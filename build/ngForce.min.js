/*! ngForce - customized by smb - 2016-05-26 */
/*! visit https://noeticpenguin.github.io/ngForce for more info. */

angular.module("ngForce", [ "Scope.safeApply", "restangular", "multipart", "ngForce.config" ]);

(function(window, document, undefined) {
    "use strict";
    angular.module("ngForce", []).factory("Backbone", [ "$http", "vfr", function($http, vfr) {
        var methodMap, sync, ajax, buildQueryString, isUndefined = _.isUndefined;
        methodMap = {
            create: "POST",
            update: "PUT",
            patch: "PATCH",
            "delete": "DELETE",
            read: "GET"
        };
        sync = function(method, model, options) {
            if (isUndefined(options)) {
                options = {};
            }
            var httpMethod = options.method || methodMap[method], params = {
                method: httpMethod
            };
            if (!options.url) {
                params.url = _.result(model, "url");
            }
            if (isUndefined(options.data) && model && (httpMethod === "POST" || httpMethod === "PUT" || httpMethod === "PATCH")) {
                params.data = JSON.stringify(options.attrs || model.toJSON(options));
            }
            if (httpMethod === "GET" && !isUndefined(options.data)) {
                params.params = options.data;
            }
            if (httpMethod === "GET") {
                params.query = _.result(model, "getQueryString");
                var xhr = vfr.query(params.query).then(function(results) {
                    if (!isUndefined(options.success) && _.isFunction(options.success)) {
                        options.success(results.records);
                        if (options.def) {
                            options.def.resolve(result.records);
                        }
                    }
                }).catch(function(err) {
                    options.error(err);
                    if (options.def) {
                        options.def.reject(err);
                    }
                }).finally(function() {});
            }
            model.trigger("request", model, xhr, _.extend(params, options));
            return xhr;
        };
        ajax = function() {
            return $http.apply($http, arguments);
        };
        buildQueryString = function(model, depth, collection) {
            var qstring = "";
            var depth = depth || 0;
            if (depth != 0) {
                qstring += "( ";
            }
            qstring += "SELECT ";
            for (var i = 0; i < model.fields.length; i++) {
                var field = model.fields[i];
                if (!field.relationship) {
                    qstring += field.name;
                } else {
                    qstring += buildQueryString(field.collection.prototype.model.prototype, depth + 1, field.collection);
                }
                if (i < model.fields.length - 1) {
                    qstring += ", ";
                }
                if (field.filters && field.filters.length > 0) {
                    qstring += "WHERE ";
                    for (var j = 0; j < field.filters.length; j++) {
                        var filter = field.filters[j];
                        qstring += filter.name += filter.operator += filter.criteria;
                    }
                }
            }
            qstring += collection ? " FROM " + collection.prototype.name : " FROM " + model.objectType;
            if (depth != 0) {
                qstring += ")";
            }
            return qstring;
        };
        return _.extend(Backbone, {
            sync: sync,
            ajax: ajax,
            buildQueryString: buildQueryString
        });
    } ]).factory("NgBackboneModel", [ "$rootScope", "Backbone", function($rootScope, Backbone) {
        var defineProperty;
        defineProperty = function(key) {
            var self = this;
            Object.defineProperty(this.$attributes, key, {
                enumerable: true,
                configurable: true,
                get: function() {
                    return self.get(key);
                },
                set: function(newValue) {
                    self.set(key, newValue);
                }
            });
        };
        return Backbone.Model.extend({
            fields: [ {
                name: "Id"
            } ],
            objectType: "Account",
            getQueryString: function() {},
            constructor: function NgBackboneModel() {
                this.$status = {
                    deleting: false,
                    loading: false,
                    saving: false,
                    syncing: false
                };
                this.on("request", function(model, xhr, options) {
                    this.$setStatus({
                        deleting: options.method === "DELETE",
                        loading: options.method === "GET",
                        saving: options.method === "POST" || options.method === "PUT",
                        syncing: true
                    });
                });
                this.on("sync error", this.$resetStatus);
                return Backbone.Model.apply(this, arguments);
            },
            initialize: function(options) {
                var self = this;
                _.map(this.fields, function(field, index) {
                    if (field.relationship && field.relationship === "OneToMany") {
                        var recordset = self.get(field.collection.prototype.name);
                        if (recordset) {
                            self.set(field.collection.prototype.name, new field.collection(self.get(field.collection.prototype.name).records));
                        } else {
                            self.set(field.collection.prototype.name, new field.collection([]));
                        }
                    }
                });
                return Backbone.Model.prototype.initialize.apply(this, arguments);
            },
            set: function(key, val, options) {
                var output = Backbone.Model.prototype.set.apply(this, arguments);
                if (output) {
                    this.$setBinding(key, val, options);
                }
                return output;
            },
            $resetStatus: function() {
                return this.$setStatus({
                    deleting: false,
                    loading: false,
                    saving: false,
                    syncing: false
                });
            },
            $setBinding: function(key, val, options) {
                var attr, attrs, unset;
                if (_.isUndefined(key)) {
                    return this;
                }
                if (_.isObject(key)) {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                options = options || {};
                if (_.isUndefined(this.$attributes)) {
                    this.$attributes = {};
                }
                unset = options.unset;
                for (attr in attrs) {
                    if (unset && this.$attributes.hasOwnProperty(attr)) {
                        delete this.$attributes[attr];
                    } else if (!unset && !this.$attributes[attr]) {
                        defineProperty.call(this, attr);
                    }
                }
                return this;
            },
            $setStatus: function(key, value, options) {
                var attr, attrs;
                if (_.isUndefined(key)) {
                    return this;
                }
                if (_.isObject(key)) {
                    attrs = key;
                    options = value;
                } else {
                    (attrs = {})[key] = value;
                }
                options = options || {};
                for (attr in this.$status) {
                    if (attrs.hasOwnProperty(attr) && _.isBoolean(attrs[attr])) {
                        this.$status[attr] = attrs[attr];
                    }
                }
            },
            $removeBinding: function(attr, options) {
                return this.$setBinding(attr, void 0, _.extend({}, options, {
                    unset: true
                }));
            }
        });
    } ]).factory("NgBackboneCollection", [ "Backbone", "NgBackboneModel", function(Backbone, NgBackboneModel) {
        return Backbone.Collection.extend({
            model: NgBackboneModel,
            getQueryString: function() {
                var querystring = "";
                querystring = Backbone.buildQueryString(this.model.prototype);
                console.log(querystring);
                return querystring;
            },
            constructor: function NgBackboneCollection() {
                var self = this;
                this.$status = {
                    deleting: false,
                    loading: false,
                    saving: false,
                    syncing: false
                };
                this.on("request", function(model, xhr, options) {
                    this.$setStatus({
                        deleting: options.method === "DELETE",
                        loading: options.method === "GET",
                        saving: options.method === "POST" || options.method === "PUT",
                        syncing: true
                    });
                });
                this.on("sync error", this.$resetStatus);
                this.on("destroy", this.$resetStatus);
                Object.defineProperty(this, "$models", {
                    enumerable: true,
                    get: function() {
                        return self.models;
                    }
                });
                Backbone.Collection.apply(this, arguments);
            },
            $setStatus: function(key, value, options) {
                var attr, attrs;
                if (_.isUndefined(key)) {
                    return this;
                }
                if (_.isObject(key)) {
                    attrs = key;
                    options = value;
                } else {
                    (attrs = {})[key] = value;
                }
                options = options || {};
                for (attr in this.$status) {
                    if (attrs.hasOwnProperty(attr) && _.isBoolean(attrs[attr])) {
                        this.$status[attr] = attrs[attr];
                    }
                }
            },
            $resetStatus: function() {
                return this.$setStatus({
                    deleting: false,
                    loading: false,
                    saving: false,
                    syncing: false
                });
            }
        });
    } ]);
})(window, document);

angular.module("ngForce").factory("encodeUriQuery", function() {
    function sortedKeys(obj) {
        var keys = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys.sort();
    }
    function forEachSorted(obj, iterator, context) {
        var keys = sortedKeys(obj);
        for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    return encodeUriQuery;
});

angular.module("multipart", []);

angular.module("multipart").service("RequestPart", function() {
    function RequestPart() {
        this.headers = [];
    }
    RequestPart.prototype.setBody = function(body) {
        this.body = body;
        switch (toString.call(body)) {
          case "[object ArrayBuffer]":
            this.bodyType = "arraybuffer";
            break;

          case "[object String]":
            this.bodyType = "string";
            break;

          case "[object Object]":
            this.bodyType = "json";
            break;

          default:
            throw Error("Unsupported multipart body type: " + toString.call(body));
        }
    };
    RequestPart.prototype.addHeader = function(name, value) {
        this.headers.push({
            name: name,
            value: value
        });
    };
    RequestPart.prototype.getRawHeaders = function() {
        var rawHeadersArr = [];
        for (var i = 0; i < this.headers.length; i++) {
            var h = this.headers[i];
            rawHeadersArr.push(h.name + ": " + h.value);
        }
        return rawHeadersArr.join("\n");
    };
    RequestPart.prototype.getBuffer = function() {
        var bufferArr = [];
        var rawHeaders = this.getRawHeaders();
        bufferArr.push(new StringView(rawHeaders).buffer);
        bufferArr.push(new StringView("\n\n").buffer);
        if (this.bodyType === "arraybuffer") {
            bufferArr.push(this.body);
        } else if (this.bodyType === "string") {
            bufferArr.push(new StringView(this.body).buffer);
        } else if (this.bodyType === "json") {
            var jsonStr = JSON.stringify(this.body);
            bufferArr.push(new StringView(jsonStr).buffer);
        }
        return joinBuffers(bufferArr);
    };
    RequestPart.prototype.toString = function() {
        return new StringView(this.getBuffer()).toString();
    };
    function joinBuffers(arrayBuffers) {
        var lengthSum = 0;
        for (var i = 0; i < arrayBuffers.length; i++) {
            lengthSum += arrayBuffers[i].byteLength;
        }
        var joined = new Uint8Array(lengthSum);
        var offset = 0;
        for (var i = 0; i < arrayBuffers.length; i++) {
            var ab = arrayBuffers[i];
            joined.set(new Uint8Array(ab), offset);
            offset += ab.byteLength;
        }
        return joined.buffer;
    }
    return RequestPart;
});

angular.module("multipart").service("MultipartRequest", [ "RequestPart", function(RequestPart) {
    function MultipartRequest(boundaryStr) {
        this.boundaryStr = boundaryStr;
        this.parts = [];
    }
    MultipartRequest.prototype.addPart = function(part) {
        this.parts.push(part);
    };
    MultipartRequest.prototype.getBuffer = function() {
        var bufferArr = [];
        bufferArr.push(new StringView("--" + this.boundaryStr + "\n").buffer);
        for (var i = 0; i < this.parts.length; i++) {
            bufferArr.push(this.parts[i].getBuffer());
            bufferArr.push(new StringView("\n\n").buffer);
            if (i !== this.parts.length - 1) {
                bufferArr.push(new StringView("--" + this.boundaryStr + "\n").buffer);
            }
        }
        bufferArr.push(new StringView("--" + this.boundaryStr + "--").buffer);
        return joinBuffers(bufferArr);
    };
    MultipartRequest.prototype.toString = function() {
        return new StringView(this.getBuffer()).toString();
    };
    function joinBuffers(arrayBuffers) {
        var lengthSum = 0;
        for (var i = 0; i < arrayBuffers.length; i++) {
            lengthSum += arrayBuffers[i].byteLength;
        }
        var joined = new Uint8Array(lengthSum);
        var offset = 0;
        for (var i = 0; i < arrayBuffers.length; i++) {
            var ab = arrayBuffers[i];
            joined.set(new Uint8Array(ab), offset);
            offset += ab.byteLength;
        }
        return joined.buffer;
    }
    return MultipartRequest;
} ]);

angular.module("ngForce").provider("remoteObjects", function() {
    var namespace = "SObjectModel";
    this.setNamespace = function(newNamespace) {
        if (!_.isUndefined(newNamespace)) {
            namespace = newNamespace;
        }
    };
    this.$get = [ "$q", "$log", function($q, $log) {
        var remoteObjects = {
            getPromiseObj: function(obj) {
                var promisedObj = {};
                promisedObj.remoteObj = new namespace[obj]();
                promisedObj.retrieve = function(options) {
                    promisedObj.remoteObj.retrieve(opts, this.handleWithPromise);
                };
                promisedObj.create = function(fvs) {
                    fvs = fvs ? fvs : promisedObj.remoteObj._props;
                    promisedObj.remoteObj.create(fvs, handleWithPromise);
                };
                promisedObj.update = function(ids, fvs) {
                    if (!angular._isArray(ids)) {
                        fvs = ids;
                        ids = null;
                    }
                    ids = ids ? ids : [ promisedObj.remoteObj._props.Id ];
                    fvs = fvs ? fvs : promisedObj.remoteObj._props;
                    promisedObj.remoteObj.update(ids, fvs, handleWithPromise);
                };
                promisedObj.del = function(ids) {
                    ids = ids ? ids : [ promisedObj.remoteObj._props.Id ];
                    promisedObj.remoteObj.del(ids, handleWithPromise);
                };
                handleWithPromise = function(err, records, e) {
                    var deferred = $q.defer();
                    if (err) {
                        deferred.reject(err);
                    } else {
                        if (e) {
                            deferred.resolve(records, e);
                        } else {
                            deferred.resolve(records);
                        }
                    }
                    return deferred.promise;
                };
                return promisedObj;
            }
        };
        return remoteObjects;
    } ];
});

angular.module("ngForce").provider("sfTemplate", function() {
    var scriptSymbolBlacklist = [ ".ajax4jsf.javascript.AjaxScript", "/js/perf/stub.js", "/sfdc/JiffyStubs.js" ];
    this.setScriptSymbolBlacklist = function(newBlacklist) {
        if (angular.isArray(newBlacklist) && newBlacklist.length > 0) {
            scriptSymbolBlacklist = newBlacklist;
        } else {
            throw new Error("newBlacklist must be an array!");
        }
    };
    this.$get = [ "$q", "$http", "$templateCache", "$log", function($q, $http, $templateCache, $log) {
        var escapeRegexp = function(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        };
        var buildScriptRegex = function(scriptNames) {
            var scriptNamesEscaped = _.map(scriptNames, escapeRegexp);
            var scriptNamePatterns = _.map(scriptNamesEscaped, function(s) {
                return ".*" + s + ".*?";
            });
            var scriptNameOptions = "(" + scriptNamePatterns.join("|") + ")";
            var scriptTagPattern = '<script src="' + scriptNameOptions + '"></script>';
            var scriptTagRegex = new RegExp(scriptTagPattern, "gi");
            return scriptTagRegex;
        };
        var stripScriptTags = function(htmlTemplate) {
            var badScriptRegex = buildScriptRegex(scriptSymbolBlacklist);
            var cleanedHtmlTemplate = htmlTemplate.replace(badScriptRegex, "");
            return cleanedHtmlTemplate;
        };
        var sfTemplate = {
            fromVf: function(url) {
                var pTemplate = $http.get(url, {
                    cache: $templateCache
                }).then(function(response) {
                    return response.data;
                }).then(stripScriptTags);
                return pTemplate;
            }
        };
        return sfTemplate;
    } ];
});

angular.module("ngForce").factory("sfr", [ "$q", "$rootScope", "Restangular", "$log", function($q, $rootScope, Restangular, $log, ngForceConfig) {
    var sobjectEndpoints = [];
    var recordEndpoints = [];
    var sfRest = {
        model: function(modelName, recordId) {
            var baseResource = Restangular.setDefaultHeaders({
                Authorization: "Bearer " + ngForceConfig.sessionId
            }).setBaseUrl("/services/data/v29.0/sobjects/").setRestangularFields({
                id: "Id",
                selfLink: "attributes.url"
            });
            var resource;
            if (recordId) resource = baseResource.one(modelName, recordId); else resource = baseResource.all(modelName);
            return resource;
        },
        insert: function(sObjectName, recordToInsert, getLatest) {
            var $defer = $q.defer();
            if (!angular.isString(sObjectName)) {
                $defer.reject("An sObject name is required to perform insert.");
                return $defer.promise;
            }
            var _getLatest = angular.isDefined(getLatest) ? getLatest : false;
            var sObjectEndpoint = sobjectEndpoints[sObjectName];
            if (angular.isUndefined(sObjectEndpoint)) {
                sObjectEndpoint = this.model(sObjectName);
                sobjectEndpoints[sObjectName] = sObjectEndpoint;
            }
            return sObjectEndpoint.post(recordToInsert).then(function(response) {
                if (response.success) {
                    $log.debug("ngForce: Created new " + sObjectName + " record:", response);
                    $defer.resolve(response);
                    if (!_getLatest) {
                        return $defer.promise;
                    }
                    return sObjectEndpoint.get(response.id).then(function(newRecord) {
                        $log.debug("ngForce: Inserted:", newRecord);
                        return newRecord;
                    });
                } else {
                    $defer.reject("Insert failed: [" + response.errors + "] Full response: " + response);
                }
                return $defer.promise;
            });
        },
        update: function(sObjectName, recordToUpdate, getLatest) {
            var $defer = $q.defer();
            if (!angular.isString(sObjectName)) {
                $defer.reject("An sObject name is required to perform an update.");
                return $defer.promise;
            }
            var _getLatest = angular.isDefined(getLatest) ? getLatest : false;
            var recordId = recordToUpdate.id || recordToUpdate.Id;
            if (!angular.isString(recordId)) {
                $defer.reject('An "Id" field is required to perform an update.');
                return $defer.promise;
            }
            var recordEndpoint = recordEndpoints[recordId];
            if (angular.isUndefined(recordEndpoint)) {
                recordEndpoint = this.model(sObjectName, recordId);
                recordEndpoints[recordId] = recordEndpoint;
            }
            var propsToIgnore = [ "Id", "LastReferencedDate", "LastModifiedById", "LastModifiedDate", "LastViewedDate", "SystemModstamp", "CreatedById", "CreatedDate", "IsDeleted" ];
            for (var i = 0; i < propsToIgnore.length; i++) {
                var p = propsToIgnore[i];
                delete recordToUpdate[p];
            }
            return recordEndpoint.patch(recordToUpdate).then(function(response) {
                $log.debug("ngForce: Patched " + sObjectName + " record:", recordToUpdate);
                if (!_getLatest) {
                    $defer.resolve("Patch successful!");
                    return $defer.promise;
                }
                return recordEndpoint.get().then(function(newRecord) {
                    $log.debug("ngForce: Updated " + sObjectName + " record:", response);
                    return newRecord;
                });
            });
        },
        "delete": function(sObjectName, recordToDelete) {
            var $defer = $q.defer();
            if (!angular.isString(sObjectName)) {
                $defer.reject("An sObject name is required to perform a delete.");
                return $defer.promise;
            }
            var recordId = recordToDelete.id || recordToDelete.Id;
            if (!angular.isString(recordId)) {
                $defer.reject('An "Id" field is required to perform a delete.');
                return $defer.promise;
            }
            var recordEndpoint = recordEndpoints[recordId];
            if (angular.isUndefined(recordEndpoint)) {
                recordEndpoint = this.model(sObjectName, recordId);
                recordEndpoints[recordId] = recordEndpoint;
            }
            return recordEndpoint.remove().then(function(response, err) {
                $log.debug("ngForce: Deleted " + sObjectName + " record:", recordId);
                $defer.resolve("Delete successful!");
                return $defer.promise;
            });
        }
    };
    return sfRest;
} ]);

"use strict";

angular.module("ngForce").factory("sfranalytics", [ "$q", "$rootScope", "Restangular", function($q, $rootScope, Restangular, ngForceConfig) {
    var _baseUrl = "/services/data/v29.0/analytics/";
    var _additionalHeaders = {
        Authorization: "Bearer " + ngForceConfig.sessionId
    };
    var _analytics = Restangular.withConfig(function(RestangularConfigurer) {
        RestangularConfigurer.setBaseUrl(_baseUrl);
        RestangularConfigurer.setDefaultHeaders(_additionalHeaders);
    }).setRestangularFields({
        id: "Id"
    });
    return {
        analytics: function() {
            return _analytics.all("reports");
        },
        reports: {
            metadata: function(reportId) {
                return _analytics.one("reports", reportId).get("metadata");
            },
            run: function(reportId, config) {
                if (typeof config !== "object") {
                    config = {};
                }
                if (config.async === true) {
                    throw "Asnynchronous report runs are not supported at this time";
                }
                var queryParams = {};
                if (config.includeDetails === true || config.includeDetails === false) {
                    queryParams.includeDetails = config.includeDetails;
                }
                var ondemandFiltering = config.reportFilters && config.reportFilters.length > 0;
                if (ondemandFiltering === true) {
                    var deferred = $q.defer();
                    this.metadata(reportId).then(function(response) {
                        var metadata = response.reportMetadata;
                        if (typeof config.reportBooleanFilter === "string" || config.reportBooleanFilter === null) {
                            metadata.reportBooleanFilter = config.reportBooleanFilter;
                        }
                        if (Object.prototype.toString.call(config.reportFilters) === "[object Array]") {
                            metadata.reportFilters = config.reportFilters;
                        }
                        _analytics.one("reports").post(reportId, {
                            reportMetadata: metadata
                        }, queryParams).then(function(response) {
                            deferred.resolve(response);
                        }, function(errorResponse) {
                            deferred.reject(errorResponse);
                        });
                    });
                    return deferred.promise;
                } else {
                    return _analytics.one("reports", reportId).get(queryParams);
                }
            }
        },
        dashboard: {}
    };
} ]);

angular.module("ngForce").factory("sfrBackend", [ "$q", "$rootScope", "$log", "$httpBackend", "encodeUriQuery", function($q, $rootScope, $log, $httpBackend, encodeUriQuery) {
    var escapeRegexp = function(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    };
    var sfrBackend = {
        whenGetPage: function(pageName, responsePage) {
            var _pageName = pageName;
            if (_pageName.indexOf("/apex/") == -1) {
                _pageName = "/apex/" + _pageName;
            }
            var escapedPageName = escapeRegexp(_pageName);
            $httpBackend.whenGET(new RegExp(escapedPageName, "i")).respond(responsePage);
        },
        whenQuery: function(sObjectName, resRecords, soqlClauses) {
            var _soqlClauses = angular.isString(soqlClauses) ? [ soqlClauses ] : soqlClauses;
            var _resRecords = !angular.isArray(resRecords) ? [ resRecords ] : resRecords;
            var encodedSoqlRegex = "query.*FROM\\++" + sObjectName;
            if (typeof _soqlClauses != "undefined" && _soqlClauses !== null) {
                var encodedSoqlClauses = _.chain(_soqlClauses).map(function(value, key) {
                    return encodeUriQuery(value);
                }).foldl(function(memo, value) {
                    return memo += value;
                }).value();
                encodedSoqlRegex += "\\++WHERE.*" + escapeRegexp(encodedSoqlClauses);
            }
            $httpBackend.whenGET(new RegExp(encodedSoqlRegex, "i")).respond(200, {
                totalSize: _resRecords.length,
                done: true,
                records: _resRecords
            });
        },
        expectQuery: function(sObjectName, resRecords, soqlClauses) {
            var _soqlClauses = angular.isString(soqlClauses) ? [ soqlClauses ] : soqlClauses;
            var _resRecords = !angular.isArray(resRecords) ? [ resRecords ] : resRecords;
            var encodedSoqlRegex = "query.*FROM\\++" + sObjectName;
            if (typeof _soqlClauses != "undefined" && _soqlClauses !== null) {
                var encodedSoqlClauses = _.chain(_soqlClauses).map(function(value, key) {
                    return encodeUriQuery(value);
                }).foldl(function(memo, value) {
                    return memo += value;
                }).value();
                encodedSoqlRegex += "\\++WHERE.*" + escapeRegexp(encodedSoqlClauses);
            }
            $httpBackend.expectGET(new RegExp(encodedSoqlRegex, "i")).respond(200, {
                totalSize: _resRecords.length,
                done: true,
                records: _resRecords
            });
        },
        expectInsert: function(sObjectName, resRecords, getLatest) {
            var _resRecords = !angular.isArray(resRecords) ? [ resRecords ] : resRecords;
            var _getLatest = getLatest || true;
            angular.forEach(_resRecords, function(resRecord, key) {
                $httpBackend.expectPOST(new RegExp(sObjectName, "i")).respond(201, {
                    id: resRecord.Id,
                    success: true,
                    errors: []
                });
                if (!_getLatest) {
                    $httpBackend.expectGET(new RegExp(sObjectName + "/" + resRecord.Id, "i")).respond(200, resRecord);
                }
            });
        },
        expectDelete: function(sObjectName, recordIds) {
            recordIds = recordIds || "";
            var _recordIds = !angular.isArray(recordIds) ? [ recordIds ] : recordIds;
            angular.forEach(_recordIds, function(recordId) {
                $httpBackend.expectDELETE(new RegExp(sObjectName + "/" + recordId, "i")).respond(201, {});
            });
        }
    };
    return sfrBackend;
} ]);

angular.module("ngForce").factory("sfrfile", [ "$q", "$rootScope", "$log", "Restangular", "MultipartRequest", "RequestPart", "ngForceConfig", function($q, $rootScope, $log, Restangular, MultipartRequest, RequestPart, ngForceConfig) {
    var sfrfile = Restangular.withConfig(function(RestangularConfigurer) {
        RestangularConfigurer.setDefaultHttpFields({
            cache: false,
            transformRequest: function(data) {
                return data;
            }
        });
        RestangularConfigurer.setBaseUrl("/services/data/v29.0/sobjects");
        RestangularConfigurer.setDefaultHeaders({
            Authorization: "Bearer " + ngForceConfig.sessionId
        });
    }).setRestangularFields({
        id: "Id",
        selfLink: "attributes.url"
    });
    sfrfile.insert = function(sObjectName, sObjectData, filename, fileBuffer) {
        SObjectType = {
            Document: {
                jsonPartName: "entity_document",
                binaryPartName: "Body"
            },
            Attachment: {
                jsonPartName: "entity_attachment",
                binaryPartName: "Body"
            },
            ContentVersion: {
                jsonPartName: "entity_content",
                binaryPartName: "VersionData"
            }
        };
        var mySObjectType = SObjectType[sObjectName];
        if (typeof mySObjectType === undefined) {
            throw new Error("Upload not supported for SObject type '" + sObjectName + "'");
        }
        var binaryNameAttr;
        var boundaryStr = "boundary_string";
        var req = new MultipartRequest(boundaryStr);
        var sobjectDataPart = new RequestPart();
        sobjectDataPart.addHeader("Content-Disposition", 'form-data; name="' + mySObjectType.jsonPartName + '";');
        sobjectDataPart.addHeader("Content-Type", "application/json");
        sobjectDataPart.setBody(sObjectData);
        req.addPart(sobjectDataPart);
        var filePart = new RequestPart();
        filePart.addHeader("Content-Type", "application/octet-stream");
        filePart.addHeader("Content-Disposition", 'form-data; name="' + mySObjectType.binaryPartName + '"; filename="' + filename + '"');
        filePart.setBody(fileBuffer);
        req.addPart(filePart);
        var bufferView = new Uint8Array(req.getBuffer());
        return sfrfile.all(sObjectName).post(bufferView, null, {
            "Content-Type": 'multipart/form-data; boundary="' + boundaryStr + '"'
        }).then(function(response) {
            return response;
        });
    };
    return sfrfile;
} ]);

angular.module("ngForce").factory("sfrquery", [ "$q", "$rootScope", "$log", "Restangular", "encodeUriQuery", "ngForceConfig", function($q, $rootScope, $log, Restangular, encodeUriQuery, ngForceConfig) {
    var sfrquery = Restangular.withConfig(function(RestangularConfigurer) {
        RestangularConfigurer.setDefaultHttpFields({
            cache: false
        });
        RestangularConfigurer.setBaseUrl("/services/data/v30.0/");
        RestangularConfigurer.setDefaultHeaders({
            Authorization: "Bearer " + ngForceConfig.sessionId
        });
    }).setRestangularFields({
        id: "Id",
        selfLink: "attributes.url"
    }).oneUrl("query", "/services/data/v30.0/query");
    sfrquery.query = function(query, cacheEnabled) {
        cacheEnabled = typeof cacheEnabled !== "undefined" ? cacheEnabled : false;
        return sfrquery.withHttpConfig({
            cache: cacheEnabled
        }).get({
            q: query
        }).then(function(response) {
            return response.records;
        });
    };
    sfrquery.queryAll = function(queryStringOrQueryLocator, cacheEnabled, deferred, results) {
        if (angular.isUndefined(cacheEnabled)) {
            cacheEnabled = true;
        }
        if (angular.isUndefined(results)) {
            results = [];
        }
        if (angular.isUndefined(deferred)) {
            deferred = $q.defer();
        }
        if (queryStringOrQueryLocator.trim().substring(0, 6).toLowerCase() === "select") {
            queryStringOrQueryLocator = "?q=" + encodeUriQuery(queryStringOrQueryLocator);
        }
        sfrquery.withHttpConfig({
            cache: cacheEnabled
        }).customGET(queryStringOrQueryLocator).then(function(data) {
            results = results.concat(data.records);
            if (!data.done) {
                sfrquery.queryAll(_.last(data.nextRecordsUrl.split("/")), cacheEnabled, deferred, results);
            } else {
                deferred.resolve(results);
                return deferred.promise;
            }
        }, function(error) {
            return deferred.reject(error);
        });
        deferred.notify();
        return deferred.promise;
    };
    return sfrquery;
} ]);

angular.module("ngForce").provider("vfr", function() {
    if (typeof Visualforce != "object") {
        throw new Error("Visualforce is not available as an object! Did you forget to include the ngForce component?");
    }
    var vfRemote = {};
    var standardOpts = {
        escape: false,
        timeout: 1e4
    };
    return {
        setStandardOptions: function(newOptions) {
            if (newOptions && typeof newOptions !== "object") {
                throw new Error("standardOptions must be an object");
            }
            standardOpts = newOptions;
        },
        $get: [ "$q", "$rootScope", function($q, $rootScope) {
            function send(remoteAction, options, nullok) {
                var namespace, controller, method;
                var Manager = Visualforce.remoting.Manager;
                var parts = remoteAction.split(".");
                if (options && typeof options !== "object") {
                    throw new Error("Options must be an object");
                }
                if (parts.length < 2) {
                    throw new Error("Invalid Remote Action specified. Use Controller.MethodName or $RemoteAction.Controller.MethodName");
                } else {
                    if (parts.length === 3) {
                        namespace = parts[0];
                        controller = parts[1];
                        method = parts[2];
                    } else if (parts.length === 2) {
                        controller = parts[0];
                        method = parts[1];
                    }
                }
                return function() {
                    var deferred = $q.defer();
                    var args;
                    if (arguments.length) {
                        args = Array.prototype.slice.apply(arguments);
                    } else {
                        args = [];
                    }
                    args.splice(0, 0, remoteAction);
                    args.push(function(result, event) {
                        handleResultWithPromise(result, event, nullok, deferred);
                    });
                    if (options) {
                        args.push(options);
                    }
                    Manager.invokeAction.apply(Manager, args);
                    return deferred.promise;
                };
            }
            function handleResultWithPromise(result, event, nullok, deferred) {
                if (result) {
                    if (typeof result !== "object") {
                        result = JSON.parse(result);
                    }
                    if (Array.isArray(result) && result.length !== 0 && result[0].message && result[0].errorCode) {
                        deferred.reject(result);
                        $rootScope.$safeApply();
                    } else {
                        deferred.resolve(result);
                        $rootScope.$safeApply();
                    }
                } else if (event && event.status === false) {
                    deferred.reject({
                        message: event.message,
                        method: event.method,
                        where: event.where,
                        errorCode: event.type === "exception" ? "EXCEPTION" : "UNSPECIFIED_ERROR"
                    });
                    $rootScope.$safeApply();
                } else if (typeof nullok !== "undefined" && nullok) {
                    deferred.resolve();
                    $rootScope.$safeApply();
                } else {
                    deferred.reject({
                        message: "Null returned by RemoteAction not called with nullOk flag",
                        errorCode: "NULL_RETURN"
                    });
                    $rootScope.$safeApply();
                }
            }
            return {
                send: send,
                standardOptions: standardOpts,
                bulkCreate: send("ngForceController.bulkCreate", this.standardOptions, false),
                bulkDelete: send("ngForceController.bulkDelete", this.standardOptions, false),
                bulkUpdate: send("ngForceController.bulkUpdate", this.standardOptions, false),
                bulkUpsert: send("ngForceController.bulkUpsert", this.standardOptions, false),
                create: send("ngForceController.create", this.standardOptions, false),
                clone: send("ngForceController.sObjectKlone", this.standardOptions, false),
                del: send("ngForceController.del", this.standardOptions, true),
                describe: send("ngForceController.describe", this.standardOptions, false),
                describeFieldSet: send("ngForceController.describeFieldSet", this.standardOptions, false),
                describePicklistValues: send("ngForceController.getPicklistValues", this.standardOptions, false),
                getObjectType: send("ngForceController.getObjType", this.standardOptions, false),
                getQueryResultsAsSelect2Data: send("ngForceController.getQueryResultsAsSelect2Data", this.standardOptions, false),
                query: send("ngForceController.query", {
                    escape: false,
                    timeout: 3e4
                }, false),
                queryFromFieldset: send("ngForceController.queryFromFieldSet", {
                    escape: false,
                    timeout: 3e4
                }, false),
                retrieve: send("ngForceController.retrieve", this.standardOptions, false),
                search: send("ngForceController.search", this.standardOptions, false),
                soqlFromFieldSet: send("ngForceController.soqlFromFieldSet", this.standardOptions, false),
                update: send("ngForceController.updat", this.standardOptions, true),
                upsert: send("ngForceController.upser", this.standardOptions, true)
            };
        } ]
    };
});
//# sourceMappingURL=ngForce.min.js.map