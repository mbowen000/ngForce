/*! ngForce - customized by smb - 2016-03-03 */
/*! visit https://noeticpenguin.github.io/ngForce for more info. */

(function() {
    var undefined;
    var arrayPool = [], objectPool = [];
    var idCounter = 0;
    var indicatorObject = {};
    var keyPrefix = +new Date() + "";
    var largeArraySize = 75;
    var maxPoolSize = 40;
    var whitespace = " 	\x0B\f \ufeff" + "\n\r\u2028\u2029" + " ᠎             　";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reFuncName = /^\s*function[ \n\r\t]+\w/;
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
    var reNoMatch = /($^)/;
    var reThis = /\bthis\b/;
    var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
    var contextProps = [ "Array", "Boolean", "Date", "Error", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
    var shadowedProps = [ "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf" ];
    var templateCounter = 0;
    var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", errorClass = "[object Error]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
    var cloneableClasses = {};
    cloneableClasses[funcClass] = false;
    cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
    var debounceOptions = {
        leading: false,
        maxWait: 0,
        trailing: false
    };
    var descriptor = {
        configurable: false,
        enumerable: false,
        value: null,
        writable: false
    };
    var iteratorData = {
        args: "",
        array: null,
        bottom: "",
        firstArg: "",
        init: "",
        keys: null,
        loop: "",
        shadowedProps: null,
        support: null,
        top: "",
        useHas: false
    };
    var objectTypes = {
        "boolean": false,
        "function": true,
        object: true,
        number: false,
        string: false,
        undefined: false
    };
    var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    };
    var root = objectTypes[typeof window] && window || this;
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    var freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
    }
    function baseIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == "boolean" || value == null) {
            return cache[value] ? 0 : -1;
        }
        if (type != "number" && type != "string") {
            type = "object";
        }
        var key = type == "number" ? value : keyPrefix + value;
        cache = (cache = cache[type]) && cache[key];
        return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
    }
    function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if (type == "boolean" || value == null) {
            cache[value] = true;
        } else {
            if (type != "number" && type != "string") {
                type = "object";
            }
            var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
            if (type == "object") {
                (typeCache[key] || (typeCache[key] = [])).push(value);
            } else {
                typeCache[key] = true;
            }
        }
    }
    function charAtCallback(value) {
        return value.charCodeAt(0);
    }
    function compareAscending(a, b) {
        var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
        while (++index < length) {
            var value = ac[index], other = bc[index];
            if (value !== other) {
                if (value > other || typeof value == "undefined") {
                    return 1;
                }
                if (value < other || typeof other == "undefined") {
                    return -1;
                }
            }
        }
        return a.index - b.index;
    }
    function createCache(array) {
        var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
        if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
            return false;
        }
        var cache = getObject();
        cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
            result.push(array[index]);
        }
        return result;
    }
    function escapeStringChar(match) {
        return "\\" + stringEscapes[match];
    }
    function getArray() {
        return arrayPool.pop() || [];
    }
    function getObject() {
        return objectPool.pop() || {
            array: null,
            cache: null,
            criteria: null,
            "false": false,
            index: 0,
            "null": false,
            number: null,
            object: null,
            push: null,
            string: null,
            "true": false,
            undefined: false,
            value: null
        };
    }
    function isNode(value) {
        return typeof value.toString != "function" && typeof (value + "") == "string";
    }
    function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
            arrayPool.push(array);
        }
    }
    function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
            releaseObject(cache);
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
            objectPool.push(object);
        }
    }
    function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == "undefined") {
            end = array ? array.length : 0;
        }
        var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
        while (++index < length) {
            result[index] = array[start + index];
        }
        return result;
    }
    function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayRef = [];
        var errorProto = Error.prototype, objectProto = Object.prototype, stringProto = String.prototype;
        var oldDash = context._;
        var toString = objectProto.toString;
        var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
        var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
        var defineProperty = function() {
            try {
                var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
            } catch (e) {}
            return result;
        }();
        var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp;
        ctorByClass[stringClass] = String;
        var nonEnumProps = {};
        nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
            constructor: true,
            toLocaleString: true,
            toString: true,
            valueOf: true
        };
        nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
            constructor: true,
            toString: true,
            valueOf: true
        };
        nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
            constructor: true,
            toString: true
        };
        nonEnumProps[objectClass] = {
            constructor: true
        };
        (function() {
            var length = shadowedProps.length;
            while (length--) {
                var key = shadowedProps[length];
                for (var className in nonEnumProps) {
                    if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
                        nonEnumProps[className][key] = false;
                    }
                }
            }
        })();
        function lodash(value) {
            return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll;
            this.__wrapped__ = value;
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        (function() {
            var ctor = function() {
                this.x = 1;
            }, object = {
                "0": 1,
                length: 1
            }, props = [];
            ctor.prototype = {
                valueOf: 1,
                y: 1
            };
            for (var key in new ctor()) {
                props.push(key);
            }
            for (key in arguments) {}
            support.argsClass = toString.call(arguments) == argsClass;
            support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);
            support.enumErrorProps = propertyIsEnumerable.call(errorProto, "message") || propertyIsEnumerable.call(errorProto, "name");
            support.enumPrototypes = propertyIsEnumerable.call(ctor, "prototype");
            support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
            support.funcNames = typeof Function.name == "string";
            support.nonEnumArgs = key != 0;
            support.nonEnumShadows = !/valueOf/.test(props);
            support.ownLast = props[0] != "x";
            support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
            support.unindexedChars = "x"[0] + Object("x")[0] != "xx";
            try {
                support.nodeClass = !(toString.call(document) == objectClass && !({
                    toString: 0
                } + ""));
            } catch (e) {
                support.nodeClass = true;
            }
        })(1);
        lodash.templateSettings = {
            escape: /<%-([\s\S]+?)%>/g,
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: reInterpolate,
            variable: "",
            imports: {
                _: lodash
            }
        };
        var iteratorTemplate = function(obj) {
            var __p = "var index, iterable = " + obj.firstArg + ", result = " + obj.init + ";\nif (!iterable) return result;\n" + obj.top + ";";
            if (obj.array) {
                __p += "\nvar length = iterable.length; index = -1;\nif (" + obj.array + ") {  ";
                if (support.unindexedChars) {
                    __p += "\n  if (isString(iterable)) {\n    iterable = iterable.split('')\n  }  ";
                }
                __p += "\n  while (++index < length) {\n    " + obj.loop + ";\n  }\n}\nelse {  ";
            } else if (support.nonEnumArgs) {
                __p += "\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += '';\n      " + obj.loop + ";\n    }\n  } else {  ";
            }
            if (support.enumPrototypes) {
                __p += "\n  var skipProto = typeof iterable == 'function';\n  ";
            }
            if (support.enumErrorProps) {
                __p += "\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ";
            }
            var conditions = [];
            if (support.enumPrototypes) {
                conditions.push('!(skipProto && index == "prototype")');
            }
            if (support.enumErrorProps) {
                conditions.push('!(skipErrorProps && (index == "message" || index == "name"))');
            }
            if (obj.useHas && obj.keys) {
                __p += "\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n";
                if (conditions.length) {
                    __p += "    if (" + conditions.join(" && ") + ") {\n  ";
                }
                __p += obj.loop + ";    ";
                if (conditions.length) {
                    __p += "\n    }";
                }
                __p += "\n  }  ";
            } else {
                __p += "\n  for (index in iterable) {\n";
                if (obj.useHas) {
                    conditions.push("hasOwnProperty.call(iterable, index)");
                }
                if (conditions.length) {
                    __p += "    if (" + conditions.join(" && ") + ") {\n  ";
                }
                __p += obj.loop + ";    ";
                if (conditions.length) {
                    __p += "\n    }";
                }
                __p += "\n  }    ";
                if (support.nonEnumShadows) {
                    __p += "\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ";
                    for (k = 0; k < 7; k++) {
                        __p += "\n    index = '" + obj.shadowedProps[k] + "';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))";
                        if (!obj.useHas) {
                            __p += " || (!nonEnum[index] && iterable[index] !== objectProto[index])";
                        }
                        __p += ") {\n      " + obj.loop + ";\n    }      ";
                    }
                    __p += "\n  }    ";
                }
            }
            if (obj.array || support.nonEnumArgs) {
                __p += "\n}";
            }
            __p += obj.bottom + ";\nreturn result";
            return __p;
        };
        function baseBind(bindData) {
            var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
            function bound() {
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (this instanceof bound) {
                    var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisArg, args || arguments);
            }
            setBindData(bound, bindData);
            return bound;
        }
        function baseClone(value, isDeep, callback, stackA, stackB) {
            if (callback) {
                var result = callback(value);
                if (typeof result != "undefined") {
                    return result;
                }
            }
            var isObj = isObject(value);
            if (isObj) {
                var className = toString.call(value);
                if (!cloneableClasses[className] || !support.nodeClass && isNode(value)) {
                    return value;
                }
                var ctor = ctorByClass[className];
                switch (className) {
                  case boolClass:
                  case dateClass:
                    return new ctor(+value);

                  case numberClass:
                  case stringClass:
                    return new ctor(value);

                  case regexpClass:
                    result = ctor(value.source, reFlags.exec(value));
                    result.lastIndex = value.lastIndex;
                    return result;
                }
            } else {
                return value;
            }
            var isArr = isArray(value);
            if (isDeep) {
                var initedStack = !stackA;
                stackA || (stackA = getArray());
                stackB || (stackB = getArray());
                var length = stackA.length;
                while (length--) {
                    if (stackA[length] == value) {
                        return stackB[length];
                    }
                }
                result = isArr ? ctor(value.length) : {};
            } else {
                result = isArr ? slice(value) : assign({}, value);
            }
            if (isArr) {
                if (hasOwnProperty.call(value, "index")) {
                    result.index = value.index;
                }
                if (hasOwnProperty.call(value, "input")) {
                    result.input = value.input;
                }
            }
            if (!isDeep) {
                return result;
            }
            stackA.push(value);
            stackB.push(result);
            (isArr ? baseEach : forOwn)(value, function(objValue, key) {
                result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
            });
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB);
            }
            return result;
        }
        function baseCreate(prototype, properties) {
            return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        if (!nativeCreate) {
            baseCreate = function() {
                function Object() {}
                return function(prototype) {
                    if (isObject(prototype)) {
                        Object.prototype = prototype;
                        var result = new Object();
                        Object.prototype = null;
                    }
                    return result || context.Object();
                };
            }();
        }
        function baseCreateCallback(func, thisArg, argCount) {
            if (typeof func != "function") {
                return identity;
            }
            if (typeof thisArg == "undefined" || !("prototype" in func)) {
                return func;
            }
            var bindData = func.__bindData__;
            if (typeof bindData == "undefined") {
                if (support.funcNames) {
                    bindData = !func.name;
                }
                bindData = bindData || !support.funcDecomp;
                if (!bindData) {
                    var source = fnToString.call(func);
                    if (!support.funcNames) {
                        bindData = !reFuncName.test(source);
                    }
                    if (!bindData) {
                        bindData = reThis.test(source);
                        setBindData(func, bindData);
                    }
                }
            }
            if (bindData === false || bindData !== true && bindData[1] & 1) {
                return func;
            }
            switch (argCount) {
              case 1:
                return function(value) {
                    return func.call(thisArg, value);
                };

              case 2:
                return function(a, b) {
                    return func.call(thisArg, a, b);
                };

              case 3:
                return function(value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };

              case 4:
                return function(accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };
            }
            return bind(func, thisArg);
        }
        function baseCreateWrapper(bindData) {
            var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
            function bound() {
                var thisBinding = isBind ? thisArg : this;
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (partialRightArgs || isCurry) {
                    args || (args = slice(arguments));
                    if (partialRightArgs) {
                        push.apply(args, partialRightArgs);
                    }
                    if (isCurry && args.length < arity) {
                        bitmask |= 16 & ~32;
                        return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
                    }
                }
                args || (args = arguments);
                if (isBindKey) {
                    func = thisBinding[key];
                }
                if (this instanceof bound) {
                    thisBinding = baseCreate(func.prototype);
                    var result = func.apply(thisBinding, args);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisBinding, args);
            }
            setBindData(bound, bindData);
            return bound;
        }
        function baseDifference(array, values) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
            if (isLarge) {
                var cache = createCache(values);
                if (cache) {
                    indexOf = cacheIndexOf;
                    values = cache;
                } else {
                    isLarge = false;
                }
            }
            while (++index < length) {
                var value = array[index];
                if (indexOf(values, value) < 0) {
                    result.push(value);
                }
            }
            if (isLarge) {
                releaseObject(values);
            }
            return result;
        }
        function baseFlatten(array, isShallow, isStrict, fromIndex) {
            var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                    if (!isShallow) {
                        value = baseFlatten(value, isShallow, isStrict);
                    }
                    var valIndex = -1, valLength = value.length, resIndex = result.length;
                    result.length += valLength;
                    while (++valIndex < valLength) {
                        result[resIndex++] = value[valIndex];
                    }
                } else if (!isStrict) {
                    result.push(value);
                }
            }
            return result;
        }
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            if (callback) {
                var result = callback(a, b);
                if (typeof result != "undefined") {
                    return !!result;
                }
            }
            if (a === b) {
                return a !== 0 || 1 / a == 1 / b;
            }
            var type = typeof a, otherType = typeof b;
            if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                return false;
            }
            if (a == null || b == null) {
                return a === b;
            }
            var className = toString.call(a), otherClass = toString.call(b);
            if (className == argsClass) {
                className = objectClass;
            }
            if (otherClass == argsClass) {
                otherClass = objectClass;
            }
            if (className != otherClass) {
                return false;
            }
            switch (className) {
              case boolClass:
              case dateClass:
                return +a == +b;

              case numberClass:
                return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

              case regexpClass:
              case stringClass:
                return a == String(b);
            }
            var isArr = className == arrayClass;
            if (!isArr) {
                var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                if (aWrapped || bWrapped) {
                    return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                }
                if (className != objectClass || !support.nodeClass && (isNode(a) || isNode(b))) {
                    return false;
                }
                var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor, ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
                if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
                    return false;
                }
            }
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == a) {
                    return stackB[length] == b;
                }
            }
            var size = 0;
            result = true;
            stackA.push(a);
            stackB.push(b);
            if (isArr) {
                length = a.length;
                size = b.length;
                result = size == length;
                if (result || isWhere) {
                    while (size--) {
                        var index = length, value = b[size];
                        if (isWhere) {
                            while (index--) {
                                if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                    break;
                                }
                            }
                        } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                            break;
                        }
                    }
                }
            } else {
                forIn(b, function(value, key, b) {
                    if (hasOwnProperty.call(b, key)) {
                        size++;
                        return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                    }
                });
                if (result && !isWhere) {
                    forIn(a, function(value, key, a) {
                        if (hasOwnProperty.call(a, key)) {
                            return result = --size > -1;
                        }
                    });
                }
            }
            stackA.pop();
            stackB.pop();
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB);
            }
            return result;
        }
        function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                var found, isArr, result = source, value = object[key];
                if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                    var stackLength = stackA.length;
                    while (stackLength--) {
                        if (found = stackA[stackLength] == source) {
                            value = stackB[stackLength];
                            break;
                        }
                    }
                    if (!found) {
                        var isShallow;
                        if (callback) {
                            result = callback(value, source);
                            if (isShallow = typeof result != "undefined") {
                                value = result;
                            }
                        }
                        if (!isShallow) {
                            value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                        }
                        stackA.push(source);
                        stackB.push(value);
                        if (!isShallow) {
                            baseMerge(value, source, callback, stackA, stackB);
                        }
                    }
                } else {
                    if (callback) {
                        result = callback(value, source);
                        if (typeof result == "undefined") {
                            result = source;
                        }
                    }
                    if (typeof result != "undefined") {
                        value = result;
                    }
                }
                object[key] = value;
            });
        }
        function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseUniq(array, isSorted, callback) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
            var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
            if (isLarge) {
                var cache = createCache(seen);
                indexOf = cacheIndexOf;
                seen = cache;
            }
            while (++index < length) {
                var value = array[index], computed = callback ? callback(value, index, array) : value;
                if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                    if (callback || isLarge) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
            }
            if (isLarge) {
                releaseArray(seen.array);
                releaseObject(seen);
            } else if (callback) {
                releaseArray(seen);
            }
            return result;
        }
        function createAggregator(setter) {
            return function(collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg, 3);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, callback(value, index, collection), collection);
                    }
                } else {
                    baseEach(collection, function(value, key, collection) {
                        setter(result, value, callback(value, key, collection), collection);
                    });
                }
                return result;
            };
        }
        function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
            if (!isBindKey && !isFunction(func)) {
                throw new TypeError();
            }
            if (isPartial && !partialArgs.length) {
                bitmask &= ~16;
                isPartial = partialArgs = false;
            }
            if (isPartialRight && !partialRightArgs.length) {
                bitmask &= ~32;
                isPartialRight = partialRightArgs = false;
            }
            var bindData = func && func.__bindData__;
            if (bindData && bindData !== true) {
                bindData = slice(bindData);
                if (bindData[2]) {
                    bindData[2] = slice(bindData[2]);
                }
                if (bindData[3]) {
                    bindData[3] = slice(bindData[3]);
                }
                if (isBind && !(bindData[1] & 1)) {
                    bindData[4] = thisArg;
                }
                if (!isBind && bindData[1] & 1) {
                    bitmask |= 8;
                }
                if (isCurry && !(bindData[1] & 4)) {
                    bindData[5] = arity;
                }
                if (isPartial) {
                    push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                }
                if (isPartialRight) {
                    unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                }
                bindData[1] |= bitmask;
                return createWrapper.apply(null, bindData);
            }
            var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
            return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
        }
        function createIterator() {
            iteratorData.shadowedProps = shadowedProps;
            iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = "";
            iteratorData.init = "iterable";
            iteratorData.useHas = true;
            for (var object, index = 0; object = arguments[index]; index++) {
                for (var key in object) {
                    iteratorData[key] = object[key];
                }
            }
            var args = iteratorData.args;
            iteratorData.firstArg = /^[^,]+/.exec(args)[0];
            var factory = Function("baseCreateCallback, errorClass, errorProto, hasOwnProperty, " + "indicatorObject, isArguments, isArray, isString, keys, objectProto, " + "objectTypes, nonEnumProps, stringClass, stringProto, toString", "return function(" + args + ") {\n" + iteratorTemplate(iteratorData) + "\n}");
            return factory(baseCreateCallback, errorClass, errorProto, hasOwnProperty, indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString);
        }
        function escapeHtmlChar(match) {
            return htmlEscapes[match];
        }
        function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result;
        }
        function isNative(value) {
            return typeof value == "function" && reNative.test(value);
        }
        var setBindData = !defineProperty ? noop : function(func, value) {
            descriptor.value = value;
            defineProperty(func, "__bindData__", descriptor);
        };
        function shimIsPlainObject(value) {
            var ctor, result;
            if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
            isFunction(ctor) && !(ctor instanceof ctor)) || !support.argsClass && isArguments(value) || !support.nodeClass && isNode(value)) {
                return false;
            }
            if (support.ownLast) {
                forIn(value, function(value, key, object) {
                    result = hasOwnProperty.call(object, key);
                    return false;
                });
                return result !== false;
            }
            forIn(value, function(value, key) {
                result = key;
            });
            return typeof result == "undefined" || hasOwnProperty.call(value, result);
        }
        function unescapeHtmlChar(match) {
            return htmlUnescapes[match];
        }
        function isArguments(value) {
            return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
        }
        if (!support.argsClass) {
            isArguments = function(value) {
                return value && typeof value == "object" && typeof value.length == "number" && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee") || false;
            };
        }
        var isArray = nativeIsArray || function(value) {
            return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
        };
        var shimKeys = createIterator({
            args: "object",
            init: "[]",
            top: "if (!(objectTypes[typeof object])) return result",
            loop: "result.push(index)"
        });
        var keys = !nativeKeys ? shimKeys : function(object) {
            if (!isObject(object)) {
                return [];
            }
            if (support.enumPrototypes && typeof object == "function" || support.nonEnumArgs && object.length && isArguments(object)) {
                return shimKeys(object);
            }
            return nativeKeys(object);
        };
        var eachIteratorOptions = {
            args: "collection, callback, thisArg",
            top: "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
            array: "typeof length == 'number'",
            keys: keys,
            loop: "if (callback(iterable[index], index, collection) === false) return result"
        };
        var defaultsIteratorOptions = {
            args: "object, source, guard",
            top: "var args = arguments,\n" + "    argsIndex = 0,\n" + "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" + "while (++argsIndex < argsLength) {\n" + "  iterable = args[argsIndex];\n" + "  if (iterable && objectTypes[typeof iterable]) {",
            keys: keys,
            loop: "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
            bottom: "  }\n}"
        };
        var forOwnIteratorOptions = {
            top: "if (!objectTypes[typeof iterable]) return result;\n" + eachIteratorOptions.top,
            array: false
        };
        var htmlEscapes = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        };
        var htmlUnescapes = invert(htmlEscapes);
        var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
        var baseEach = createIterator(eachIteratorOptions);
        var assign = createIterator(defaultsIteratorOptions, {
            top: defaultsIteratorOptions.top.replace(";", ";\n" + "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" + "  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n" + "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" + "  callback = args[--argsLength];\n" + "}"),
            loop: "result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]"
        });
        function clone(value, isDeep, callback, thisArg) {
            if (typeof isDeep != "boolean" && isDeep != null) {
                thisArg = callback;
                callback = isDeep;
                isDeep = false;
            }
            return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
        }
        function cloneDeep(value, callback, thisArg) {
            return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
        }
        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? assign(result, properties) : result;
        }
        var defaults = createIterator(defaultsIteratorOptions);
        function findKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function(value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        function findLastKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwnRight(object, function(value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
            useHas: false
        });
        function forInRight(object, callback, thisArg) {
            var pairs = [];
            forIn(object, function(value, key) {
                pairs.push(key, value);
            });
            var length = pairs.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(pairs[length--], pairs[length], object) === false) {
                    break;
                }
            }
            return object;
        }
        var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
        function forOwnRight(object, callback, thisArg) {
            var props = keys(object), length = props.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                var key = props[length];
                if (callback(object[key], key, object) === false) {
                    break;
                }
            }
            return object;
        }
        function functions(object) {
            var result = [];
            forIn(object, function(value, key) {
                if (isFunction(value)) {
                    result.push(key);
                }
            });
            return result.sort();
        }
        function has(object, key) {
            return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object) {
            var index = -1, props = keys(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index];
                result[object[key]] = key;
            }
            return result;
        }
        function isBoolean(value) {
            return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
        }
        function isDate(value) {
            return value && typeof value == "object" && toString.call(value) == dateClass || false;
        }
        function isElement(value) {
            return value && value.nodeType === 1 || false;
        }
        function isEmpty(value) {
            var result = true;
            if (!value) {
                return result;
            }
            var className = toString.call(value), length = value.length;
            if (className == arrayClass || className == stringClass || (support.argsClass ? className == argsClass : isArguments(value)) || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                return !length;
            }
            forOwn(value, function() {
                return result = false;
            });
            return result;
        }
        function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
        }
        function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
            return typeof value == "function";
        }
        if (isFunction(/x/)) {
            isFunction = function(value) {
                return typeof value == "function" && toString.call(value) == funcClass;
            };
        }
        function isObject(value) {
            return !!(value && objectTypes[typeof value]);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNull(value) {
            return value === null;
        }
        function isNumber(value) {
            return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
            if (!(value && toString.call(value) == objectClass) || !support.argsClass && isArguments(value)) {
                return false;
            }
            var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
            return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
        }
        function isString(value) {
            return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
        }
        function isUndefined(value) {
            return typeof value == "undefined";
        }
        function mapValues(object, callback, thisArg) {
            var result = {};
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function(value, key, object) {
                result[key] = callback(value, key, object);
            });
            return result;
        }
        function merge(object) {
            var args = arguments, length = 2;
            if (!isObject(object)) {
                return object;
            }
            if (typeof args[2] != "number") {
                length = args.length;
            }
            if (length > 3 && typeof args[length - 2] == "function") {
                var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
            } else if (length > 2 && typeof args[length - 1] == "function") {
                callback = args[--length];
            }
            var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
            while (++index < length) {
                baseMerge(object, sources[index], callback, stackA, stackB);
            }
            releaseArray(stackA);
            releaseArray(stackB);
            return object;
        }
        function omit(object, callback, thisArg) {
            var result = {};
            if (typeof callback != "function") {
                var props = [];
                forIn(object, function(value, key) {
                    props.push(key);
                });
                props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                var index = -1, length = props.length;
                while (++index < length) {
                    var key = props[index];
                    result[key] = object[key];
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function(value, key, object) {
                    if (!callback(value, key, object)) {
                        result[key] = value;
                    }
                });
            }
            return result;
        }
        function pairs(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                var key = props[index];
                result[index] = [ key, object[key] ];
            }
            return result;
        }
        function pick(object, callback, thisArg) {
            var result = {};
            if (typeof callback != "function") {
                var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                while (++index < length) {
                    var key = props[index];
                    if (key in object) {
                        result[key] = object[key];
                    }
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function(value, key, object) {
                    if (callback(value, key, object)) {
                        result[key] = value;
                    }
                });
            }
            return result;
        }
        function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            if (accumulator == null) {
                if (isArr) {
                    accumulator = [];
                } else {
                    var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                    accumulator = baseCreate(proto);
                }
            }
            if (callback) {
                callback = lodash.createCallback(callback, thisArg, 4);
                (isArr ? baseEach : forOwn)(object, function(value, index, object) {
                    return callback(accumulator, value, index, object);
                });
            }
            return accumulator;
        }
        function values(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                result[index] = object[props[index]];
            }
            return result;
        }
        function at(collection) {
            var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
            if (support.unindexedChars && isString(collection)) {
                collection = collection.split("");
            }
            while (++index < length) {
                result[index] = collection[props[index]];
            }
            return result;
        }
        function contains(collection, target, fromIndex) {
            var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
            if (isArray(collection)) {
                result = indexOf(collection, target, fromIndex) > -1;
            } else if (typeof length == "number") {
                result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
            } else {
                baseEach(collection, function(value) {
                    if (++index >= fromIndex) {
                        return !(result = value === target);
                    }
                });
            }
            return result;
        }
        var countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
        });
        function every(collection, callback, thisArg) {
            var result = true;
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    if (!(result = !!callback(collection[index], index, collection))) {
                        break;
                    }
                }
            } else {
                baseEach(collection, function(value, index, collection) {
                    return result = !!callback(value, index, collection);
                });
            }
            return result;
        }
        function filter(collection, callback, thisArg) {
            var result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        result.push(value);
                    }
                }
            } else {
                baseEach(collection, function(value, index, collection) {
                    if (callback(value, index, collection)) {
                        result.push(value);
                    }
                });
            }
            return result;
        }
        function find(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        return value;
                    }
                }
            } else {
                var result;
                baseEach(collection, function(value, index, collection) {
                    if (callback(value, index, collection)) {
                        result = value;
                        return false;
                    }
                });
                return result;
            }
        }
        function findLast(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forEachRight(collection, function(value, index, collection) {
                if (callback(value, index, collection)) {
                    result = value;
                    return false;
                }
            });
            return result;
        }
        function forEach(collection, callback, thisArg) {
            if (callback && typeof thisArg == "undefined" && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    if (callback(collection[index], index, collection) === false) {
                        break;
                    }
                }
            } else {
                baseEach(collection, callback, thisArg);
            }
            return collection;
        }
        function forEachRight(collection, callback, thisArg) {
            var iterable = collection, length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                while (length--) {
                    if (callback(collection[length], length, collection) === false) {
                        break;
                    }
                }
            } else {
                if (typeof length != "number") {
                    var props = keys(collection);
                    length = props.length;
                } else if (support.unindexedChars && isString(collection)) {
                    iterable = collection.split("");
                }
                baseEach(collection, function(value, key, collection) {
                    key = props ? props[--length] : --length;
                    return callback(iterable[key], key, collection);
                });
            }
            return collection;
        }
        var groupBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
        });
        var indexBy = createAggregator(function(result, value, key) {
            result[key] = value;
        });
        function invoke(collection, methodName) {
            var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            forEach(collection, function(value) {
                result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
            });
            return result;
        }
        function map(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                while (++index < length) {
                    result[index] = callback(collection[index], index, collection);
                }
            } else {
                baseEach(collection, function(value, key, collection) {
                    result[++index] = callback(value, key, collection);
                });
            }
            return result;
        }
        function max(collection, callback, thisArg) {
            var computed = -Infinity, result = computed;
            if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                callback = null;
            }
            if (callback == null && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value > result) {
                        result = value;
                    }
                }
            } else {
                callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                baseEach(collection, function(value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current > computed) {
                        computed = current;
                        result = value;
                    }
                });
            }
            return result;
        }
        function min(collection, callback, thisArg) {
            var computed = Infinity, result = computed;
            if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                callback = null;
            }
            if (callback == null && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value < result) {
                        result = value;
                    }
                }
            } else {
                callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                baseEach(collection, function(value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current < computed) {
                        computed = current;
                        result = value;
                    }
                });
            }
            return result;
        }
        var pluck = map;
        function reduce(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                if (noaccum) {
                    accumulator = collection[++index];
                }
                while (++index < length) {
                    accumulator = callback(accumulator, collection[index], index, collection);
                }
            } else {
                baseEach(collection, function(value, index, collection) {
                    accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                });
            }
            return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            forEachRight(collection, function(value, index, collection) {
                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
            });
            return accumulator;
        }
        function reject(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            return filter(collection, function(value, index, collection) {
                return !callback(value, index, collection);
            });
        }
        function sample(collection, n, guard) {
            if (collection && typeof collection.length != "number") {
                collection = values(collection);
            } else if (support.unindexedChars && isString(collection)) {
                collection = collection.split("");
            }
            if (n == null || guard) {
                return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(nativeMax(0, n), result.length);
            return result;
        }
        function shuffle(collection) {
            var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            forEach(collection, function(value) {
                var rand = baseRandom(0, ++index);
                result[index] = result[rand];
                result[rand] = value;
            });
            return result;
        }
        function size(collection) {
            var length = collection ? collection.length : 0;
            return typeof length == "number" ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    if (result = callback(collection[index], index, collection)) {
                        break;
                    }
                }
            } else {
                baseEach(collection, function(value, index, collection) {
                    return !(result = callback(value, index, collection));
                });
            }
            return !!result;
        }
        function sortBy(collection, callback, thisArg) {
            var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            if (!isArr) {
                callback = lodash.createCallback(callback, thisArg, 3);
            }
            forEach(collection, function(value, key, collection) {
                var object = result[++index] = getObject();
                if (isArr) {
                    object.criteria = map(callback, function(key) {
                        return value[key];
                    });
                } else {
                    (object.criteria = getArray())[0] = callback(value, key, collection);
                }
                object.index = index;
                object.value = value;
            });
            length = result.length;
            result.sort(compareAscending);
            while (length--) {
                var object = result[length];
                result[length] = object.value;
                if (!isArr) {
                    releaseArray(object.criteria);
                }
                releaseObject(object);
            }
            return result;
        }
        function toArray(collection) {
            if (collection && typeof collection.length == "number") {
                return support.unindexedChars && isString(collection) ? collection.split("") : slice(collection);
            }
            return values(collection);
        }
        var where = filter;
        function compact(array) {
            var index = -1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result.push(value);
                }
            }
            return result;
        }
        function difference(array) {
            return baseDifference(array, baseFlatten(arguments, true, true, 1));
        }
        function findIndex(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                if (callback(array[index], index, array)) {
                    return index;
                }
            }
            return -1;
        }
        function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(array[length], length, array)) {
                    return length;
                }
            }
            return -1;
        }
        function first(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = -1;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[0] : undefined;
                }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
        function flatten(array, isShallow, callback, thisArg) {
            if (typeof isShallow != "boolean" && isShallow != null) {
                thisArg = callback;
                callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
                isShallow = false;
            }
            if (callback != null) {
                array = map(array, callback, thisArg);
            }
            return baseFlatten(array, isShallow);
        }
        function indexOf(array, value, fromIndex) {
            if (typeof fromIndex == "number") {
                var length = array ? array.length : 0;
                fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
            } else if (fromIndex) {
                var index = sortedIndex(array, value);
                return array[index] === value ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
        }
        function initial(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback == null || thisArg ? 1 : callback || n;
            }
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection() {
            var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
            while (++argsIndex < argsLength) {
                var value = arguments[argsIndex];
                if (isArray(value) || isArguments(value)) {
                    args.push(value);
                    caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                }
            }
            var array = args[0], index = -1, length = array ? array.length : 0, result = [];
            outer: while (++index < length) {
                var cache = caches[0];
                value = array[index];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                    argsIndex = argsLength;
                    (cache || seen).push(value);
                    while (--argsIndex) {
                        cache = caches[argsIndex];
                        if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                            continue outer;
                        }
                    }
                    result.push(value);
                }
            }
            while (argsLength--) {
                cache = caches[argsLength];
                if (cache) {
                    releaseObject(cache);
                }
            }
            releaseArray(caches);
            releaseArray(seen);
            return result;
        }
        function last(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[length - 1] : undefined;
                }
            }
            return slice(array, nativeMax(0, length - n));
        }
        function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            if (typeof fromIndex == "number") {
                index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
            }
            while (index--) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function pull(array) {
            var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
            while (++argsIndex < argsLength) {
                var index = -1, value = args[argsIndex];
                while (++index < length) {
                    if (array[index] === value) {
                        splice.call(array, index--, 1);
                        length--;
                    }
                }
            }
            return array;
        }
        function range(start, end, step) {
            start = +start || 0;
            step = typeof step == "number" ? step : +step || 1;
            if (end == null) {
                end = start;
                start = 0;
            }
            var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
            while (++index < length) {
                result[index] = start;
                start += step;
            }
            return result;
        }
        function remove(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0, result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                var value = array[index];
                if (callback(value, index, array)) {
                    result.push(value);
                    splice.call(array, index--, 1);
                    length--;
                }
            }
            return result;
        }
        function rest(array, callback, thisArg) {
            if (typeof callback != "number" && callback != null) {
                var n = 0, index = -1, length = array ? array.length : 0;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback == null || thisArg ? 1 : nativeMax(0, callback);
            }
            return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
            var low = 0, high = array ? array.length : low;
            callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
            value = callback(value);
            while (low < high) {
                var mid = low + high >>> 1;
                callback(array[mid]) < value ? low = mid + 1 : high = mid;
            }
            return low;
        }
        function union() {
            return baseUniq(baseFlatten(arguments, true, true));
        }
        function uniq(array, isSorted, callback, thisArg) {
            if (typeof isSorted != "boolean" && isSorted != null) {
                thisArg = callback;
                callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
                isSorted = false;
            }
            if (callback != null) {
                callback = lodash.createCallback(callback, thisArg, 3);
            }
            return baseUniq(array, isSorted, callback);
        }
        function without(array) {
            return baseDifference(array, slice(arguments, 1));
        }
        function xor() {
            var index = -1, length = arguments.length;
            while (++index < length) {
                var array = arguments[index];
                if (isArray(array) || isArguments(array)) {
                    var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                }
            }
            return result || [];
        }
        function zip() {
            var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
            while (++index < length) {
                result[index] = pluck(array, index);
            }
            return result;
        }
        function zipObject(keys, values) {
            var index = -1, length = keys ? keys.length : 0, result = {};
            if (!values && length && !isArray(keys[0])) {
                values = [];
            }
            while (++index < length) {
                var key = keys[index];
                if (values) {
                    result[key] = values[index];
                } else if (key) {
                    result[key[0]] = key[1];
                }
            }
            return result;
        }
        function after(n, func) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            return function() {
                if (--n < 1) {
                    return func.apply(this, arguments);
                }
            };
        }
        function bind(func, thisArg) {
            return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
        }
        function bindAll(object) {
            var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
            while (++index < length) {
                var key = funcs[index];
                object[key] = createWrapper(object[key], 1, null, null, object);
            }
            return object;
        }
        function bindKey(object, key) {
            return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
        }
        function compose() {
            var funcs = arguments, length = funcs.length;
            while (length--) {
                if (!isFunction(funcs[length])) {
                    throw new TypeError();
                }
            }
            return function() {
                var args = arguments, length = funcs.length;
                while (length--) {
                    args = [ funcs[length].apply(this, args) ];
                }
                return args[0];
            };
        }
        function curry(func, arity) {
            arity = typeof arity == "number" ? arity : +arity || func.length;
            return createWrapper(func, 4, null, null, null, arity);
        }
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            wait = nativeMax(0, wait) || 0;
            if (options === true) {
                var leading = true;
                trailing = false;
            } else if (isObject(options)) {
                leading = options.leading;
                maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                trailing = "trailing" in options ? options.trailing : trailing;
            }
            var delayed = function() {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0) {
                    if (maxTimeoutId) {
                        clearTimeout(maxTimeoutId);
                    }
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined;
                    if (isCalled) {
                        lastCalled = now();
                        result = func.apply(thisArg, args);
                        if (!timeoutId && !maxTimeoutId) {
                            args = thisArg = null;
                        }
                    }
                } else {
                    timeoutId = setTimeout(delayed, remaining);
                }
            };
            var maxDelayed = function() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (trailing || maxWait !== wait) {
                    lastCalled = now();
                    result = func.apply(thisArg, args);
                    if (!timeoutId && !maxTimeoutId) {
                        args = thisArg = null;
                    }
                }
            };
            return function() {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);
                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId;
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp;
                    }
                    var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                    if (isCalled) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId);
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args);
                    } else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                    }
                }
                if (isCalled && timeoutId) {
                    timeoutId = clearTimeout(timeoutId);
                } else if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait);
                }
                if (leadingCall) {
                    isCalled = true;
                    result = func.apply(thisArg, args);
                }
                if (isCalled && !timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                }
                return result;
            };
        }
        function defer(func) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var args = slice(arguments, 1);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, 1);
        }
        function delay(func, wait) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var args = slice(arguments, 2);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, wait);
        }
        function memoize(func, resolver) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var memoized = function() {
                var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
            };
            memoized.cache = {};
            return memoized;
        }
        function once(func) {
            var ran, result;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            return function() {
                if (ran) {
                    return result;
                }
                ran = true;
                result = func.apply(this, arguments);
                func = null;
                return result;
            };
        }
        function partial(func) {
            return createWrapper(func, 16, slice(arguments, 1));
        }
        function partialRight(func) {
            return createWrapper(func, 32, null, slice(arguments, 1));
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            if (options === false) {
                leading = false;
            } else if (isObject(options)) {
                leading = "leading" in options ? options.leading : leading;
                trailing = "trailing" in options ? options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = wait;
            debounceOptions.trailing = trailing;
            return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
            return createWrapper(wrapper, 16, [ value ]);
        }
        function constant(value) {
            return function() {
                return value;
            };
        }
        function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (func == null || type == "function") {
                return baseCreateCallback(func, thisArg, argCount);
            }
            if (type != "object") {
                return property(func);
            }
            var props = keys(func), key = props[0], a = func[key];
            if (props.length == 1 && a === a && !isObject(a)) {
                return function(object) {
                    var b = object[key];
                    return a === b && (a !== 0 || 1 / a == 1 / b);
                };
            }
            return function(object) {
                var length = props.length, result = false;
                while (length--) {
                    if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                        break;
                    }
                }
                return result;
            };
        }
        function escape(string) {
            return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
            return value;
        }
        function mixin(object, source, options) {
            var chain = true, methodNames = source && functions(source);
            if (!source || !options && !methodNames.length) {
                if (options == null) {
                    options = source;
                }
                ctor = lodashWrapper;
                source = object;
                object = lodash;
                methodNames = functions(source);
            }
            if (options === false) {
                chain = false;
            } else if (isObject(options) && "chain" in options) {
                chain = options.chain;
            }
            var ctor = object, isFunc = isFunction(ctor);
            forEach(methodNames, function(methodName) {
                var func = object[methodName] = source[methodName];
                if (isFunc) {
                    ctor.prototype[methodName] = function() {
                        var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                        push.apply(args, arguments);
                        var result = func.apply(object, args);
                        if (chain || chainAll) {
                            if (value === result && isObject(result)) {
                                return this;
                            }
                            result = new ctor(result);
                            result.__chain__ = chainAll;
                        }
                        return result;
                    };
                }
            });
        }
        function noConflict() {
            context._ = oldDash;
            return this;
        }
        function noop() {}
        var now = isNative(now = Date.now) && now || function() {
            return new Date().getTime();
        };
        var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
        };
        function property(key) {
            return function(object) {
                return object[key];
            };
        }
        function random(min, max, floating) {
            var noMin = min == null, noMax = max == null;
            if (floating == null) {
                if (typeof min == "boolean" && noMax) {
                    floating = min;
                    min = 1;
                } else if (!noMax && typeof max == "boolean") {
                    floating = max;
                    noMax = true;
                }
            }
            if (noMin && noMax) {
                max = 1;
            }
            min = +min || 0;
            if (noMax) {
                max = min;
                min = 0;
            } else {
                max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
                var rand = nativeRandom();
                return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
            }
            return baseRandom(min, max);
        }
        function result(object, key) {
            if (object) {
                var value = object[key];
                return isFunction(value) ? object[key]() : value;
            }
        }
        function template(text, data, options) {
            var settings = lodash.templateSettings;
            text = String(text || "");
            options = defaults({}, options, settings);
            var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
            var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                }
                if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                }
                index = offset + match.length;
                return match;
            });
            source += "';\n";
            var variable = options.variable, hasVariable = variable;
            if (!hasVariable) {
                variable = "obj";
                source = "with (" + variable + ") {\n" + source + "\n}\n";
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
            try {
                var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
            } catch (e) {
                e.source = source;
                throw e;
            }
            if (data) {
                return result(data);
            }
            result.source = source;
            return result;
        }
        function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1, result = Array(n);
            callback = baseCreateCallback(callback, thisArg, 1);
            while (++index < n) {
                result[index] = callback(index);
            }
            return result;
        }
        function unescape(string) {
            return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return String(prefix == null ? "" : prefix) + id;
        }
        function chain(value) {
            value = new lodashWrapper(value);
            value.__chain__ = true;
            return value;
        }
        function tap(value, interceptor) {
            interceptor(value);
            return value;
        }
        function wrapperChain() {
            this.__chain__ = true;
            return this;
        }
        function wrapperToString() {
            return String(this.__wrapped__);
        }
        function wrapperValueOf() {
            return this.__wrapped__;
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.chain = chain;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.createCallback = createCallback;
        lodash.curry = curry;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.pull = pull;
        lodash.range = range;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        lodash.unzip = zip;
        mixin(lodash);
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        mixin(function() {
            var source = {};
            forOwn(lodash, function(func, methodName) {
                if (!lodash.prototype[methodName]) {
                    source[methodName] = func;
                }
            });
            return source;
        }(), false);
        lodash.first = first;
        lodash.last = last;
        lodash.sample = sample;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function(func, methodName) {
            var callbackable = methodName !== "sample";
            if (!lodash.prototype[methodName]) {
                lodash.prototype[methodName] = function(n, guard) {
                    var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                    return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
                };
            }
        });
        lodash.VERSION = "2.4.1";
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        baseEach([ "join", "pop", "shift" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                return chainAll ? new lodashWrapper(result, chainAll) : result;
            };
        });
        baseEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                func.apply(this.__wrapped__, arguments);
                return this;
            };
        });
        baseEach([ "concat", "slice", "splice" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
            };
        });
        if (!support.spliceObjects) {
            baseEach([ "pop", "shift", "splice" ], function(methodName) {
                var func = arrayRef[methodName], isSplice = methodName == "splice";
                lodash.prototype[methodName] = function() {
                    var chainAll = this.__chain__, value = this.__wrapped__, result = func.apply(value, arguments);
                    if (value.length === 0) {
                        delete value[0];
                    }
                    return chainAll || isSplice ? new lodashWrapper(result, chainAll) : result;
                };
            });
        }
        return lodash;
    }
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
            return _;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _;
        } else {
            freeExports._ = _;
        }
    } else {
        root._ = _;
    }
}).call(this);

(function() {
    var module = angular.module("restangular", []);
    module.provider("Restangular", function() {
        var Configurer = {};
        Configurer.init = function(object, config) {
            object.configuration = config;
            var safeMethods = [ "get", "head", "options", "trace", "getlist" ];
            config.isSafe = function(operation) {
                return _.contains(safeMethods, operation.toLowerCase());
            };
            var absolutePattern = /^https?:\/\//i;
            config.isAbsoluteUrl = function(string) {
                return _.isUndefined(config.absoluteUrl) || _.isNull(config.absoluteUrl) ? string && absolutePattern.test(string) : config.absoluteUrl;
            };
            config.absoluteUrl = _.isUndefined(config.absoluteUrl) ? true : config.absoluteUrl;
            object.setSelfLinkAbsoluteUrl = function(value) {
                config.absoluteUrl = value;
            };
            config.baseUrl = _.isUndefined(config.baseUrl) ? "" : config.baseUrl;
            object.setBaseUrl = function(newBaseUrl) {
                config.baseUrl = /\/$/.test(newBaseUrl) ? newBaseUrl.substring(0, newBaseUrl.length - 1) : newBaseUrl;
                return this;
            };
            config.extraFields = config.extraFields || [];
            object.setExtraFields = function(newExtraFields) {
                config.extraFields = newExtraFields;
                return this;
            };
            config.defaultHttpFields = config.defaultHttpFields || {};
            object.setDefaultHttpFields = function(values) {
                config.defaultHttpFields = values;
                return this;
            };
            config.withHttpValues = function(httpLocalConfig, obj) {
                return _.defaults(obj, httpLocalConfig, config.defaultHttpFields);
            };
            config.encodeIds = _.isUndefined(config.encodeIds) ? true : config.encodeIds;
            object.setEncodeIds = function(encode) {
                config.encodeIds = encode;
            };
            config.defaultRequestParams = config.defaultRequestParams || {
                get: {},
                post: {},
                put: {},
                remove: {},
                common: {}
            };
            object.setDefaultRequestParams = function(param1, param2) {
                var methods = [], params = param2 || param1;
                if (!_.isUndefined(param2)) {
                    if (_.isArray(param1)) {
                        methods = param1;
                    } else {
                        methods.push(param1);
                    }
                } else {
                    methods.push("common");
                }
                _.each(methods, function(method) {
                    config.defaultRequestParams[method] = params;
                });
                return this;
            };
            object.requestParams = config.defaultRequestParams;
            config.defaultHeaders = config.defaultHeaders || {};
            object.setDefaultHeaders = function(headers) {
                config.defaultHeaders = headers;
                object.defaultHeaders = config.defaultHeaders;
                return this;
            };
            object.defaultHeaders = config.defaultHeaders;
            config.methodOverriders = config.methodOverriders || [];
            object.setMethodOverriders = function(values) {
                var overriders = _.extend([], values);
                if (config.isOverridenMethod("delete", overriders)) {
                    overriders.push("remove");
                }
                config.methodOverriders = overriders;
                return this;
            };
            config.jsonp = _.isUndefined(config.jsonp) ? false : config.jsonp;
            object.setJsonp = function(active) {
                config.jsonp = active;
            };
            config.isOverridenMethod = function(method, values) {
                var search = values || config.methodOverriders;
                return !_.isUndefined(_.find(search, function(one) {
                    return one.toLowerCase() === method.toLowerCase();
                }));
            };
            config.urlCreator = config.urlCreator || "path";
            object.setUrlCreator = function(name) {
                if (!_.has(config.urlCreatorFactory, name)) {
                    throw new Error("URL Path selected isn't valid");
                }
                config.urlCreator = name;
                return this;
            };
            config.restangularFields = config.restangularFields || {
                id: "id",
                route: "route",
                parentResource: "parentResource",
                restangularCollection: "restangularCollection",
                cannonicalId: "__cannonicalId",
                etag: "restangularEtag",
                selfLink: "href",
                get: "get",
                getList: "getList",
                put: "put",
                post: "post",
                remove: "remove",
                head: "head",
                trace: "trace",
                options: "options",
                patch: "patch",
                getRestangularUrl: "getRestangularUrl",
                getRequestedUrl: "getRequestedUrl",
                putElement: "putElement",
                addRestangularMethod: "addRestangularMethod",
                getParentList: "getParentList",
                clone: "clone",
                ids: "ids",
                httpConfig: "_$httpConfig",
                reqParams: "reqParams",
                one: "one",
                all: "all",
                several: "several",
                oneUrl: "oneUrl",
                allUrl: "allUrl",
                customPUT: "customPUT",
                customPOST: "customPOST",
                customDELETE: "customDELETE",
                customGET: "customGET",
                customGETLIST: "customGETLIST",
                customOperation: "customOperation",
                doPUT: "doPUT",
                doPOST: "doPOST",
                doDELETE: "doDELETE",
                doGET: "doGET",
                doGETLIST: "doGETLIST",
                fromServer: "fromServer",
                withConfig: "withConfig",
                withHttpConfig: "withHttpConfig",
                singleOne: "singleOne",
                plain: "plain",
                save: "save"
            };
            object.setRestangularFields = function(resFields) {
                config.restangularFields = _.extend(config.restangularFields, resFields);
                return this;
            };
            config.isRestangularized = function(obj) {
                return !!obj[config.restangularFields.one] || !!obj[config.restangularFields.all];
            };
            config.setFieldToElem = function(field, elem, value) {
                var properties = field.split(".");
                var idValue = elem;
                _.each(_.initial(properties), function(prop) {
                    idValue[prop] = {};
                    idValue = idValue[prop];
                });
                idValue[_.last(properties)] = value;
                return this;
            };
            config.getFieldFromElem = function(field, elem) {
                var properties = field.split(".");
                var idValue = elem;
                _.each(properties, function(prop) {
                    if (idValue) {
                        idValue = idValue[prop];
                    }
                });
                return angular.copy(idValue);
            };
            config.setIdToElem = function(elem, id) {
                config.setFieldToElem(config.restangularFields.id, elem, id);
                return this;
            };
            config.getIdFromElem = function(elem) {
                return config.getFieldFromElem(config.restangularFields.id, elem);
            };
            config.isValidId = function(elemId) {
                return "" !== elemId && !_.isUndefined(elemId) && !_.isNull(elemId);
            };
            config.setUrlToElem = function(elem, url, route) {
                config.setFieldToElem(config.restangularFields.selfLink, elem, url);
                return this;
            };
            config.getUrlFromElem = function(elem) {
                return config.getFieldFromElem(config.restangularFields.selfLink, elem);
            };
            config.useCannonicalId = _.isUndefined(config.useCannonicalId) ? false : config.useCannonicalId;
            object.setUseCannonicalId = function(value) {
                config.useCannonicalId = value;
                return this;
            };
            config.getCannonicalIdFromElem = function(elem) {
                var cannonicalId = elem[config.restangularFields.cannonicalId];
                var actualId = config.isValidId(cannonicalId) ? cannonicalId : config.getIdFromElem(elem);
                return actualId;
            };
            config.responseInterceptors = config.responseInterceptors || [];
            config.defaultResponseInterceptor = function(data, operation, what, url, response, deferred) {
                return data;
            };
            config.responseExtractor = function(data, operation, what, url, response, deferred) {
                var interceptors = angular.copy(config.responseInterceptors);
                interceptors.push(config.defaultResponseInterceptor);
                var theData = data;
                _.each(interceptors, function(interceptor) {
                    theData = interceptor(theData, operation, what, url, response, deferred);
                });
                return theData;
            };
            object.addResponseInterceptor = function(extractor) {
                config.responseInterceptors.push(extractor);
                return this;
            };
            object.setResponseInterceptor = object.addResponseInterceptor;
            object.setResponseExtractor = object.addResponseInterceptor;
            config.requestInterceptors = config.requestInterceptors || [];
            config.defaultInterceptor = function(element, operation, path, url, headers, params, httpConfig) {
                return {
                    element: element,
                    headers: headers,
                    params: params,
                    httpConfig: httpConfig
                };
            };
            config.fullRequestInterceptor = function(element, operation, path, url, headers, params, httpConfig) {
                var interceptors = angular.copy(config.requestInterceptors);
                var defaultRequest = config.defaultInterceptor(element, operation, path, url, headers, params, httpConfig);
                return _.reduce(interceptors, function(request, interceptor) {
                    return _.extend(request, interceptor(request.element, operation, path, url, request.headers, request.params, request.httpConfig));
                }, defaultRequest);
            };
            object.addRequestInterceptor = function(interceptor) {
                config.requestInterceptors.push(function(elem, operation, path, url, headers, params, httpConfig) {
                    return {
                        headers: headers,
                        params: params,
                        element: interceptor(elem, operation, path, url),
                        httpConfig: httpConfig
                    };
                });
                return this;
            };
            object.setRequestInterceptor = object.addRequestInterceptor;
            object.addFullRequestInterceptor = function(interceptor) {
                config.requestInterceptors.push(interceptor);
                return this;
            };
            object.setFullRequestInterceptor = object.addFullRequestInterceptor;
            config.errorInterceptor = config.errorInterceptor || function() {};
            object.setErrorInterceptor = function(interceptor) {
                config.errorInterceptor = interceptor;
                return this;
            };
            config.onBeforeElemRestangularized = config.onBeforeElemRestangularized || function(elem) {
                return elem;
            };
            object.setOnBeforeElemRestangularized = function(post) {
                config.onBeforeElemRestangularized = post;
                return this;
            };
            config.onElemRestangularized = config.onElemRestangularized || function(elem) {
                return elem;
            };
            object.setOnElemRestangularized = function(post) {
                config.onElemRestangularized = post;
                return this;
            };
            config.shouldSaveParent = config.shouldSaveParent || function() {
                return true;
            };
            object.setParentless = function(values) {
                if (_.isArray(values)) {
                    config.shouldSaveParent = function(route) {
                        return !_.contains(values, route);
                    };
                } else if (_.isBoolean(values)) {
                    config.shouldSaveParent = function() {
                        return !values;
                    };
                }
                return this;
            };
            config.suffix = _.isUndefined(config.suffix) ? null : config.suffix;
            object.setRequestSuffix = function(newSuffix) {
                config.suffix = newSuffix;
                return this;
            };
            config.transformers = config.transformers || {};
            object.addElementTransformer = function(type, secondArg, thirdArg) {
                var isCollection = null;
                var transformer = null;
                if (arguments.length === 2) {
                    transformer = secondArg;
                } else {
                    transformer = thirdArg;
                    isCollection = secondArg;
                }
                var typeTransformers = config.transformers[type];
                if (!typeTransformers) {
                    typeTransformers = config.transformers[type] = [];
                }
                typeTransformers.push(function(coll, elem) {
                    if (_.isNull(isCollection) || coll == isCollection) {
                        return transformer(elem);
                    }
                    return elem;
                });
                return object;
            };
            object.extendCollection = function(route, fn) {
                return object.addElementTransformer(route, true, fn);
            };
            object.extendModel = function(route, fn) {
                return object.addElementTransformer(route, false, fn);
            };
            config.transformElem = function(elem, isCollection, route, Restangular, force) {
                if (!force && !config.transformLocalElements && !elem[config.restangularFields.fromServer]) {
                    return elem;
                }
                var typeTransformers = config.transformers[route];
                var changedElem = elem;
                if (typeTransformers) {
                    _.each(typeTransformers, function(transformer) {
                        changedElem = transformer(isCollection, changedElem);
                    });
                }
                return config.onElemRestangularized(changedElem, isCollection, route, Restangular);
            };
            config.transformLocalElements = _.isUndefined(config.transformLocalElements) ? false : config.transformLocalElements;
            object.setTransformOnlyServerElements = function(active) {
                config.transformLocalElements = !active;
            };
            config.fullResponse = _.isUndefined(config.fullResponse) ? false : config.fullResponse;
            object.setFullResponse = function(full) {
                config.fullResponse = full;
                return this;
            };
            config.urlCreatorFactory = {};
            var BaseCreator = function() {};
            BaseCreator.prototype.setConfig = function(config) {
                this.config = config;
                return this;
            };
            BaseCreator.prototype.parentsArray = function(current) {
                var parents = [];
                while (current) {
                    parents.push(current);
                    current = current[this.config.restangularFields.parentResource];
                }
                return parents.reverse();
            };
            function RestangularResource(config, $http, url, configurer) {
                var resource = {};
                _.each(_.keys(configurer), function(key) {
                    var value = configurer[key];
                    value.params = _.extend({}, value.params, config.defaultRequestParams[value.method.toLowerCase()]);
                    if (_.isEmpty(value.params)) {
                        delete value.params;
                    }
                    if (config.isSafe(value.method)) {
                        resource[key] = function() {
                            return $http(_.extend(value, {
                                url: url
                            }));
                        };
                    } else {
                        resource[key] = function(data) {
                            return $http(_.extend(value, {
                                url: url,
                                data: data
                            }));
                        };
                    }
                });
                return resource;
            }
            BaseCreator.prototype.resource = function(current, $http, localHttpConfig, callHeaders, callParams, what, etag, operation) {
                var params = _.defaults(callParams || {}, this.config.defaultRequestParams.common);
                var headers = _.defaults(callHeaders || {}, this.config.defaultHeaders);
                if (etag) {
                    if (!config.isSafe(operation)) {
                        headers["If-Match"] = etag;
                    } else {
                        headers["If-None-Match"] = etag;
                    }
                }
                var url = this.base(current);
                if (what) {
                    var add = "";
                    if (!/\/$/.test(url)) {
                        add += "/";
                    }
                    add += what;
                    url += add;
                }
                if (this.config.suffix && url.indexOf(this.config.suffix, url.length - this.config.suffix.length) === -1 && !this.config.getUrlFromElem(current)) {
                    url += this.config.suffix;
                }
                current[this.config.restangularFields.httpConfig] = undefined;
                return RestangularResource(this.config, $http, url, {
                    getList: this.config.withHttpValues(localHttpConfig, {
                        method: "GET",
                        params: params,
                        headers: headers
                    }),
                    get: this.config.withHttpValues(localHttpConfig, {
                        method: "GET",
                        params: params,
                        headers: headers
                    }),
                    jsonp: this.config.withHttpValues(localHttpConfig, {
                        method: "jsonp",
                        params: params,
                        headers: headers
                    }),
                    put: this.config.withHttpValues(localHttpConfig, {
                        method: "PUT",
                        params: params,
                        headers: headers
                    }),
                    post: this.config.withHttpValues(localHttpConfig, {
                        method: "POST",
                        params: params,
                        headers: headers
                    }),
                    remove: this.config.withHttpValues(localHttpConfig, {
                        method: "DELETE",
                        params: params,
                        headers: headers
                    }),
                    head: this.config.withHttpValues(localHttpConfig, {
                        method: "HEAD",
                        params: params,
                        headers: headers
                    }),
                    trace: this.config.withHttpValues(localHttpConfig, {
                        method: "TRACE",
                        params: params,
                        headers: headers
                    }),
                    options: this.config.withHttpValues(localHttpConfig, {
                        method: "OPTIONS",
                        params: params,
                        headers: headers
                    }),
                    patch: this.config.withHttpValues(localHttpConfig, {
                        method: "PATCH",
                        params: params,
                        headers: headers
                    })
                });
            };
            var Path = function() {};
            Path.prototype = new BaseCreator();
            Path.prototype.base = function(current) {
                var __this = this;
                return _.reduce(this.parentsArray(current), function(acum, elem) {
                    var elemUrl;
                    var elemSelfLink = __this.config.getUrlFromElem(elem);
                    if (elemSelfLink) {
                        if (__this.config.isAbsoluteUrl(elemSelfLink)) {
                            return elemSelfLink;
                        } else {
                            elemUrl = elemSelfLink;
                        }
                    } else {
                        elemUrl = elem[__this.config.restangularFields.route];
                        if (elem[__this.config.restangularFields.restangularCollection]) {
                            var ids = elem[__this.config.restangularFields.ids];
                            if (ids) {
                                elemUrl += "/" + ids.join(",");
                            }
                        } else {
                            var elemId;
                            if (__this.config.useCannonicalId) {
                                elemId = __this.config.getCannonicalIdFromElem(elem);
                            } else {
                                elemId = __this.config.getIdFromElem(elem);
                            }
                            if (config.isValidId(elemId) && !elem.singleOne) {
                                elemUrl += "/" + (__this.config.encodeIds ? encodeURIComponent(elemId) : elemId);
                            }
                        }
                    }
                    return acum.replace(/\/$/, "") + "/" + elemUrl;
                }, this.config.baseUrl);
            };
            Path.prototype.fetchUrl = function(current, what) {
                var baseUrl = this.base(current);
                if (what) {
                    baseUrl += "/" + what;
                }
                return baseUrl;
            };
            Path.prototype.fetchRequestedUrl = function(current, what) {
                var url = this.fetchUrl(current, what);
                var params = current[config.restangularFields.reqParams];
                function sortedKeys(obj) {
                    var keys = [];
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            keys.push(key);
                        }
                    }
                    return keys.sort();
                }
                function forEachSorted(obj, iterator, context) {
                    var keys = sortedKeys(obj);
                    for (var i = 0; i < keys.length; i++) {
                        iterator.call(context, obj[keys[i]], keys[i]);
                    }
                    return keys;
                }
                function encodeUriQuery(val, pctEncodeSpaces) {
                    return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
                }
                if (!params) return url;
                var parts = [];
                forEachSorted(params, function(value, key) {
                    if (value == null || value == undefined) return;
                    if (!angular.isArray(value)) value = [ value ];
                    angular.forEach(value, function(v) {
                        if (angular.isObject(v)) {
                            v = angular.toJson(v);
                        }
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    });
                });
                return url + (this.config.suffix || "") + (url.indexOf("?") === -1 ? "?" : "&") + parts.join("&");
            };
            config.urlCreatorFactory.path = Path;
        };
        var globalConfiguration = {};
        Configurer.init(this, globalConfiguration);
        this.$get = [ "$http", "$q", function($http, $q) {
            function createServiceForConfiguration(config) {
                var service = {};
                var urlHandler = new config.urlCreatorFactory[config.urlCreator]();
                urlHandler.setConfig(config);
                function restangularizeBase(parent, elem, route, reqParams, fromServer) {
                    elem[config.restangularFields.route] = route;
                    elem[config.restangularFields.getRestangularUrl] = _.bind(urlHandler.fetchUrl, urlHandler, elem);
                    elem[config.restangularFields.getRequestedUrl] = _.bind(urlHandler.fetchRequestedUrl, urlHandler, elem);
                    elem[config.restangularFields.addRestangularMethod] = _.bind(addRestangularMethodFunction, elem);
                    elem[config.restangularFields.clone] = _.bind(copyRestangularizedElement, elem, elem);
                    elem[config.restangularFields.reqParams] = _.isEmpty(reqParams) ? null : reqParams;
                    elem[config.restangularFields.withHttpConfig] = _.bind(withHttpConfig, elem);
                    elem[config.restangularFields.plain] = _.bind(stripRestangular, elem, elem);
                    elem[config.restangularFields.one] = _.bind(one, elem, elem);
                    elem[config.restangularFields.all] = _.bind(all, elem, elem);
                    elem[config.restangularFields.several] = _.bind(several, elem, elem);
                    elem[config.restangularFields.oneUrl] = _.bind(oneUrl, elem, elem);
                    elem[config.restangularFields.allUrl] = _.bind(allUrl, elem, elem);
                    elem[config.restangularFields.fromServer] = !!fromServer;
                    if (parent && config.shouldSaveParent(route)) {
                        var parentId = config.getIdFromElem(parent);
                        var parentUrl = config.getUrlFromElem(parent);
                        var restangularFieldsForParent = _.union(_.values(_.pick(config.restangularFields, [ "route", "singleOne", "parentResource" ])), config.extraFields);
                        var parentResource = _.pick(parent, restangularFieldsForParent);
                        if (config.isValidId(parentId)) {
                            config.setIdToElem(parentResource, parentId);
                        }
                        if (config.isValidId(parentUrl)) {
                            config.setUrlToElem(parentResource, parentUrl);
                        }
                        elem[config.restangularFields.parentResource] = parentResource;
                    } else {
                        elem[config.restangularFields.parentResource] = null;
                    }
                    return elem;
                }
                function one(parent, route, id, singleOne) {
                    if (_.isNumber(route) || _.isNumber(parent)) {
                        var error = "You're creating a Restangular entity with the number ";
                        error += "instead of the route or the parent. You can't call .one(12)";
                        throw new Error(error);
                    }
                    var elem = {};
                    config.setIdToElem(elem, id);
                    config.setFieldToElem(config.restangularFields.singleOne, elem, singleOne);
                    return restangularizeElem(parent, elem, route, false);
                }
                function all(parent, route) {
                    return restangularizeCollection(parent, [], route, false);
                }
                function several(parent, route, ids) {
                    var collection = [];
                    collection[config.restangularFields.ids] = Array.prototype.splice.call(arguments, 2);
                    return restangularizeCollection(parent, collection, route, false);
                }
                function oneUrl(parent, route, url) {
                    if (!route) {
                        throw new Error("Route is mandatory when creating new Restangular objects.");
                    }
                    var elem = {};
                    config.setUrlToElem(elem, url, route);
                    return restangularizeElem(parent, elem, route, false);
                }
                function allUrl(parent, route, url) {
                    if (!route) {
                        throw new Error("Route is mandatory when creating new Restangular objects.");
                    }
                    var elem = {};
                    config.setUrlToElem(elem, url, route);
                    return restangularizeCollection(parent, elem, route, false);
                }
                function restangularizePromise(promise, isCollection, valueToFill) {
                    promise.call = _.bind(promiseCall, promise);
                    promise.get = _.bind(promiseGet, promise);
                    promise[config.restangularFields.restangularCollection] = isCollection;
                    if (isCollection) {
                        promise.push = _.bind(promiseCall, promise, "push");
                    }
                    promise.$object = valueToFill;
                    return promise;
                }
                function promiseCall(method) {
                    var deferred = $q.defer();
                    var callArgs = arguments;
                    var filledValue = {};
                    this.then(function(val) {
                        var params = Array.prototype.slice.call(callArgs, 1);
                        var func = val[method];
                        func.apply(val, params);
                        filledValue = val;
                        deferred.resolve(val);
                    });
                    return restangularizePromise(deferred.promise, this[config.restangularFields.restangularCollection], filledValue);
                }
                function promiseGet(what) {
                    var deferred = $q.defer();
                    var filledValue = {};
                    this.then(function(val) {
                        filledValue = val[what];
                        deferred.resolve(filledValue);
                    });
                    return restangularizePromise(deferred.promise, this[config.restangularFields.restangularCollection], filledValue);
                }
                function resolvePromise(deferred, response, data, filledValue) {
                    _.extend(filledValue, data);
                    if (config.fullResponse) {
                        return deferred.resolve(_.extend(response, {
                            data: data
                        }));
                    } else {
                        deferred.resolve(data);
                    }
                }
                function stripRestangular(elem) {
                    if (_.isArray(elem)) {
                        var array = [];
                        _.each(elem, function(value) {
                            array.push(stripRestangular(value));
                        });
                        return array;
                    } else {
                        return _.omit(elem, _.values(_.omit(config.restangularFields, "id")));
                    }
                }
                function addCustomOperation(elem) {
                    elem[config.restangularFields.customOperation] = _.bind(customFunction, elem);
                    _.each([ "put", "post", "get", "delete" ], function(oper) {
                        _.each([ "do", "custom" ], function(alias) {
                            var callOperation = oper === "delete" ? "remove" : oper;
                            var name = alias + oper.toUpperCase();
                            var callFunction;
                            if (callOperation !== "put" && callOperation !== "post") {
                                callFunction = customFunction;
                            } else {
                                callFunction = function(operation, elem, path, params, headers) {
                                    return _.bind(customFunction, this)(operation, path, params, headers, elem);
                                };
                            }
                            elem[name] = _.bind(callFunction, elem, callOperation);
                        });
                    });
                    elem[config.restangularFields.customGETLIST] = _.bind(fetchFunction, elem);
                    elem[config.restangularFields.doGETLIST] = elem[config.restangularFields.customGETLIST];
                }
                function copyRestangularizedElement(fromElement, toElement) {
                    var copiedElement = angular.copy(fromElement, toElement);
                    return restangularizeElem(copiedElement[config.restangularFields.parentResource], copiedElement, copiedElement[config.restangularFields.route], true);
                }
                function restangularizeElem(parent, element, route, fromServer, collection, reqParams) {
                    var elem = config.onBeforeElemRestangularized(element, false, route);
                    var localElem = restangularizeBase(parent, elem, route, reqParams, fromServer);
                    if (config.useCannonicalId) {
                        localElem[config.restangularFields.cannonicalId] = config.getIdFromElem(localElem);
                    }
                    if (collection) {
                        localElem[config.restangularFields.getParentList] = function() {
                            return collection;
                        };
                    }
                    localElem[config.restangularFields.restangularCollection] = false;
                    localElem[config.restangularFields.get] = _.bind(getFunction, localElem);
                    localElem[config.restangularFields.getList] = _.bind(fetchFunction, localElem);
                    localElem[config.restangularFields.put] = _.bind(putFunction, localElem);
                    localElem[config.restangularFields.post] = _.bind(postFunction, localElem);
                    localElem[config.restangularFields.remove] = _.bind(deleteFunction, localElem);
                    localElem[config.restangularFields.head] = _.bind(headFunction, localElem);
                    localElem[config.restangularFields.trace] = _.bind(traceFunction, localElem);
                    localElem[config.restangularFields.options] = _.bind(optionsFunction, localElem);
                    localElem[config.restangularFields.patch] = _.bind(patchFunction, localElem);
                    localElem[config.restangularFields.save] = _.bind(save, localElem);
                    addCustomOperation(localElem);
                    return config.transformElem(localElem, false, route, service, true);
                }
                function restangularizeCollection(parent, element, route, fromServer, reqParams) {
                    var elem = config.onBeforeElemRestangularized(element, true, route);
                    var localElem = restangularizeBase(parent, elem, route, reqParams, fromServer);
                    localElem[config.restangularFields.restangularCollection] = true;
                    localElem[config.restangularFields.post] = _.bind(postFunction, localElem, null);
                    localElem[config.restangularFields.remove] = _.bind(deleteFunction, localElem);
                    localElem[config.restangularFields.head] = _.bind(headFunction, localElem);
                    localElem[config.restangularFields.trace] = _.bind(traceFunction, localElem);
                    localElem[config.restangularFields.putElement] = _.bind(putElementFunction, localElem);
                    localElem[config.restangularFields.options] = _.bind(optionsFunction, localElem);
                    localElem[config.restangularFields.patch] = _.bind(patchFunction, localElem);
                    localElem[config.restangularFields.get] = _.bind(getById, localElem);
                    localElem[config.restangularFields.getList] = _.bind(fetchFunction, localElem, null);
                    addCustomOperation(localElem);
                    return config.transformElem(localElem, true, route, service, true);
                }
                function restangularizeCollectionAndElements(parent, element, route) {
                    var collection = restangularizeCollection(parent, element, route, false);
                    _.each(collection, function(elem) {
                        restangularizeElem(parent, elem, route, false);
                    });
                    return collection;
                }
                function getById(id, reqParams, headers) {
                    return this.customGET(id.toString(), reqParams, headers);
                }
                function putElementFunction(idx, params, headers) {
                    var __this = this;
                    var elemToPut = this[idx];
                    var deferred = $q.defer();
                    var filledArray = [];
                    filledArray = config.transformElem(filledArray, true, elemToPut[config.restangularFields.route], service);
                    elemToPut.put(params, headers).then(function(serverElem) {
                        var newArray = copyRestangularizedElement(__this);
                        newArray[idx] = serverElem;
                        filledArray = newArray;
                        deferred.resolve(newArray);
                    }, function(response) {
                        deferred.reject(response);
                    });
                    return restangularizePromise(deferred.promise, true, filledArray);
                }
                function parseResponse(resData, operation, route, fetchUrl, response, deferred) {
                    var data = config.responseExtractor(resData, operation, route, fetchUrl, response, deferred);
                    var etag = response.headers("ETag");
                    if (data && etag) {
                        data[config.restangularFields.etag] = etag;
                    }
                    return data;
                }
                function fetchFunction(what, reqParams, headers) {
                    var __this = this;
                    var deferred = $q.defer();
                    var operation = "getList";
                    var url = urlHandler.fetchUrl(this, what);
                    var whatFetched = what || __this[config.restangularFields.route];
                    var request = config.fullRequestInterceptor(null, operation, whatFetched, url, headers || {}, reqParams || {}, this[config.restangularFields.httpConfig] || {});
                    var filledArray = [];
                    filledArray = config.transformElem(filledArray, true, whatFetched, service);
                    var method = "getList";
                    if (config.jsonp) {
                        method = "jsonp";
                    }
                    urlHandler.resource(this, $http, request.httpConfig, request.headers, request.params, what, this[config.restangularFields.etag], operation)[method]().then(function(response) {
                        var resData = response.data;
                        var fullParams = response.config.params;
                        var data = parseResponse(resData, operation, whatFetched, url, response, deferred);
                        if (_.isUndefined(data) || "" === data) {
                            data = [];
                        }
                        if (!_.isArray(data)) {
                            throw new Error("Response for getList SHOULD be an array and not an object or something else");
                        }
                        var processedData = _.map(data, function(elem) {
                            if (!__this[config.restangularFields.restangularCollection]) {
                                return restangularizeElem(__this, elem, what, true, data);
                            } else {
                                return restangularizeElem(__this[config.restangularFields.parentResource], elem, __this[config.restangularFields.route], true, data);
                            }
                        });
                        processedData = _.extend(data, processedData);
                        if (!__this[config.restangularFields.restangularCollection]) {
                            resolvePromise(deferred, response, restangularizeCollection(__this, processedData, what, true, fullParams), filledArray);
                        } else {
                            resolvePromise(deferred, response, restangularizeCollection(__this[config.restangularFields.parentResource], processedData, __this[config.restangularFields.route], true, fullParams), filledArray);
                        }
                    }, function error(response) {
                        if (response.status === 304 && __this[config.restangularFields.restangularCollection]) {
                            resolvePromise(deferred, response, __this, filledArray);
                        } else if (config.errorInterceptor(response, deferred) !== false) {
                            deferred.reject(response);
                        }
                    });
                    return restangularizePromise(deferred.promise, true, filledArray);
                }
                function withHttpConfig(httpConfig) {
                    this[config.restangularFields.httpConfig] = httpConfig;
                    return this;
                }
                function save(params, headers) {
                    if (this[config.restangularFields.fromServer]) {
                        return this[config.restangularFields.put](params, headers);
                    } else {
                        return _.bind(elemFunction, this)("post", undefined, params, undefined, headers);
                    }
                }
                function elemFunction(operation, what, params, obj, headers) {
                    var __this = this;
                    var deferred = $q.defer();
                    var resParams = params || {};
                    var route = what || this[config.restangularFields.route];
                    var fetchUrl = urlHandler.fetchUrl(this, what);
                    var callObj = obj || this;
                    var etag = callObj[config.restangularFields.etag] || (operation != "post" ? this[config.restangularFields.etag] : null);
                    if (_.isObject(callObj) && config.isRestangularized(callObj)) {
                        callObj = stripRestangular(callObj);
                    }
                    var request = config.fullRequestInterceptor(callObj, operation, route, fetchUrl, headers || {}, resParams || {}, this[config.restangularFields.httpConfig] || {});
                    var filledObject = {};
                    filledObject = config.transformElem(filledObject, false, route, service);
                    var okCallback = function(response) {
                        var resData = response.data;
                        var fullParams = response.config.params;
                        var elem = parseResponse(resData, operation, route, fetchUrl, response, deferred);
                        if (elem) {
                            if (operation === "post" && !__this[config.restangularFields.restangularCollection]) {
                                resolvePromise(deferred, response, restangularizeElem(__this, elem, what, true, null, fullParams), filledObject);
                            } else {
                                var data = restangularizeElem(__this[config.restangularFields.parentResource], elem, __this[config.restangularFields.route], true, null, fullParams);
                                data[config.restangularFields.singleOne] = __this[config.restangularFields.singleOne];
                                resolvePromise(deferred, response, data, filledObject);
                            }
                        } else {
                            resolvePromise(deferred, response, undefined, filledObject);
                        }
                    };
                    var errorCallback = function(response) {
                        if (response.status === 304 && config.isSafe(operation)) {
                            resolvePromise(deferred, response, __this, filledObject);
                        } else if (config.errorInterceptor(response, deferred) !== false) {
                            deferred.reject(response);
                        }
                    };
                    var callOperation = operation;
                    var callHeaders = _.extend({}, request.headers);
                    var isOverrideOperation = config.isOverridenMethod(operation);
                    if (isOverrideOperation) {
                        callOperation = "post";
                        callHeaders = _.extend(callHeaders, {
                            "X-HTTP-Method-Override": operation === "remove" ? "DELETE" : operation
                        });
                    } else if (config.jsonp && callOperation === "get") {
                        callOperation = "jsonp";
                    }
                    if (config.isSafe(operation)) {
                        if (isOverrideOperation) {
                            urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation]({}).then(okCallback, errorCallback);
                        } else {
                            urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation]().then(okCallback, errorCallback);
                        }
                    } else {
                        urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation](request.element).then(okCallback, errorCallback);
                    }
                    return restangularizePromise(deferred.promise, false, filledObject);
                }
                function getFunction(params, headers) {
                    return _.bind(elemFunction, this)("get", undefined, params, undefined, headers);
                }
                function deleteFunction(params, headers) {
                    return _.bind(elemFunction, this)("remove", undefined, params, undefined, headers);
                }
                function putFunction(params, headers) {
                    return _.bind(elemFunction, this)("put", undefined, params, undefined, headers);
                }
                function postFunction(what, elem, params, headers) {
                    return _.bind(elemFunction, this)("post", what, params, elem, headers);
                }
                function headFunction(params, headers) {
                    return _.bind(elemFunction, this)("head", undefined, params, undefined, headers);
                }
                function traceFunction(params, headers) {
                    return _.bind(elemFunction, this)("trace", undefined, params, undefined, headers);
                }
                function optionsFunction(params, headers) {
                    return _.bind(elemFunction, this)("options", undefined, params, undefined, headers);
                }
                function patchFunction(elem, params, headers) {
                    return _.bind(elemFunction, this)("patch", undefined, params, elem, headers);
                }
                function customFunction(operation, path, params, headers, elem) {
                    return _.bind(elemFunction, this)(operation, path, params, elem, headers);
                }
                function addRestangularMethodFunction(name, operation, path, defaultParams, defaultHeaders, defaultElem) {
                    var bindedFunction;
                    if (operation === "getList") {
                        bindedFunction = _.bind(fetchFunction, this, path);
                    } else {
                        bindedFunction = _.bind(customFunction, this, operation, path);
                    }
                    var createdFunction = function(params, headers, elem) {
                        var callParams = _.defaults({
                            params: params,
                            headers: headers,
                            elem: elem
                        }, {
                            params: defaultParams,
                            headers: defaultHeaders,
                            elem: defaultElem
                        });
                        return bindedFunction(callParams.params, callParams.headers, callParams.elem);
                    };
                    if (config.isSafe(operation)) {
                        this[name] = createdFunction;
                    } else {
                        this[name] = function(elem, params, headers) {
                            return createdFunction(params, headers, elem);
                        };
                    }
                }
                function withConfigurationFunction(configurer) {
                    var newConfig = angular.copy(_.omit(config, "configuration"));
                    Configurer.init(newConfig, newConfig);
                    configurer(newConfig);
                    return createServiceForConfiguration(newConfig);
                }
                function toService(route, parent) {
                    var serv = {};
                    var collection = (parent || service).all(route);
                    serv.one = _.bind(one, parent || service, parent, route);
                    serv.post = _.bind(collection.post, collection);
                    serv.getList = _.bind(collection.getList, collection);
                    return serv;
                }
                Configurer.init(service, config);
                service.copy = _.bind(copyRestangularizedElement, service);
                service.service = _.bind(toService, service);
                service.withConfig = _.bind(withConfigurationFunction, service);
                service.one = _.bind(one, service, null);
                service.all = _.bind(all, service, null);
                service.several = _.bind(several, service, null);
                service.oneUrl = _.bind(oneUrl, service, null);
                service.allUrl = _.bind(allUrl, service, null);
                service.stripRestangular = _.bind(stripRestangular, service);
                service.restangularizeElement = _.bind(restangularizeElem, service);
                service.restangularizeCollection = _.bind(restangularizeCollectionAndElements, service);
                return service;
            }
            return createServiceForConfiguration(globalConfiguration);
        } ];
    });
})();

angular.module("Scope.safeApply", []).run([ "$rootScope", function($rootScope) {
    $rootScope.$safeApply = function() {
        var $scope, fn, force = false;
        if (arguments.length == 1) {
            var arg = arguments[0];
            if (typeof arg == "function") {
                fn = arg;
            } else {
                $scope = arg;
            }
        } else {
            $scope = arguments[0];
            fn = arguments[1];
            if (arguments.length == 3) {
                force = !!arguments[2];
            }
        }
        $scope = $scope || this;
        fn = fn || function() {};
        if (force || !$scope.$$phase) {
            $scope.$apply ? $scope.$apply(fn) : $scope.apply(fn);
        } else {
            fn();
        }
    };
} ]);

"use strict";

if (!Number.isInteger) {
    Number.isInteger = function isInteger(nVal) {
        return typeof nVal === "number" && isFinite(nVal) && nVal > -9007199254740992 && nVal < 9007199254740992 && Math.floor(nVal) === nVal;
    };
}

function StringView(vInput, sEncoding, nOffset, nLength) {
    var fTAView, aWhole, aRaw, fPutOutptCode, fGetOutptChrSize, nInptLen, nStartIdx = isFinite(nOffset) ? nOffset : 0, nTranscrType = 15;
    if (sEncoding) {
        this.encoding = sEncoding.toString();
    }
    encSwitch: switch (this.encoding) {
      case "UTF-8":
        fPutOutptCode = StringView.putUTF8CharCode;
        fGetOutptChrSize = StringView.getUTF8CharLength;
        fTAView = Uint8Array;
        break encSwitch;

      case "UTF-16":
        fPutOutptCode = StringView.putUTF16CharCode;
        fGetOutptChrSize = StringView.getUTF16CharLength;
        fTAView = Uint16Array;
        break encSwitch;

      case "UTF-32":
        fTAView = Uint32Array;
        nTranscrType &= 14;
        break encSwitch;

      default:
        fTAView = Uint8Array;
        nTranscrType &= 14;
    }
    typeSwitch: switch (typeof vInput) {
      case "string":
        nTranscrType &= 7;
        break typeSwitch;

      case "object":
        classSwitch: switch (vInput.constructor) {
          case StringView:
            nTranscrType &= 3;
            break typeSwitch;

          case String:
            nTranscrType &= 7;
            break typeSwitch;

          case ArrayBuffer:
            aWhole = new fTAView(vInput);
            nInptLen = this.encoding === "UTF-32" ? vInput.byteLength >>> 2 : this.encoding === "UTF-16" ? vInput.byteLength >>> 1 : vInput.byteLength;
            aRaw = nStartIdx === 0 && (!isFinite(nLength) || nLength === nInptLen) ? aWhole : new fTAView(vInput, nStartIdx, !isFinite(nLength) ? nInptLen - nStartIdx : nLength);
            break typeSwitch;

          case Uint32Array:
          case Uint16Array:
          case Uint8Array:
            fTAView = vInput.constructor;
            nInptLen = vInput.length;
            aWhole = vInput.byteOffset === 0 && vInput.length === (fTAView === Uint32Array ? vInput.buffer.byteLength >>> 2 : fTAView === Uint16Array ? vInput.buffer.byteLength >>> 1 : vInput.buffer.byteLength) ? vInput : new fTAView(vInput.buffer);
            aRaw = nStartIdx === 0 && (!isFinite(nLength) || nLength === nInptLen) ? vInput : vInput.subarray(nStartIdx, isFinite(nLength) ? nStartIdx + nLength : nInptLen);
            break typeSwitch;

          default:
            aWhole = new fTAView(vInput);
            nInptLen = aWhole.length;
            aRaw = nStartIdx === 0 && (!isFinite(nLength) || nLength === nInptLen) ? aWhole : aWhole.subarray(nStartIdx, isFinite(nLength) ? nStartIdx + nLength : nInptLen);
        }
        break typeSwitch;

      default:
        aWhole = aRaw = new fTAView(Number(vInput) || 0);
    }
    if (nTranscrType < 8) {
        var vSource, nOutptLen, nCharStart, nCharEnd, nEndIdx, fGetInptChrSize, fGetInptChrCode;
        if (nTranscrType & 4) {
            vSource = vInput;
            nOutptLen = nInptLen = vSource.length;
            nTranscrType ^= this.encoding === "UTF-32" ? 0 : 2;
            nStartIdx = nCharStart = nOffset ? Math.max((nOutptLen + nOffset) % nOutptLen, 0) : 0;
            nEndIdx = nCharEnd = (Number.isInteger(nLength) ? Math.min(Math.max(nLength, 0) + nStartIdx, nOutptLen) : nOutptLen) - 1;
        } else {
            vSource = vInput.rawData;
            nInptLen = vInput.makeIndex();
            nStartIdx = nCharStart = nOffset ? Math.max((nInptLen + nOffset) % nInptLen, 0) : 0;
            nOutptLen = Number.isInteger(nLength) ? Math.min(Math.max(nLength, 0), nInptLen - nCharStart) : nInptLen;
            nEndIdx = nCharEnd = nOutptLen + nCharStart;
            if (vInput.encoding === "UTF-8") {
                fGetInptChrSize = StringView.getUTF8CharLength;
                fGetInptChrCode = StringView.loadUTF8CharCode;
            } else if (vInput.encoding === "UTF-16") {
                fGetInptChrSize = StringView.getUTF16CharLength;
                fGetInptChrCode = StringView.loadUTF16CharCode;
            } else {
                nTranscrType &= 1;
            }
        }
        if (nOutptLen === 0 || nTranscrType < 4 && vSource.encoding === this.encoding && nCharStart === 0 && nOutptLen === nInptLen) {
            nTranscrType = 7;
        }
        conversionSwitch: switch (nTranscrType) {
          case 0:
            aWhole = new fTAView(nOutptLen);
            for (var nOutptIdx = 0; nOutptIdx < nOutptLen; aWhole[nOutptIdx] = vSource[nStartIdx + nOutptIdx++]) ;
            break conversionSwitch;

          case 1:
            nOutptLen = 0;
            for (var nInptIdx = nStartIdx; nInptIdx < nEndIdx; nInptIdx++) {
                nOutptLen += fGetOutptChrSize(vSource[nInptIdx]);
            }
            aWhole = new fTAView(nOutptLen);
            for (var nInptIdx = nStartIdx, nOutptIdx = 0; nOutptIdx < nOutptLen; nInptIdx++) {
                nOutptIdx = fPutOutptCode(aWhole, vSource[nInptIdx], nOutptIdx);
            }
            break conversionSwitch;

          case 2:
            nStartIdx = 0;
            var nChrCode;
            for (nChrIdx = 0; nChrIdx < nCharStart; nChrIdx++) {
                nChrCode = fGetInptChrCode(vSource, nStartIdx);
                nStartIdx += fGetInptChrSize(nChrCode);
            }
            aWhole = new fTAView(nOutptLen);
            for (var nInptIdx = nStartIdx, nOutptIdx = 0; nOutptIdx < nOutptLen; nInptIdx += fGetInptChrSize(nChrCode), 
            nOutptIdx++) {
                nChrCode = fGetInptChrCode(vSource, nInptIdx);
                aWhole[nOutptIdx] = nChrCode;
            }
            break conversionSwitch;

          case 3:
            nOutptLen = 0;
            var nChrCode;
            for (var nChrIdx = 0, nInptIdx = 0; nChrIdx < nCharEnd; nInptIdx += fGetInptChrSize(nChrCode)) {
                nChrCode = fGetInptChrCode(vSource, nInptIdx);
                if (nChrIdx === nCharStart) {
                    nStartIdx = nInptIdx;
                }
                if (++nChrIdx > nCharStart) {
                    nOutptLen += fGetOutptChrSize(nChrCode);
                }
            }
            aWhole = new fTAView(nOutptLen);
            for (var nInptIdx = nStartIdx, nOutptIdx = 0; nOutptIdx < nOutptLen; nInptIdx += fGetInptChrSize(nChrCode)) {
                nChrCode = fGetInptChrCode(vSource, nInptIdx);
                nOutptIdx = fPutOutptCode(aWhole, nChrCode, nOutptIdx);
            }
            break conversionSwitch;

          case 4:
            aWhole = new fTAView(nOutptLen);
            for (var nIdx = 0; nIdx < nOutptLen; nIdx++) {
                aWhole[nIdx] = vSource.charCodeAt(nIdx) & 255;
            }
            break conversionSwitch;

          case 5:
            nOutptLen = 0;
            for (var nMapIdx = 0; nMapIdx < nInptLen; nMapIdx++) {
                if (nMapIdx === nCharStart) {
                    nStartIdx = nOutptLen;
                }
                nOutptLen += fGetOutptChrSize(vSource.charCodeAt(nMapIdx));
                if (nMapIdx === nCharEnd) {
                    nEndIdx = nOutptLen;
                }
            }
            aWhole = new fTAView(nOutptLen);
            for (var nOutptIdx = 0, nChrIdx = 0; nOutptIdx < nOutptLen; nChrIdx++) {
                nOutptIdx = fPutOutptCode(aWhole, vSource.charCodeAt(nChrIdx), nOutptIdx);
            }
            break conversionSwitch;

          case 6:
            aWhole = new fTAView(nOutptLen);
            for (var nIdx = 0; nIdx < nOutptLen; nIdx++) {
                aWhole[nIdx] = vSource.charCodeAt(nIdx);
            }
            break conversionSwitch;

          case 7:
            aWhole = new fTAView(nOutptLen ? vSource : 0);
            break conversionSwitch;
        }
        aRaw = nTranscrType > 3 && (nStartIdx > 0 || nEndIdx < aWhole.length - 1) ? aWhole.subarray(nStartIdx, nEndIdx) : aWhole;
    }
    this.buffer = aWhole.buffer;
    this.bufferView = aWhole;
    this.rawData = aRaw;
    Object.freeze(this);
}

StringView.loadUTF8CharCode = function(aChars, nIdx) {
    var nLen = aChars.length, nPart = aChars[nIdx];
    return nPart > 251 && nPart < 254 && nIdx + 5 < nLen ? (nPart - 252) * 1073741824 + (aChars[nIdx + 1] - 128 << 24) + (aChars[nIdx + 2] - 128 << 18) + (aChars[nIdx + 3] - 128 << 12) + (aChars[nIdx + 4] - 128 << 6) + aChars[nIdx + 5] - 128 : nPart > 247 && nPart < 252 && nIdx + 4 < nLen ? (nPart - 248 << 24) + (aChars[nIdx + 1] - 128 << 18) + (aChars[nIdx + 2] - 128 << 12) + (aChars[nIdx + 3] - 128 << 6) + aChars[nIdx + 4] - 128 : nPart > 239 && nPart < 248 && nIdx + 3 < nLen ? (nPart - 240 << 18) + (aChars[nIdx + 1] - 128 << 12) + (aChars[nIdx + 2] - 128 << 6) + aChars[nIdx + 3] - 128 : nPart > 223 && nPart < 240 && nIdx + 2 < nLen ? (nPart - 224 << 12) + (aChars[nIdx + 1] - 128 << 6) + aChars[nIdx + 2] - 128 : nPart > 191 && nPart < 224 && nIdx + 1 < nLen ? (nPart - 192 << 6) + aChars[nIdx + 1] - 128 : nPart;
};

StringView.putUTF8CharCode = function(aTarget, nChar, nPutAt) {
    var nIdx = nPutAt;
    if (nChar < 128) {
        aTarget[nIdx++] = nChar;
    } else if (nChar < 2048) {
        aTarget[nIdx++] = 192 + (nChar >>> 6);
        aTarget[nIdx++] = 128 + (nChar & 63);
    } else if (nChar < 65536) {
        aTarget[nIdx++] = 224 + (nChar >>> 12);
        aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
        aTarget[nIdx++] = 128 + (nChar & 63);
    } else if (nChar < 2097152) {
        aTarget[nIdx++] = 240 + (nChar >>> 18);
        aTarget[nIdx++] = 128 + (nChar >>> 12 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
        aTarget[nIdx++] = 128 + (nChar & 63);
    } else if (nChar < 67108864) {
        aTarget[nIdx++] = 248 + (nChar >>> 24);
        aTarget[nIdx++] = 128 + (nChar >>> 18 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 12 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
        aTarget[nIdx++] = 128 + (nChar & 63);
    } else {
        aTarget[nIdx++] = 252 + nChar / 1073741824;
        aTarget[nIdx++] = 128 + (nChar >>> 24 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 18 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 12 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
        aTarget[nIdx++] = 128 + (nChar & 63);
    }
    return nIdx;
};

StringView.getUTF8CharLength = function(nChar) {
    return nChar < 128 ? 1 : nChar < 2048 ? 2 : nChar < 65536 ? 3 : nChar < 2097152 ? 4 : nChar < 67108864 ? 5 : 6;
};

StringView.loadUTF16CharCode = function(aChars, nIdx) {
    var nFrstChr = aChars[nIdx];
    return nFrstChr > 55231 && nIdx + 1 < aChars.length ? (nFrstChr - 55296 << 10) + aChars[nIdx + 1] + 9216 : nFrstChr;
};

StringView.putUTF16CharCode = function(aTarget, nChar, nPutAt) {
    var nIdx = nPutAt;
    if (nChar < 65536) {
        aTarget[nIdx++] = nChar;
    } else {
        aTarget[nIdx++] = 55232 + (nChar >>> 10);
        aTarget[nIdx++] = 56320 + (nChar & 1023);
    }
    return nIdx;
};

StringView.getUTF16CharLength = function(nChar) {
    return nChar < 65536 ? 1 : 2;
};

StringView.b64ToUint6 = function(nChr) {
    return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
};

StringView.uint6ToB64 = function(nUint6) {
    return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;
};

StringView.bytesToBase64 = function(aBytes) {
    var sB64Enc = "";
    for (var nMod3, nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
        nMod3 = nIdx % 3;
        if (nIdx > 0 && nIdx * 4 / 3 % 76 === 0) {
            sB64Enc += "\r\n";
        }
        nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
        if (nMod3 === 2 || aBytes.length - nIdx === 1) {
            sB64Enc += String.fromCharCode(StringView.uint6ToB64(nUint24 >>> 18 & 63), StringView.uint6ToB64(nUint24 >>> 12 & 63), StringView.uint6ToB64(nUint24 >>> 6 & 63), StringView.uint6ToB64(nUint24 & 63));
            nUint24 = 0;
        }
    }
    return sB64Enc.replace(/A(?=A$|$)/g, "=");
};

StringView.base64ToBytes = function(sBase64, nBlockBytes) {
    var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""), nInLen = sB64Enc.length, nOutLen = nBlockBytes ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockBytes) * nBlockBytes : nInLen * 3 + 1 >>> 2, aBytes = new Uint8Array(nOutLen);
    for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= StringView.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
            for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
                aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
            }
            nUint24 = 0;
        }
    }
    return aBytes;
};

StringView.makeFromBase64 = function(sB64Inpt, sEncoding, nByteOffset, nLength) {
    return new StringView(sEncoding === "UTF-16" || sEncoding === "UTF-32" ? StringView.base64ToBytes(sB64Inpt, sEncoding === "UTF-16" ? 2 : 4).buffer : StringView.base64ToBytes(sB64Inpt), sEncoding, nByteOffset, nLength);
};

StringView.prototype.encoding = "UTF-8";

StringView.prototype.makeIndex = function(nChrLength, nStartFrom) {
    var aTarget = this.rawData, nChrEnd, nRawLength = aTarget.length, nStartIdx = nStartFrom || 0, nIdxEnd = nStartIdx, nStopAtChr = isNaN(nChrLength) ? Infinity : nChrLength;
    if (nChrLength + 1 > aTarget.length) {
        throw new RangeError("StringView.prototype.makeIndex - The offset can't be major than the length of the array - 1.");
    }
    switch (this.encoding) {
      case "UTF-8":
        var nPart;
        for (nChrEnd = 0; nIdxEnd < nRawLength && nChrEnd < nStopAtChr; nChrEnd++) {
            nPart = aTarget[nIdxEnd];
            nIdxEnd += nPart > 251 && nPart < 254 && nIdxEnd + 5 < nRawLength ? 6 : nPart > 247 && nPart < 252 && nIdxEnd + 4 < nRawLength ? 5 : nPart > 239 && nPart < 248 && nIdxEnd + 3 < nRawLength ? 4 : nPart > 223 && nPart < 240 && nIdxEnd + 2 < nRawLength ? 3 : nPart > 191 && nPart < 224 && nIdxEnd + 1 < nRawLength ? 2 : 1;
        }
        break;

      case "UTF-16":
        for (nChrEnd = nStartIdx; nIdxEnd < nRawLength && nChrEnd < nStopAtChr; nChrEnd++) {
            nIdxEnd += aTarget[nIdxEnd] > 55231 && nIdxEnd + 1 < aTarget.length ? 2 : 1;
        }
        break;

      default:
        nIdxEnd = nChrEnd = isFinite(nChrLength) ? nChrLength : nRawLength - 1;
    }
    if (nChrLength) {
        return nIdxEnd;
    }
    return nChrEnd;
};

StringView.prototype.toBase64 = function(bWholeBuffer) {
    return StringView.bytesToBase64(bWholeBuffer ? this.bufferView.constructor === Uint8Array ? this.bufferView : new Uint8Array(this.buffer) : this.rawData.constructor === Uint8Array ? this.rawData : new Uint8Array(this.buffer, this.rawData.byteOffset, this.rawData.length << (this.rawData.constructor === Uint16Array ? 1 : 2)));
};

StringView.prototype.subview = function(nCharOffset, nCharLength) {
    var nChrLen, nCharStart, nStrLen, bVariableLen = this.encoding === "UTF-8" || this.encoding === "UTF-16", nStartOffset = nCharOffset, nStringLength, nRawLen = this.rawData.length;
    if (nRawLen === 0) {
        return new StringView(this.buffer, this.encoding);
    }
    nStringLength = bVariableLen ? this.makeIndex() : nRawLen;
    nCharStart = nCharOffset ? Math.max((nStringLength + nCharOffset) % nStringLength, 0) : 0;
    nStrLen = Number.isInteger(nCharLength) ? Math.max(nCharLength, 0) + nCharStart > nStringLength ? nStringLength - nCharStart : nCharLength : nStringLength;
    if (nCharStart === 0 && nStrLen === nStringLength) {
        return this;
    }
    if (bVariableLen) {
        nStartOffset = this.makeIndex(nCharStart);
        nChrLen = this.makeIndex(nStrLen, nStartOffset) - nStartOffset;
    } else {
        nStartOffset = nCharStart;
        nChrLen = nStrLen - nCharStart;
    }
    if (this.encoding === "UTF-16") {
        nStartOffset <<= 1;
    } else if (this.encoding === "UTF-32") {
        nStartOffset <<= 2;
    }
    return new StringView(this.buffer, this.encoding, nStartOffset, nChrLen);
};

StringView.prototype.forEachChar = function(fCallback, oThat, nChrOffset, nChrLen) {
    var aSource = this.rawData, nRawEnd, nRawIdx;
    if (this.encoding === "UTF-8" || this.encoding === "UTF-16") {
        var fGetInptChrSize, fGetInptChrCode;
        if (this.encoding === "UTF-8") {
            fGetInptChrSize = StringView.getUTF8CharLength;
            fGetInptChrCode = StringView.loadUTF8CharCode;
        } else if (this.encoding === "UTF-16") {
            fGetInptChrSize = StringView.getUTF16CharLength;
            fGetInptChrCode = StringView.loadUTF16CharCode;
        }
        nRawIdx = isFinite(nChrOffset) ? this.makeIndex(nChrOffset) : 0;
        nRawEnd = isFinite(nChrLen) ? this.makeIndex(nChrLen, nRawIdx) : aSource.length;
        for (var nChrCode, nChrIdx = 0; nRawIdx < nRawEnd; nChrIdx++) {
            nChrCode = fGetInptChrCode(aSource, nRawIdx);
            fCallback.call(oThat || null, nChrCode, nChrIdx, nRawIdx, aSource);
            nRawIdx += fGetInptChrSize(nChrCode);
        }
    } else {
        nRawIdx = isFinite(nChrOffset) ? nChrOffset : 0;
        nRawEnd = isFinite(nChrLen) ? nChrLen + nRawIdx : aSource.length;
        for (nRawIdx; nRawIdx < nRawEnd; nRawIdx++) {
            fCallback.call(oThat || null, aSource[nRawIdx], nRawIdx, nRawIdx, aSource);
        }
    }
};

StringView.prototype.valueOf = StringView.prototype.toString = function() {
    if (this.encoding !== "UTF-8" && this.encoding !== "UTF-16") {
        return String.fromCharCode.apply(null, this.rawData);
    }
    var fGetCode, fGetIncr, sView = "";
    if (this.encoding === "UTF-8") {
        fGetIncr = StringView.getUTF8CharLength;
        fGetCode = StringView.loadUTF8CharCode;
    } else if (this.encoding === "UTF-16") {
        fGetIncr = StringView.getUTF16CharLength;
        fGetCode = StringView.loadUTF16CharCode;
    }
    for (var nChr, nLen = this.rawData.length, nIdx = 0; nIdx < nLen; nIdx += fGetIncr(nChr)) {
        nChr = fGetCode(this.rawData, nIdx);
        sView += String.fromCharCode(nChr);
    }
    return sView;
};
//# sourceMappingURL=ngForce-dependencies.min.js.map