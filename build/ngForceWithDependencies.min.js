/*! ngForce - customized by smb - 2016-06-10 */
/*! visit https://noeticpenguin.github.io/ngForce for more info. */

(function() {
    var root = this;
    var previousUnderscore = root._;
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
    var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
    var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, nativeCreate = Object.create;
    var Ctor = function() {};
    var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
    };
    if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = _;
        }
        exports._ = _;
    } else {
        root._ = _;
    }
    _.VERSION = "1.8.3";
    var optimizeCb = function(func, context, argCount) {
        if (context === void 0) return func;
        switch (argCount == null ? 3 : argCount) {
          case 1:
            return function(value) {
                return func.call(context, value);
            };

          case 2:
            return function(value, other) {
                return func.call(context, value, other);
            };

          case 3:
            return function(value, index, collection) {
                return func.call(context, value, index, collection);
            };

          case 4:
            return function(accumulator, value, index, collection) {
                return func.call(context, accumulator, value, index, collection);
            };
        }
        return function() {
            return func.apply(context, arguments);
        };
    };
    var cb = function(value, context, argCount) {
        if (value == null) return _.identity;
        if (_.isFunction(value)) return optimizeCb(value, context, argCount);
        if (_.isObject(value)) return _.matcher(value);
        return _.property(value);
    };
    _.iteratee = function(value, context) {
        return cb(value, context, Infinity);
    };
    var createAssigner = function(keysFunc, undefinedOnly) {
        return function(obj) {
            var length = arguments.length;
            if (length < 2 || obj == null) return obj;
            for (var index = 1; index < length; index++) {
                var source = arguments[index], keys = keysFunc(source), l = keys.length;
                for (var i = 0; i < l; i++) {
                    var key = keys[i];
                    if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
                }
            }
            return obj;
        };
    };
    var baseCreate = function(prototype) {
        if (!_.isObject(prototype)) return {};
        if (nativeCreate) return nativeCreate(prototype);
        Ctor.prototype = prototype;
        var result = new Ctor();
        Ctor.prototype = null;
        return result;
    };
    var property = function(key) {
        return function(obj) {
            return obj == null ? void 0 : obj[key];
        };
    };
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    var getLength = property("length");
    var isArrayLike = function(collection) {
        var length = getLength(collection);
        return typeof length == "number" && length >= 0 && length <= MAX_ARRAY_INDEX;
    };
    _.each = _.forEach = function(obj, iteratee, context) {
        iteratee = optimizeCb(iteratee, context);
        var i, length;
        if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; i++) {
                iteratee(obj[i], i, obj);
            }
        } else {
            var keys = _.keys(obj);
            for (i = 0, length = keys.length; i < length; i++) {
                iteratee(obj[keys[i]], keys[i], obj);
            }
        }
        return obj;
    };
    _.map = _.collect = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length);
        for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            results[index] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
    };
    function createReduce(dir) {
        function iterator(obj, iteratee, memo, keys, index, length) {
            for (;index >= 0 && index < length; index += dir) {
                var currentKey = keys ? keys[index] : index;
                memo = iteratee(memo, obj[currentKey], currentKey, obj);
            }
            return memo;
        }
        return function(obj, iteratee, memo, context) {
            iteratee = optimizeCb(iteratee, context, 4);
            var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1;
            if (arguments.length < 3) {
                memo = obj[keys ? keys[index] : index];
                index += dir;
            }
            return iterator(obj, iteratee, memo, keys, index, length);
        };
    }
    _.reduce = _.foldl = _.inject = createReduce(1);
    _.reduceRight = _.foldr = createReduce(-1);
    _.find = _.detect = function(obj, predicate, context) {
        var key;
        if (isArrayLike(obj)) {
            key = _.findIndex(obj, predicate, context);
        } else {
            key = _.findKey(obj, predicate, context);
        }
        if (key !== void 0 && key !== -1) return obj[key];
    };
    _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        predicate = cb(predicate, context);
        _.each(obj, function(value, index, list) {
            if (predicate(value, index, list)) results.push(value);
        });
        return results;
    };
    _.reject = function(obj, predicate, context) {
        return _.filter(obj, _.negate(cb(predicate)), context);
    };
    _.every = _.all = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            if (!predicate(obj[currentKey], currentKey, obj)) return false;
        }
        return true;
    };
    _.some = _.any = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            if (predicate(obj[currentKey], currentKey, obj)) return true;
        }
        return false;
    };
    _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        if (typeof fromIndex != "number" || guard) fromIndex = 0;
        return _.indexOf(obj, item, fromIndex) >= 0;
    };
    _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
            var func = isFunc ? method : value[method];
            return func == null ? func : func.apply(value, args);
        });
    };
    _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
    };
    _.where = function(obj, attrs) {
        return _.filter(obj, _.matcher(attrs));
    };
    _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matcher(attrs));
    };
    _.max = function(obj, iteratee, context) {
        var result = -Infinity, lastComputed = -Infinity, value, computed;
        if (iteratee == null && obj != null) {
            obj = isArrayLike(obj) ? obj : _.values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
                value = obj[i];
                if (value > result) {
                    result = value;
                }
            }
        } else {
            iteratee = cb(iteratee, context);
            _.each(obj, function(value, index, list) {
                computed = iteratee(value, index, list);
                if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                    result = value;
                    lastComputed = computed;
                }
            });
        }
        return result;
    };
    _.min = function(obj, iteratee, context) {
        var result = Infinity, lastComputed = Infinity, value, computed;
        if (iteratee == null && obj != null) {
            obj = isArrayLike(obj) ? obj : _.values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
                value = obj[i];
                if (value < result) {
                    result = value;
                }
            }
        } else {
            iteratee = cb(iteratee, context);
            _.each(obj, function(value, index, list) {
                computed = iteratee(value, index, list);
                if (computed < lastComputed || computed === Infinity && result === Infinity) {
                    result = value;
                    lastComputed = computed;
                }
            });
        }
        return result;
    };
    _.shuffle = function(obj) {
        var set = isArrayLike(obj) ? obj : _.values(obj);
        var length = set.length;
        var shuffled = Array(length);
        for (var index = 0, rand; index < length; index++) {
            rand = _.random(0, index);
            if (rand !== index) shuffled[index] = shuffled[rand];
            shuffled[rand] = set[index];
        }
        return shuffled;
    };
    _.sample = function(obj, n, guard) {
        if (n == null || guard) {
            if (!isArrayLike(obj)) obj = _.values(obj);
            return obj[_.random(obj.length - 1)];
        }
        return _.shuffle(obj).slice(0, Math.max(0, n));
    };
    _.sortBy = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        return _.pluck(_.map(obj, function(value, index, list) {
            return {
                value: value,
                index: index,
                criteria: iteratee(value, index, list)
            };
        }).sort(function(left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
                if (a > b || a === void 0) return 1;
                if (a < b || b === void 0) return -1;
            }
            return left.index - right.index;
        }), "value");
    };
    var group = function(behavior) {
        return function(obj, iteratee, context) {
            var result = {};
            iteratee = cb(iteratee, context);
            _.each(obj, function(value, index) {
                var key = iteratee(value, index, obj);
                behavior(result, value, key);
            });
            return result;
        };
    };
    _.groupBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key].push(value); else result[key] = [ value ];
    });
    _.indexBy = group(function(result, value, key) {
        result[key] = value;
    });
    _.countBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key]++; else result[key] = 1;
    });
    _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (isArrayLike(obj)) return _.map(obj, _.identity);
        return _.values(obj);
    };
    _.size = function(obj) {
        if (obj == null) return 0;
        return isArrayLike(obj) ? obj.length : _.keys(obj).length;
    };
    _.partition = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var pass = [], fail = [];
        _.each(obj, function(value, key, obj) {
            (predicate(value, key, obj) ? pass : fail).push(value);
        });
        return [ pass, fail ];
    };
    _.first = _.head = _.take = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) return array[0];
        return _.initial(array, array.length - n);
    };
    _.initial = function(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    };
    _.last = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) return array[array.length - 1];
        return _.rest(array, Math.max(0, array.length - n));
    };
    _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
    };
    _.compact = function(array) {
        return _.filter(array, _.identity);
    };
    var flatten = function(input, shallow, strict, startIndex) {
        var output = [], idx = 0;
        for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
            var value = input[i];
            if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
                if (!shallow) value = flatten(value, shallow, strict);
                var j = 0, len = value.length;
                output.length += len;
                while (j < len) {
                    output[idx++] = value[j++];
                }
            } else if (!strict) {
                output[idx++] = value;
            }
        }
        return output;
    };
    _.flatten = function(array, shallow) {
        return flatten(array, shallow, false);
    };
    _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
    };
    _.uniq = _.unique = function(array, isSorted, iteratee, context) {
        if (!_.isBoolean(isSorted)) {
            context = iteratee;
            iteratee = isSorted;
            isSorted = false;
        }
        if (iteratee != null) iteratee = cb(iteratee, context);
        var result = [];
        var seen = [];
        for (var i = 0, length = getLength(array); i < length; i++) {
            var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
            if (isSorted) {
                if (!i || seen !== computed) result.push(value);
                seen = computed;
            } else if (iteratee) {
                if (!_.contains(seen, computed)) {
                    seen.push(computed);
                    result.push(value);
                }
            } else if (!_.contains(result, value)) {
                result.push(value);
            }
        }
        return result;
    };
    _.union = function() {
        return _.uniq(flatten(arguments, true, true));
    };
    _.intersection = function(array) {
        var result = [];
        var argsLength = arguments.length;
        for (var i = 0, length = getLength(array); i < length; i++) {
            var item = array[i];
            if (_.contains(result, item)) continue;
            for (var j = 1; j < argsLength; j++) {
                if (!_.contains(arguments[j], item)) break;
            }
            if (j === argsLength) result.push(item);
        }
        return result;
    };
    _.difference = function(array) {
        var rest = flatten(arguments, true, true, 1);
        return _.filter(array, function(value) {
            return !_.contains(rest, value);
        });
    };
    _.zip = function() {
        return _.unzip(arguments);
    };
    _.unzip = function(array) {
        var length = array && _.max(array, getLength).length || 0;
        var result = Array(length);
        for (var index = 0; index < length; index++) {
            result[index] = _.pluck(array, index);
        }
        return result;
    };
    _.object = function(list, values) {
        var result = {};
        for (var i = 0, length = getLength(list); i < length; i++) {
            if (values) {
                result[list[i]] = values[i];
            } else {
                result[list[i][0]] = list[i][1];
            }
        }
        return result;
    };
    function createPredicateIndexFinder(dir) {
        return function(array, predicate, context) {
            predicate = cb(predicate, context);
            var length = getLength(array);
            var index = dir > 0 ? 0 : length - 1;
            for (;index >= 0 && index < length; index += dir) {
                if (predicate(array[index], index, array)) return index;
            }
            return -1;
        };
    }
    _.findIndex = createPredicateIndexFinder(1);
    _.findLastIndex = createPredicateIndexFinder(-1);
    _.sortedIndex = function(array, obj, iteratee, context) {
        iteratee = cb(iteratee, context, 1);
        var value = iteratee(obj);
        var low = 0, high = getLength(array);
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
        }
        return low;
    };
    function createIndexFinder(dir, predicateFind, sortedIndex) {
        return function(array, item, idx) {
            var i = 0, length = getLength(array);
            if (typeof idx == "number") {
                if (dir > 0) {
                    i = idx >= 0 ? idx : Math.max(idx + length, i);
                } else {
                    length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
                }
            } else if (sortedIndex && idx && length) {
                idx = sortedIndex(array, item);
                return array[idx] === item ? idx : -1;
            }
            if (item !== item) {
                idx = predicateFind(slice.call(array, i, length), _.isNaN);
                return idx >= 0 ? idx + i : -1;
            }
            for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
                if (array[idx] === item) return idx;
            }
            return -1;
        };
    }
    _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
    _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
    _.range = function(start, stop, step) {
        if (stop == null) {
            stop = start || 0;
            start = 0;
        }
        step = step || 1;
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range = Array(length);
        for (var idx = 0; idx < length; idx++, start += step) {
            range[idx] = start;
        }
        return range;
    };
    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
        var self = baseCreate(sourceFunc.prototype);
        var result = sourceFunc.apply(self, args);
        if (_.isObject(result)) return result;
        return self;
    };
    _.bind = function(func, context) {
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError("Bind must be called on a function");
        var args = slice.call(arguments, 2);
        var bound = function() {
            return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
        };
        return bound;
    };
    _.partial = function(func) {
        var boundArgs = slice.call(arguments, 1);
        var bound = function() {
            var position = 0, length = boundArgs.length;
            var args = Array(length);
            for (var i = 0; i < length; i++) {
                args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
            }
            while (position < arguments.length) args.push(arguments[position++]);
            return executeBound(func, bound, this, this, args);
        };
        return bound;
    };
    _.bindAll = function(obj) {
        var i, length = arguments.length, key;
        if (length <= 1) throw new Error("bindAll must be passed function names");
        for (i = 1; i < length; i++) {
            key = arguments[i];
            obj[key] = _.bind(obj[key], obj);
        }
        return obj;
    };
    _.memoize = function(func, hasher) {
        var memoize = function(key) {
            var cache = memoize.cache;
            var address = "" + (hasher ? hasher.apply(this, arguments) : key);
            if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
            return cache[address];
        };
        memoize.cache = {};
        return memoize;
    };
    _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function() {
            return func.apply(null, args);
        }, wait);
    };
    _.defer = _.partial(_.delay, _, 1);
    _.throttle = function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) options = {};
        var later = function() {
            previous = options.leading === false ? 0 : _.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        };
        return function() {
            var now = _.now();
            if (!previous && options.leading === false) previous = now;
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                previous = now;
                result = func.apply(context, args);
                if (!timeout) context = args = null;
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    };
    _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        var later = function() {
            var last = _.now() - timestamp;
            if (last < wait && last >= 0) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                }
            }
        };
        return function() {
            context = this;
            args = arguments;
            timestamp = _.now();
            var callNow = immediate && !timeout;
            if (!timeout) timeout = setTimeout(later, wait);
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }
            return result;
        };
    };
    _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
    };
    _.negate = function(predicate) {
        return function() {
            return !predicate.apply(this, arguments);
        };
    };
    _.compose = function() {
        var args = arguments;
        var start = args.length - 1;
        return function() {
            var i = start;
            var result = args[start].apply(this, arguments);
            while (i--) result = args[i].call(this, result);
            return result;
        };
    };
    _.after = function(times, func) {
        return function() {
            if (--times < 1) {
                return func.apply(this, arguments);
            }
        };
    };
    _.before = function(times, func) {
        var memo;
        return function() {
            if (--times > 0) {
                memo = func.apply(this, arguments);
            }
            if (times <= 1) func = null;
            return memo;
        };
    };
    _.once = _.partial(_.before, 2);
    var hasEnumBug = !{
        toString: null
    }.propertyIsEnumerable("toString");
    var nonEnumerableProps = [ "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString" ];
    function collectNonEnumProps(obj, keys) {
        var nonEnumIdx = nonEnumerableProps.length;
        var constructor = obj.constructor;
        var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
        var prop = "constructor";
        if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
        while (nonEnumIdx--) {
            prop = nonEnumerableProps[nonEnumIdx];
            if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
                keys.push(prop);
            }
        }
    }
    _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj) if (_.has(obj, key)) keys.push(key);
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
    };
    _.allKeys = function(obj) {
        if (!_.isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
    };
    _.values = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
        }
        return values;
    };
    _.mapObject = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = _.keys(obj), length = keys.length, results = {}, currentKey;
        for (var index = 0; index < length; index++) {
            currentKey = keys[index];
            results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
    };
    _.pairs = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = Array(length);
        for (var i = 0; i < length; i++) {
            pairs[i] = [ keys[i], obj[keys[i]] ];
        }
        return pairs;
    };
    _.invert = function(obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
            result[obj[keys[i]]] = keys[i];
        }
        return result;
    };
    _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
            if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
    };
    _.extend = createAssigner(_.allKeys);
    _.extendOwn = _.assign = createAssigner(_.keys);
    _.findKey = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = _.keys(obj), key;
        for (var i = 0, length = keys.length; i < length; i++) {
            key = keys[i];
            if (predicate(obj[key], key, obj)) return key;
        }
    };
    _.pick = function(object, oiteratee, context) {
        var result = {}, obj = object, iteratee, keys;
        if (obj == null) return result;
        if (_.isFunction(oiteratee)) {
            keys = _.allKeys(obj);
            iteratee = optimizeCb(oiteratee, context);
        } else {
            keys = flatten(arguments, false, false, 1);
            iteratee = function(value, key, obj) {
                return key in obj;
            };
            obj = Object(obj);
        }
        for (var i = 0, length = keys.length; i < length; i++) {
            var key = keys[i];
            var value = obj[key];
            if (iteratee(value, key, obj)) result[key] = value;
        }
        return result;
    };
    _.omit = function(obj, iteratee, context) {
        if (_.isFunction(iteratee)) {
            iteratee = _.negate(iteratee);
        } else {
            var keys = _.map(flatten(arguments, false, false, 1), String);
            iteratee = function(value, key) {
                return !_.contains(keys, key);
            };
        }
        return _.pick(obj, iteratee, context);
    };
    _.defaults = createAssigner(_.allKeys, true);
    _.create = function(prototype, props) {
        var result = baseCreate(prototype);
        if (props) _.extendOwn(result, props);
        return result;
    };
    _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };
    _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
    };
    _.isMatch = function(object, attrs) {
        var keys = _.keys(attrs), length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
            var key = keys[i];
            if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
    };
    var eq = function(a, b, aStack, bStack) {
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        if (a == null || b == null) return a === b;
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
          case "[object RegExp]":
          case "[object String]":
            return "" + a === "" + b;

          case "[object Number]":
            if (+a !== +a) return +b !== +b;
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;

          case "[object Date]":
          case "[object Boolean]":
            return +a === +b;
        }
        var areArrays = className === "[object Array]";
        if (!areArrays) {
            if (typeof a != "object" || typeof b != "object") return false;
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
                return false;
            }
        }
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
            if (aStack[length] === a) return bStack[length] === b;
        }
        aStack.push(a);
        bStack.push(b);
        if (areArrays) {
            length = a.length;
            if (length !== b.length) return false;
            while (length--) {
                if (!eq(a[length], b[length], aStack, bStack)) return false;
            }
        } else {
            var keys = _.keys(a), key;
            length = keys.length;
            if (_.keys(b).length !== length) return false;
            while (length--) {
                key = keys[length];
                if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
            }
        }
        aStack.pop();
        bStack.pop();
        return true;
    };
    _.isEqual = function(a, b) {
        return eq(a, b);
    };
    _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
        return _.keys(obj).length === 0;
    };
    _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
    };
    _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) === "[object Array]";
    };
    _.isObject = function(obj) {
        var type = typeof obj;
        return type === "function" || type === "object" && !!obj;
    };
    _.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp", "Error" ], function(name) {
        _["is" + name] = function(obj) {
            return toString.call(obj) === "[object " + name + "]";
        };
    });
    if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
            return _.has(obj, "callee");
        };
    }
    if (typeof /./ != "function" && typeof Int8Array != "object") {
        _.isFunction = function(obj) {
            return typeof obj == "function" || false;
        };
    }
    _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
    };
    _.isNaN = function(obj) {
        return _.isNumber(obj) && obj !== +obj;
    };
    _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
    };
    _.isNull = function(obj) {
        return obj === null;
    };
    _.isUndefined = function(obj) {
        return obj === void 0;
    };
    _.has = function(obj, key) {
        return obj != null && hasOwnProperty.call(obj, key);
    };
    _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
    };
    _.identity = function(value) {
        return value;
    };
    _.constant = function(value) {
        return function() {
            return value;
        };
    };
    _.noop = function() {};
    _.property = property;
    _.propertyOf = function(obj) {
        return obj == null ? function() {} : function(key) {
            return obj[key];
        };
    };
    _.matcher = _.matches = function(attrs) {
        attrs = _.extendOwn({}, attrs);
        return function(obj) {
            return _.isMatch(obj, attrs);
        };
    };
    _.times = function(n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = optimizeCb(iteratee, context, 1);
        for (var i = 0; i < n; i++) accum[i] = iteratee(i);
        return accum;
    };
    _.random = function(min, max) {
        if (max == null) {
            max = min;
            min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
    };
    _.now = Date.now || function() {
        return new Date().getTime();
    };
    var escapeMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    };
    var unescapeMap = _.invert(escapeMap);
    var createEscaper = function(map) {
        var escaper = function(match) {
            return map[match];
        };
        var source = "(?:" + _.keys(map).join("|") + ")";
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, "g");
        return function(string) {
            string = string == null ? "" : "" + string;
            return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
    };
    _.escape = createEscaper(escapeMap);
    _.unescape = createEscaper(unescapeMap);
    _.result = function(object, property, fallback) {
        var value = object == null ? void 0 : object[property];
        if (value === void 0) {
            value = fallback;
        }
        return _.isFunction(value) ? value.call(object) : value;
    };
    var idCounter = 0;
    _.uniqueId = function(prefix) {
        var id = ++idCounter + "";
        return prefix ? prefix + id : id;
    };
    _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var noMatch = /(.)^/;
    var escapes = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
    };
    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
    var escapeChar = function(match) {
        return "\\" + escapes[match];
    };
    _.template = function(text, settings, oldSettings) {
        if (!settings && oldSettings) settings = oldSettings;
        settings = _.defaults({}, settings, _.templateSettings);
        var matcher = RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g");
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
            source += text.slice(index, offset).replace(escaper, escapeChar);
            index = offset + match.length;
            if (escape) {
                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
            } else if (interpolate) {
                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
            } else if (evaluate) {
                source += "';\n" + evaluate + "\n__p+='";
            }
            return match;
        });
        source += "';\n";
        if (!settings.variable) source = "with(obj||{}){\n" + source + "}\n";
        source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
        try {
            var render = new Function(settings.variable || "obj", "_", source);
        } catch (e) {
            e.source = source;
            throw e;
        }
        var template = function(data) {
            return render.call(this, data, _);
        };
        var argument = settings.variable || "obj";
        template.source = "function(" + argument + "){\n" + source + "}";
        return template;
    };
    _.chain = function(obj) {
        var instance = _(obj);
        instance._chain = true;
        return instance;
    };
    var result = function(instance, obj) {
        return instance._chain ? _(obj).chain() : obj;
    };
    _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function() {
                var args = [ this._wrapped ];
                push.apply(args, arguments);
                return result(this, func.apply(_, args));
            };
        });
    };
    _.mixin(_);
    _.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            var obj = this._wrapped;
            method.apply(obj, arguments);
            if ((name === "shift" || name === "splice") && obj.length === 0) delete obj[0];
            return result(this, obj);
        };
    });
    _.each([ "concat", "join", "slice" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            return result(this, method.apply(this._wrapped, arguments));
        };
    });
    _.prototype.value = function() {
        return this._wrapped;
    };
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    _.prototype.toString = function() {
        return "" + this._wrapped;
    };
    if (typeof define === "function" && define.amd) {
        define("underscore", [], function() {
            return _;
        });
    }
}).call(this);

(function(factory) {
    var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global;
    if (typeof define === "function" && define.amd) {
        define([ "underscore", "jquery", "exports" ], function(_, $, exports) {
            root.Backbone = factory(root, exports, _, $);
        });
    } else if (typeof exports !== "undefined") {
        var _ = require("underscore"), $;
        try {
            $ = require("jquery");
        } catch (e) {}
        factory(root, exports, _, $);
    } else {
        root.Backbone = factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$);
    }
})(function(root, Backbone, _, $) {
    var previousBackbone = root.Backbone;
    var slice = Array.prototype.slice;
    Backbone.VERSION = "1.3.3";
    Backbone.$ = $;
    Backbone.noConflict = function() {
        root.Backbone = previousBackbone;
        return this;
    };
    Backbone.emulateHTTP = false;
    Backbone.emulateJSON = false;
    var addMethod = function(length, method, attribute) {
        switch (length) {
          case 1:
            return function() {
                return _[method](this[attribute]);
            };

          case 2:
            return function(value) {
                return _[method](this[attribute], value);
            };

          case 3:
            return function(iteratee, context) {
                return _[method](this[attribute], cb(iteratee, this), context);
            };

          case 4:
            return function(iteratee, defaultVal, context) {
                return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
            };

          default:
            return function() {
                var args = slice.call(arguments);
                args.unshift(this[attribute]);
                return _[method].apply(_, args);
            };
        }
    };
    var addUnderscoreMethods = function(Class, methods, attribute) {
        _.each(methods, function(length, method) {
            if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
        });
    };
    var cb = function(iteratee, instance) {
        if (_.isFunction(iteratee)) return iteratee;
        if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
        if (_.isString(iteratee)) return function(model) {
            return model.get(iteratee);
        };
        return iteratee;
    };
    var modelMatcher = function(attrs) {
        var matcher = _.matches(attrs);
        return function(model) {
            return matcher(model.attributes);
        };
    };
    var Events = Backbone.Events = {};
    var eventSplitter = /\s+/;
    var eventsApi = function(iteratee, events, name, callback, opts) {
        var i = 0, names;
        if (name && typeof name === "object") {
            if (callback !== void 0 && "context" in opts && opts.context === void 0) opts.context = callback;
            for (names = _.keys(name); i < names.length; i++) {
                events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
            }
        } else if (name && eventSplitter.test(name)) {
            for (names = name.split(eventSplitter); i < names.length; i++) {
                events = iteratee(events, names[i], callback, opts);
            }
        } else {
            events = iteratee(events, name, callback, opts);
        }
        return events;
    };
    Events.on = function(name, callback, context) {
        return internalOn(this, name, callback, context);
    };
    var internalOn = function(obj, name, callback, context, listening) {
        obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
            context: context,
            ctx: obj,
            listening: listening
        });
        if (listening) {
            var listeners = obj._listeners || (obj._listeners = {});
            listeners[listening.id] = listening;
        }
        return obj;
    };
    Events.listenTo = function(obj, name, callback) {
        if (!obj) return this;
        var id = obj._listenId || (obj._listenId = _.uniqueId("l"));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = listeningTo[id];
        if (!listening) {
            var thisId = this._listenId || (this._listenId = _.uniqueId("l"));
            listening = listeningTo[id] = {
                obj: obj,
                objId: id,
                id: thisId,
                listeningTo: listeningTo,
                count: 0
            };
        }
        internalOn(obj, name, callback, this, listening);
        return this;
    };
    var onApi = function(events, name, callback, options) {
        if (callback) {
            var handlers = events[name] || (events[name] = []);
            var context = options.context, ctx = options.ctx, listening = options.listening;
            if (listening) listening.count++;
            handlers.push({
                callback: callback,
                context: context,
                ctx: context || ctx,
                listening: listening
            });
        }
        return events;
    };
    Events.off = function(name, callback, context) {
        if (!this._events) return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
            context: context,
            listeners: this._listeners
        });
        return this;
    };
    Events.stopListening = function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) return this;
        var ids = obj ? [ obj._listenId ] : _.keys(listeningTo);
        for (var i = 0; i < ids.length; i++) {
            var listening = listeningTo[ids[i]];
            if (!listening) break;
            listening.obj.off(name, callback, this);
        }
        return this;
    };
    var offApi = function(events, name, callback, options) {
        if (!events) return;
        var i = 0, listening;
        var context = options.context, listeners = options.listeners;
        if (!name && !callback && !context) {
            var ids = _.keys(listeners);
            for (;i < ids.length; i++) {
                listening = listeners[ids[i]];
                delete listeners[listening.id];
                delete listening.listeningTo[listening.objId];
            }
            return;
        }
        var names = name ? [ name ] : _.keys(events);
        for (;i < names.length; i++) {
            name = names[i];
            var handlers = events[name];
            if (!handlers) break;
            var remaining = [];
            for (var j = 0; j < handlers.length; j++) {
                var handler = handlers[j];
                if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
                    remaining.push(handler);
                } else {
                    listening = handler.listening;
                    if (listening && --listening.count === 0) {
                        delete listeners[listening.id];
                        delete listening.listeningTo[listening.objId];
                    }
                }
            }
            if (remaining.length) {
                events[name] = remaining;
            } else {
                delete events[name];
            }
        }
        return events;
    };
    Events.once = function(name, callback, context) {
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
        if (typeof name === "string" && context == null) callback = void 0;
        return this.on(events, callback, context);
    };
    Events.listenToOnce = function(obj, name, callback) {
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
        return this.listenTo(obj, events);
    };
    var onceMap = function(map, name, callback, offer) {
        if (callback) {
            var once = map[name] = _.once(function() {
                offer(name, once);
                callback.apply(this, arguments);
            });
            once._callback = callback;
        }
        return map;
    };
    Events.trigger = function(name) {
        if (!this._events) return this;
        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for (var i = 0; i < length; i++) args[i] = arguments[i + 1];
        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
    };
    var triggerApi = function(objEvents, name, callback, args) {
        if (objEvents) {
            var events = objEvents[name];
            var allEvents = objEvents.all;
            if (events && allEvents) allEvents = allEvents.slice();
            if (events) triggerEvents(events, args);
            if (allEvents) triggerEvents(allEvents, [ name ].concat(args));
        }
        return objEvents;
    };
    var triggerEvents = function(events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
          case 0:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx);
            return;

          case 1:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);
            return;

          case 2:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);
            return;

          case 3:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
            return;

          default:
            while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
            return;
        }
    };
    Events.bind = Events.on;
    Events.unbind = Events.off;
    _.extend(Backbone, Events);
    var Model = Backbone.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection) this.collection = options.collection;
        if (options.parse) attrs = this.parse(attrs, options) || {};
        var defaults = _.result(this, "defaults");
        attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
    };
    _.extend(Model.prototype, Events, {
        changed: null,
        validationError: null,
        idAttribute: "id",
        cidPrefix: "c",
        initialize: function() {},
        toJSON: function(options) {
            return _.clone(this.attributes);
        },
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },
        get: function(attr) {
            return this.attributes[attr];
        },
        escape: function(attr) {
            return _.escape(this.get(attr));
        },
        has: function(attr) {
            return this.get(attr) != null;
        },
        matches: function(attrs) {
            return !!_.iteratee(attrs, this)(this.attributes);
        },
        set: function(key, val, options) {
            if (key == null) return this;
            var attrs;
            if (typeof key === "object") {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }
            options || (options = {});
            if (!this._validate(attrs, options)) return false;
            var unset = options.unset;
            var silent = options.silent;
            var changes = [];
            var changing = this._changing;
            this._changing = true;
            if (!changing) {
                this._previousAttributes = _.clone(this.attributes);
                this.changed = {};
            }
            var current = this.attributes;
            var changed = this.changed;
            var prev = this._previousAttributes;
            for (var attr in attrs) {
                val = attrs[attr];
                if (!_.isEqual(current[attr], val)) changes.push(attr);
                if (!_.isEqual(prev[attr], val)) {
                    changed[attr] = val;
                } else {
                    delete changed[attr];
                }
                unset ? delete current[attr] : current[attr] = val;
            }
            if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);
            if (!silent) {
                if (changes.length) this._pending = options;
                for (var i = 0; i < changes.length; i++) {
                    this.trigger("change:" + changes[i], this, current[changes[i]], options);
                }
            }
            if (changing) return this;
            if (!silent) {
                while (this._pending) {
                    options = this._pending;
                    this._pending = false;
                    this.trigger("change", this, options);
                }
            }
            this._pending = false;
            this._changing = false;
            return this;
        },
        unset: function(attr, options) {
            return this.set(attr, void 0, _.extend({}, options, {
                unset: true
            }));
        },
        clear: function(options) {
            var attrs = {};
            for (var key in this.attributes) attrs[key] = void 0;
            return this.set(attrs, _.extend({}, options, {
                unset: true
            }));
        },
        hasChanged: function(attr) {
            if (attr == null) return !_.isEmpty(this.changed);
            return _.has(this.changed, attr);
        },
        changedAttributes: function(diff) {
            if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
            var old = this._changing ? this._previousAttributes : this.attributes;
            var changed = {};
            for (var attr in diff) {
                var val = diff[attr];
                if (_.isEqual(old[attr], val)) continue;
                changed[attr] = val;
            }
            return _.size(changed) ? changed : false;
        },
        previous: function(attr) {
            if (attr == null || !this._previousAttributes) return null;
            return this._previousAttributes[attr];
        },
        previousAttributes: function() {
            return _.clone(this._previousAttributes);
        },
        fetch: function(options) {
            options = _.extend({
                parse: true
            }, options);
            var model = this;
            var success = options.success;
            options.success = function(resp) {
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (!model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger("sync", model, resp, options);
            };
            wrapError(this, options);
            return this.sync("read", this, options);
        },
        save: function(key, val, options) {
            var attrs;
            if (key == null || typeof key === "object") {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }
            options = _.extend({
                validate: true,
                parse: true
            }, options);
            var wait = options.wait;
            if (attrs && !wait) {
                if (!this.set(attrs, options)) return false;
            } else if (!this._validate(attrs, options)) {
                return false;
            }
            var model = this;
            var success = options.success;
            var attributes = this.attributes;
            options.success = function(resp) {
                model.attributes = attributes;
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
                if (serverAttrs && !model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger("sync", model, resp, options);
            };
            wrapError(this, options);
            if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);
            var method = this.isNew() ? "create" : options.patch ? "patch" : "update";
            if (method === "patch" && !options.attrs) options.attrs = attrs;
            var xhr = this.sync(method, this, options);
            this.attributes = attributes;
            return xhr;
        },
        destroy: function(options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;
            var wait = options.wait;
            var destroy = function() {
                model.stopListening();
                model.trigger("destroy", model, model.collection, options);
            };
            options.success = function(resp) {
                if (wait) destroy();
                if (success) success.call(options.context, model, resp, options);
                if (!model.isNew()) model.trigger("sync", model, resp, options);
            };
            var xhr = false;
            if (this.isNew()) {
                _.defer(options.success);
            } else {
                wrapError(this, options);
                xhr = this.sync("delete", this, options);
            }
            if (!wait) destroy();
            return xhr;
        },
        url: function() {
            var base = _.result(this, "urlRoot") || _.result(this.collection, "url") || urlError();
            if (this.isNew()) return base;
            var id = this.get(this.idAttribute);
            return base.replace(/[^\/]$/, "$&/") + encodeURIComponent(id);
        },
        parse: function(resp, options) {
            return resp;
        },
        clone: function() {
            return new this.constructor(this.attributes);
        },
        isNew: function() {
            return !this.has(this.idAttribute);
        },
        isValid: function(options) {
            return this._validate({}, _.extend({}, options, {
                validate: true
            }));
        },
        _validate: function(attrs, options) {
            if (!options.validate || !this.validate) return true;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validationError = this.validate(attrs, options) || null;
            if (!error) return true;
            this.trigger("invalid", this, error, _.extend(options, {
                validationError: error
            }));
            return false;
        }
    });
    var modelMethods = {
        keys: 1,
        values: 1,
        pairs: 1,
        invert: 1,
        pick: 0,
        omit: 0,
        chain: 1,
        isEmpty: 1
    };
    addUnderscoreMethods(Model, modelMethods, "attributes");
    var Collection = Backbone.Collection = function(models, options) {
        options || (options = {});
        if (options.model) this.model = options.model;
        if (options.comparator !== void 0) this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) this.reset(models, _.extend({
            silent: true
        }, options));
    };
    var setOptions = {
        add: true,
        remove: true,
        merge: true
    };
    var addOptions = {
        add: true,
        remove: false
    };
    var splice = function(array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length = insert.length;
        var i;
        for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
        for (i = 0; i < length; i++) array[i + at] = insert[i];
        for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
    };
    _.extend(Collection.prototype, Events, {
        model: Model,
        initialize: function() {},
        toJSON: function(options) {
            return this.map(function(model) {
                return model.toJSON(options);
            });
        },
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },
        add: function(models, options) {
            return this.set(models, _.extend({
                merge: false
            }, options, addOptions));
        },
        remove: function(models, options) {
            options = _.extend({}, options);
            var singular = !_.isArray(models);
            models = singular ? [ models ] : models.slice();
            var removed = this._removeModels(models, options);
            if (!options.silent && removed.length) {
                options.changes = {
                    added: [],
                    merged: [],
                    removed: removed
                };
                this.trigger("update", this, options);
            }
            return singular ? removed[0] : removed;
        },
        set: function(models, options) {
            if (models == null) return;
            options = _.extend({}, setOptions, options);
            if (options.parse && !this._isModel(models)) {
                models = this.parse(models, options) || [];
            }
            var singular = !_.isArray(models);
            models = singular ? [ models ] : models.slice();
            var at = options.at;
            if (at != null) at = +at;
            if (at > this.length) at = this.length;
            if (at < 0) at += this.length + 1;
            var set = [];
            var toAdd = [];
            var toMerge = [];
            var toRemove = [];
            var modelMap = {};
            var add = options.add;
            var merge = options.merge;
            var remove = options.remove;
            var sort = false;
            var sortable = this.comparator && at == null && options.sort !== false;
            var sortAttr = _.isString(this.comparator) ? this.comparator : null;
            var model, i;
            for (i = 0; i < models.length; i++) {
                model = models[i];
                var existing = this.get(model);
                if (existing) {
                    if (merge && model !== existing) {
                        var attrs = this._isModel(model) ? model.attributes : model;
                        if (options.parse) attrs = existing.parse(attrs, options);
                        existing.set(attrs, options);
                        toMerge.push(existing);
                        if (sortable && !sort) sort = existing.hasChanged(sortAttr);
                    }
                    if (!modelMap[existing.cid]) {
                        modelMap[existing.cid] = true;
                        set.push(existing);
                    }
                    models[i] = existing;
                } else if (add) {
                    model = models[i] = this._prepareModel(model, options);
                    if (model) {
                        toAdd.push(model);
                        this._addReference(model, options);
                        modelMap[model.cid] = true;
                        set.push(model);
                    }
                }
            }
            if (remove) {
                for (i = 0; i < this.length; i++) {
                    model = this.models[i];
                    if (!modelMap[model.cid]) toRemove.push(model);
                }
                if (toRemove.length) this._removeModels(toRemove, options);
            }
            var orderChanged = false;
            var replace = !sortable && add && remove;
            if (set.length && replace) {
                orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {
                    return m !== set[index];
                });
                this.models.length = 0;
                splice(this.models, set, 0);
                this.length = this.models.length;
            } else if (toAdd.length) {
                if (sortable) sort = true;
                splice(this.models, toAdd, at == null ? this.length : at);
                this.length = this.models.length;
            }
            if (sort) this.sort({
                silent: true
            });
            if (!options.silent) {
                for (i = 0; i < toAdd.length; i++) {
                    if (at != null) options.index = at + i;
                    model = toAdd[i];
                    model.trigger("add", model, this, options);
                }
                if (sort || orderChanged) this.trigger("sort", this, options);
                if (toAdd.length || toRemove.length || toMerge.length) {
                    options.changes = {
                        added: toAdd,
                        removed: toRemove,
                        merged: toMerge
                    };
                    this.trigger("update", this, options);
                }
            }
            return singular ? models[0] : models;
        },
        reset: function(models, options) {
            options = options ? _.clone(options) : {};
            for (var i = 0; i < this.models.length; i++) {
                this._removeReference(this.models[i], options);
            }
            options.previousModels = this.models;
            this._reset();
            models = this.add(models, _.extend({
                silent: true
            }, options));
            if (!options.silent) this.trigger("reset", this, options);
            return models;
        },
        push: function(model, options) {
            return this.add(model, _.extend({
                at: this.length
            }, options));
        },
        pop: function(options) {
            var model = this.at(this.length - 1);
            return this.remove(model, options);
        },
        unshift: function(model, options) {
            return this.add(model, _.extend({
                at: 0
            }, options));
        },
        shift: function(options) {
            var model = this.at(0);
            return this.remove(model, options);
        },
        slice: function() {
            return slice.apply(this.models, arguments);
        },
        get: function(obj) {
            if (obj == null) return void 0;
            return this._byId[obj] || this._byId[this.modelId(obj.attributes || obj)] || obj.cid && this._byId[obj.cid];
        },
        has: function(obj) {
            return this.get(obj) != null;
        },
        at: function(index) {
            if (index < 0) index += this.length;
            return this.models[index];
        },
        where: function(attrs, first) {
            return this[first ? "find" : "filter"](attrs);
        },
        findWhere: function(attrs) {
            return this.where(attrs, true);
        },
        sort: function(options) {
            var comparator = this.comparator;
            if (!comparator) throw new Error("Cannot sort a set without a comparator");
            options || (options = {});
            var length = comparator.length;
            if (_.isFunction(comparator)) comparator = _.bind(comparator, this);
            if (length === 1 || _.isString(comparator)) {
                this.models = this.sortBy(comparator);
            } else {
                this.models.sort(comparator);
            }
            if (!options.silent) this.trigger("sort", this, options);
            return this;
        },
        pluck: function(attr) {
            return this.map(attr + "");
        },
        fetch: function(options) {
            options = _.extend({
                parse: true
            }, options);
            var success = options.success;
            var collection = this;
            options.success = function(resp) {
                var method = options.reset ? "reset" : "set";
                collection[method](resp, options);
                if (success) success.call(options.context, collection, resp, options);
                collection.trigger("sync", collection, resp, options);
            };
            wrapError(this, options);
            return this.sync("read", this, options);
        },
        create: function(model, options) {
            options = options ? _.clone(options) : {};
            var wait = options.wait;
            model = this._prepareModel(model, options);
            if (!model) return false;
            if (!wait) this.add(model, options);
            var collection = this;
            var success = options.success;
            options.success = function(m, resp, callbackOpts) {
                if (wait) collection.add(m, callbackOpts);
                if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
            };
            model.save(null, options);
            return model;
        },
        parse: function(resp, options) {
            return resp;
        },
        clone: function() {
            return new this.constructor(this.models, {
                model: this.model,
                comparator: this.comparator
            });
        },
        modelId: function(attrs) {
            return attrs[this.model.prototype.idAttribute || "id"];
        },
        _reset: function() {
            this.length = 0;
            this.models = [];
            this._byId = {};
        },
        _prepareModel: function(attrs, options) {
            if (this._isModel(attrs)) {
                if (!attrs.collection) attrs.collection = this;
                return attrs;
            }
            options = options ? _.clone(options) : {};
            options.collection = this;
            var model = new this.model(attrs, options);
            if (!model.validationError) return model;
            this.trigger("invalid", this, model.validationError, options);
            return false;
        },
        _removeModels: function(models, options) {
            var removed = [];
            for (var i = 0; i < models.length; i++) {
                var model = this.get(models[i]);
                if (!model) continue;
                var index = this.indexOf(model);
                this.models.splice(index, 1);
                this.length--;
                delete this._byId[model.cid];
                var id = this.modelId(model.attributes);
                if (id != null) delete this._byId[id];
                if (!options.silent) {
                    options.index = index;
                    model.trigger("remove", model, this, options);
                }
                removed.push(model);
                this._removeReference(model, options);
            }
            return removed;
        },
        _isModel: function(model) {
            return model instanceof Model;
        },
        _addReference: function(model, options) {
            this._byId[model.cid] = model;
            var id = this.modelId(model.attributes);
            if (id != null) this._byId[id] = model;
            model.on("all", this._onModelEvent, this);
        },
        _removeReference: function(model, options) {
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes);
            if (id != null) delete this._byId[id];
            if (this === model.collection) delete model.collection;
            model.off("all", this._onModelEvent, this);
        },
        _onModelEvent: function(event, model, collection, options) {
            if (model) {
                if ((event === "add" || event === "remove") && collection !== this) return;
                if (event === "destroy") this.remove(model, options);
                if (event === "change") {
                    var prevId = this.modelId(model.previousAttributes());
                    var id = this.modelId(model.attributes);
                    if (prevId !== id) {
                        if (prevId != null) delete this._byId[prevId];
                        if (id != null) this._byId[id] = model;
                    }
                }
            }
            this.trigger.apply(this, arguments);
        }
    });
    var collectionMethods = {
        forEach: 3,
        each: 3,
        map: 3,
        collect: 3,
        reduce: 0,
        foldl: 0,
        inject: 0,
        reduceRight: 0,
        foldr: 0,
        find: 3,
        detect: 3,
        filter: 3,
        select: 3,
        reject: 3,
        every: 3,
        all: 3,
        some: 3,
        any: 3,
        include: 3,
        includes: 3,
        contains: 3,
        invoke: 0,
        max: 3,
        min: 3,
        toArray: 1,
        size: 1,
        first: 3,
        head: 3,
        take: 3,
        initial: 3,
        rest: 3,
        tail: 3,
        drop: 3,
        last: 3,
        without: 0,
        difference: 0,
        indexOf: 3,
        shuffle: 1,
        lastIndexOf: 3,
        isEmpty: 1,
        chain: 1,
        sample: 3,
        partition: 3,
        groupBy: 3,
        countBy: 3,
        sortBy: 3,
        indexBy: 3,
        findIndex: 3,
        findLastIndex: 3
    };
    addUnderscoreMethods(Collection, collectionMethods, "models");
    var View = Backbone.View = function(options) {
        this.cid = _.uniqueId("view");
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
    };
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
    var viewOptions = [ "model", "collection", "el", "id", "attributes", "className", "tagName", "events" ];
    _.extend(View.prototype, Events, {
        tagName: "div",
        $: function(selector) {
            return this.$el.find(selector);
        },
        initialize: function() {},
        render: function() {
            return this;
        },
        remove: function() {
            this._removeElement();
            this.stopListening();
            return this;
        },
        _removeElement: function() {
            this.$el.remove();
        },
        setElement: function(element) {
            this.undelegateEvents();
            this._setElement(element);
            this.delegateEvents();
            return this;
        },
        _setElement: function(el) {
            this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
            this.el = this.$el[0];
        },
        delegateEvents: function(events) {
            events || (events = _.result(this, "events"));
            if (!events) return this;
            this.undelegateEvents();
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) method = this[method];
                if (!method) continue;
                var match = key.match(delegateEventSplitter);
                this.delegate(match[1], match[2], _.bind(method, this));
            }
            return this;
        },
        delegate: function(eventName, selector, listener) {
            this.$el.on(eventName + ".delegateEvents" + this.cid, selector, listener);
            return this;
        },
        undelegateEvents: function() {
            if (this.$el) this.$el.off(".delegateEvents" + this.cid);
            return this;
        },
        undelegate: function(eventName, selector, listener) {
            this.$el.off(eventName + ".delegateEvents" + this.cid, selector, listener);
            return this;
        },
        _createElement: function(tagName) {
            return document.createElement(tagName);
        },
        _ensureElement: function() {
            if (!this.el) {
                var attrs = _.extend({}, _.result(this, "attributes"));
                if (this.id) attrs.id = _.result(this, "id");
                if (this.className) attrs["class"] = _.result(this, "className");
                this.setElement(this._createElement(_.result(this, "tagName")));
                this._setAttributes(attrs);
            } else {
                this.setElement(_.result(this, "el"));
            }
        },
        _setAttributes: function(attributes) {
            this.$el.attr(attributes);
        }
    });
    Backbone.sync = function(method, model, options) {
        var type = methodMap[method];
        _.defaults(options || (options = {}), {
            emulateHTTP: Backbone.emulateHTTP,
            emulateJSON: Backbone.emulateJSON
        });
        var params = {
            type: type,
            dataType: "json"
        };
        if (!options.url) {
            params.url = _.result(model, "url") || urlError();
        }
        if (options.data == null && model && (method === "create" || method === "update" || method === "patch")) {
            params.contentType = "application/json";
            params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        if (options.emulateJSON) {
            params.contentType = "application/x-www-form-urlencoded";
            params.data = params.data ? {
                model: params.data
            } : {};
        }
        if (options.emulateHTTP && (type === "PUT" || type === "DELETE" || type === "PATCH")) {
            params.type = "POST";
            if (options.emulateJSON) params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function(xhr) {
                xhr.setRequestHeader("X-HTTP-Method-Override", type);
                if (beforeSend) return beforeSend.apply(this, arguments);
            };
        }
        if (params.type !== "GET" && !options.emulateJSON) {
            params.processData = false;
        }
        var error = options.error;
        options.error = function(xhr, textStatus, errorThrown) {
            options.textStatus = textStatus;
            options.errorThrown = errorThrown;
            if (error) error.call(options.context, xhr, textStatus, errorThrown);
        };
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger("request", model, xhr, options);
        return xhr;
    };
    var methodMap = {
        create: "POST",
        update: "PUT",
        patch: "PATCH",
        "delete": "DELETE",
        read: "GET"
    };
    Backbone.ajax = function() {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
    };
    var Router = Backbone.Router = function(options) {
        options || (options = {});
        if (options.routes) this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    };
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    _.extend(Router.prototype, Events, {
        initialize: function() {},
        route: function(route, name, callback) {
            if (!_.isRegExp(route)) route = this._routeToRegExp(route);
            if (_.isFunction(name)) {
                callback = name;
                name = "";
            }
            if (!callback) callback = this[name];
            var router = this;
            Backbone.history.route(route, function(fragment) {
                var args = router._extractParameters(route, fragment);
                if (router.execute(callback, args, name) !== false) {
                    router.trigger.apply(router, [ "route:" + name ].concat(args));
                    router.trigger("route", name, args);
                    Backbone.history.trigger("route", router, name, args);
                }
            });
            return this;
        },
        execute: function(callback, args, name) {
            if (callback) callback.apply(this, args);
        },
        navigate: function(fragment, options) {
            Backbone.history.navigate(fragment, options);
            return this;
        },
        _bindRoutes: function() {
            if (!this.routes) return;
            this.routes = _.result(this, "routes");
            var route, routes = _.keys(this.routes);
            while ((route = routes.pop()) != null) {
                this.route(route, this.routes[route]);
            }
        },
        _routeToRegExp: function(route) {
            route = route.replace(escapeRegExp, "\\$&").replace(optionalParam, "(?:$1)?").replace(namedParam, function(match, optional) {
                return optional ? match : "([^/?]+)";
            }).replace(splatParam, "([^?]*?)");
            return new RegExp("^" + route + "(?:\\?([\\s\\S]*))?$");
        },
        _extractParameters: function(route, fragment) {
            var params = route.exec(fragment).slice(1);
            return _.map(params, function(param, i) {
                if (i === params.length - 1) return param || null;
                return param ? decodeURIComponent(param) : null;
            });
        }
    });
    var History = Backbone.History = function() {
        this.handlers = [];
        this.checkUrl = _.bind(this.checkUrl, this);
        if (typeof window !== "undefined") {
            this.location = window.location;
            this.history = window.history;
        }
    };
    var routeStripper = /^[#\/]|\s+$/g;
    var rootStripper = /^\/+|\/+$/g;
    var pathStripper = /#.*$/;
    History.started = false;
    _.extend(History.prototype, Events, {
        interval: 50,
        atRoot: function() {
            var path = this.location.pathname.replace(/[^\/]$/, "$&/");
            return path === this.root && !this.getSearch();
        },
        matchRoot: function() {
            var path = this.decodeFragment(this.location.pathname);
            var rootPath = path.slice(0, this.root.length - 1) + "/";
            return rootPath === this.root;
        },
        decodeFragment: function(fragment) {
            return decodeURI(fragment.replace(/%25/g, "%2525"));
        },
        getSearch: function() {
            var match = this.location.href.replace(/#.*/, "").match(/\?.+/);
            return match ? match[0] : "";
        },
        getHash: function(window) {
            var match = (window || this).location.href.match(/#(.*)$/);
            return match ? match[1] : "";
        },
        getPath: function() {
            var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
            return path.charAt(0) === "/" ? path.slice(1) : path;
        },
        getFragment: function(fragment) {
            if (fragment == null) {
                if (this._usePushState || !this._wantsHashChange) {
                    fragment = this.getPath();
                } else {
                    fragment = this.getHash();
                }
            }
            return fragment.replace(routeStripper, "");
        },
        start: function(options) {
            if (History.started) throw new Error("Backbone.history has already been started");
            History.started = true;
            this.options = _.extend({
                root: "/"
            }, this.options, options);
            this.root = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false;
            this._hasHashChange = "onhashchange" in window && (document.documentMode === void 0 || document.documentMode > 7);
            this._useHashChange = this._wantsHashChange && this._hasHashChange;
            this._wantsPushState = !!this.options.pushState;
            this._hasPushState = !!(this.history && this.history.pushState);
            this._usePushState = this._wantsPushState && this._hasPushState;
            this.fragment = this.getFragment();
            this.root = ("/" + this.root + "/").replace(rootStripper, "/");
            if (this._wantsHashChange && this._wantsPushState) {
                if (!this._hasPushState && !this.atRoot()) {
                    var rootPath = this.root.slice(0, -1) || "/";
                    this.location.replace(rootPath + "#" + this.getPath());
                    return true;
                } else if (this._hasPushState && this.atRoot()) {
                    this.navigate(this.getHash(), {
                        replace: true
                    });
                }
            }
            if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
                this.iframe = document.createElement("iframe");
                this.iframe.src = "javascript:0";
                this.iframe.style.display = "none";
                this.iframe.tabIndex = -1;
                var body = document.body;
                var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
                iWindow.document.open();
                iWindow.document.close();
                iWindow.location.hash = "#" + this.fragment;
            }
            var addEventListener = window.addEventListener || function(eventName, listener) {
                return attachEvent("on" + eventName, listener);
            };
            if (this._usePushState) {
                addEventListener("popstate", this.checkUrl, false);
            } else if (this._useHashChange && !this.iframe) {
                addEventListener("hashchange", this.checkUrl, false);
            } else if (this._wantsHashChange) {
                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            }
            if (!this.options.silent) return this.loadUrl();
        },
        stop: function() {
            var removeEventListener = window.removeEventListener || function(eventName, listener) {
                return detachEvent("on" + eventName, listener);
            };
            if (this._usePushState) {
                removeEventListener("popstate", this.checkUrl, false);
            } else if (this._useHashChange && !this.iframe) {
                removeEventListener("hashchange", this.checkUrl, false);
            }
            if (this.iframe) {
                document.body.removeChild(this.iframe);
                this.iframe = null;
            }
            if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
            History.started = false;
        },
        route: function(route, callback) {
            this.handlers.unshift({
                route: route,
                callback: callback
            });
        },
        checkUrl: function(e) {
            var current = this.getFragment();
            if (current === this.fragment && this.iframe) {
                current = this.getHash(this.iframe.contentWindow);
            }
            if (current === this.fragment) return false;
            if (this.iframe) this.navigate(current);
            this.loadUrl();
        },
        loadUrl: function(fragment) {
            if (!this.matchRoot()) return false;
            fragment = this.fragment = this.getFragment(fragment);
            return _.some(this.handlers, function(handler) {
                if (handler.route.test(fragment)) {
                    handler.callback(fragment);
                    return true;
                }
            });
        },
        navigate: function(fragment, options) {
            if (!History.started) return false;
            if (!options || options === true) options = {
                trigger: !!options
            };
            fragment = this.getFragment(fragment || "");
            var rootPath = this.root;
            if (fragment === "" || fragment.charAt(0) === "?") {
                rootPath = rootPath.slice(0, -1) || "/";
            }
            var url = rootPath + fragment;
            fragment = this.decodeFragment(fragment.replace(pathStripper, ""));
            if (this.fragment === fragment) return;
            this.fragment = fragment;
            if (this._usePushState) {
                this.history[options.replace ? "replaceState" : "pushState"]({}, document.title, url);
            } else if (this._wantsHashChange) {
                this._updateHash(this.location, fragment, options.replace);
                if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
                    var iWindow = this.iframe.contentWindow;
                    if (!options.replace) {
                        iWindow.document.open();
                        iWindow.document.close();
                    }
                    this._updateHash(iWindow.location, fragment, options.replace);
                }
            } else {
                return this.location.assign(url);
            }
            if (options.trigger) return this.loadUrl(fragment);
        },
        _updateHash: function(location, fragment, replace) {
            if (replace) {
                var href = location.href.replace(/(javascript:|#).*$/, "");
                location.replace(href + "#" + fragment);
            } else {
                location.hash = "#" + fragment;
            }
        }
    });
    Backbone.history = new History();
    var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _.has(protoProps, "constructor")) {
            child = protoProps.constructor;
        } else {
            child = function() {
                return parent.apply(this, arguments);
            };
        }
        _.extend(child, parent, staticProps);
        child.prototype = _.create(parent.prototype, protoProps);
        child.prototype.constructor = child;
        child.__super__ = parent.prototype;
        return child;
    };
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
    var urlError = function() {
        throw new Error('A "url" property or function must be specified');
    };
    var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
            if (error) error.call(options.context, model, resp, options);
            model.trigger("error", model, resp, options);
        };
    };
    return Backbone;
});

(function() {
    var undefined;
    var arrayPool = [], objectPool = [];
    var idCounter = 0;
    var indicatorObject = {};
    var keyPrefix = +new Date() + "";
    var largeArraySize = 75;
    var maxPoolSize = 40;
    var whitespace = " 	\x0B\f\ufeff" + "\n\r\u2028\u2029" + "";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reFuncName = /^\s*function[ \n\r\t]+\w/;
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
    var reNoMatch = /($^)/;
    var reThis = /\bthis\b/;
    var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
    var contextProps = [ "Array", "Boolean", "Date", "Error", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
    var shadowedProps = [ "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf" ];
    var templateCounter = 0;
    var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", errorClass = "[object Error]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
    var cloneableClasses = {};
    cloneableClasses[funcClass] = false;
    cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
    var debounceOptions = {
        leading: false,
        maxWait: 0,
        trailing: false
    };
    var descriptor = {
        configurable: false,
        enumerable: false,
        value: null,
        writable: false
    };
    var iteratorData = {
        args: "",
        array: null,
        bottom: "",
        firstArg: "",
        init: "",
        keys: null,
        loop: "",
        shadowedProps: null,
        support: null,
        top: "",
        useHas: false
    };
    var objectTypes = {
        "boolean": false,
        "function": true,
        object: true,
        number: false,
        string: false,
        undefined: false
    };
    var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    };
    var root = objectTypes[typeof window] && window || this;
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    var freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
    }
    function baseIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == "boolean" || value == null) {
            return cache[value] ? 0 : -1;
        }
        if (type != "number" && type != "string") {
            type = "object";
        }
        var key = type == "number" ? value : keyPrefix + value;
        cache = (cache = cache[type]) && cache[key];
        return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
    }
    function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if (type == "boolean" || value == null) {
            cache[value] = true;
        } else {
            if (type != "number" && type != "string") {
                type = "object";
            }
            var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
            if (type == "object") {
                (typeCache[key] || (typeCache[key] = [])).push(value);
            } else {
                typeCache[key] = true;
            }
        }
    }
    function charAtCallback(value) {
        return value.charCodeAt(0);
    }
    function compareAscending(a, b) {
        var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
        while (++index < length) {
            var value = ac[index], other = bc[index];
            if (value !== other) {
                if (value > other || typeof value == "undefined") {
                    return 1;
                }
                if (value < other || typeof other == "undefined") {
                    return -1;
                }
            }
        }
        return a.index - b.index;
    }
    function createCache(array) {
        var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
        if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
            return false;
        }
        var cache = getObject();
        cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
            result.push(array[index]);
        }
        return result;
    }
    function escapeStringChar(match) {
        return "\\" + stringEscapes[match];
    }
    function getArray() {
        return arrayPool.pop() || [];
    }
    function getObject() {
        return objectPool.pop() || {
            array: null,
            cache: null,
            criteria: null,
            "false": false,
            index: 0,
            "null": false,
            number: null,
            object: null,
            push: null,
            string: null,
            "true": false,
            undefined: false,
            value: null
        };
    }
    function isNode(value) {
        return typeof value.toString != "function" && typeof (value + "") == "string";
    }
    function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
            arrayPool.push(array);
        }
    }
    function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
            releaseObject(cache);
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
            objectPool.push(object);
        }
    }
    function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == "undefined") {
            end = array ? array.length : 0;
        }
        var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
        while (++index < length) {
            result[index] = array[start + index];
        }
        return result;
    }
    function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayRef = [];
        var errorProto = Error.prototype, objectProto = Object.prototype, stringProto = String.prototype;
        var oldDash = context._;
        var toString = objectProto.toString;
        var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
        var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
        var defineProperty = function() {
            try {
                var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
            } catch (e) {}
            return result;
        }();
        var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp;
        ctorByClass[stringClass] = String;
        var nonEnumProps = {};
        nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
            constructor: true,
            toLocaleString: true,
            toString: true,
            valueOf: true
        };
        nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
            constructor: true,
            toString: true,
            valueOf: true
        };
        nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
            constructor: true,
            toString: true
        };
        nonEnumProps[objectClass] = {
            constructor: true
        };
        (function() {
            var length = shadowedProps.length;
            while (length--) {
                var key = shadowedProps[length];
                for (var className in nonEnumProps) {
                    if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
                        nonEnumProps[className][key] = false;
                    }
                }
            }
        })();
        function lodash(value) {
            return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll;
            this.__wrapped__ = value;
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        (function() {
            var ctor = function() {
                this.x = 1;
            }, object = {
                "0": 1,
                length: 1
            }, props = [];
            ctor.prototype = {
                valueOf: 1,
                y: 1
            };
            for (var key in new ctor()) {
                props.push(key);
            }
            for (key in arguments) {}
            support.argsClass = toString.call(arguments) == argsClass;
            support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);
            support.enumErrorProps = propertyIsEnumerable.call(errorProto, "message") || propertyIsEnumerable.call(errorProto, "name");
            support.enumPrototypes = propertyIsEnumerable.call(ctor, "prototype");
            support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
            support.funcNames = typeof Function.name == "string";
            support.nonEnumArgs = key != 0;
            support.nonEnumShadows = !/valueOf/.test(props);
            support.ownLast = props[0] != "x";
            support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
            support.unindexedChars = "x"[0] + Object("x")[0] != "xx";
            try {
                support.nodeClass = !(toString.call(document) == objectClass && !({
                    toString: 0
                } + ""));
            } catch (e) {
                support.nodeClass = true;
            }
        })(1);
        lodash.templateSettings = {
            escape: /<%-([\s\S]+?)%>/g,
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: reInterpolate,
            variable: "",
            imports: {
                _: lodash
            }
        };
        var iteratorTemplate = function(obj) {
            var __p = "var index, iterable = " + obj.firstArg + ", result = " + obj.init + ";\nif (!iterable) return result;\n" + obj.top + ";";
            if (obj.array) {
                __p += "\nvar length = iterable.length; index = -1;\nif (" + obj.array + ") {  ";
                if (support.unindexedChars) {
                    __p += "\n  if (isString(iterable)) {\n    iterable = iterable.split('')\n  }  ";
                }
                __p += "\n  while (++index < length) {\n    " + obj.loop + ";\n  }\n}\nelse {  ";
            } else if (support.nonEnumArgs) {
                __p += "\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += '';\n      " + obj.loop + ";\n    }\n  } else {  ";
            }
            if (support.enumPrototypes) {
                __p += "\n  var skipProto = typeof iterable == 'function';\n  ";
            }
            if (support.enumErrorProps) {
                __p += "\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ";
            }
            var conditions = [];
            if (support.enumPrototypes) {
                conditions.push('!(skipProto && index == "prototype")');
            }
            if (support.enumErrorProps) {
                conditions.push('!(skipErrorProps && (index == "message" || index == "name"))');
            }
            if (obj.useHas && obj.keys) {
                __p += "\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n";
                if (conditions.length) {
                    __p += "    if (" + conditions.join(" && ") + ") {\n  ";
                }
                __p += obj.loop + ";    ";
                if (conditions.length) {
                    __p += "\n    }";
                }
                __p += "\n  }  ";
            } else {
                __p += "\n  for (index in iterable) {\n";
                if (obj.useHas) {
                    conditions.push("hasOwnProperty.call(iterable, index)");
                }
                if (conditions.length) {
                    __p += "    if (" + conditions.join(" && ") + ") {\n  ";
                }
                __p += obj.loop + ";    ";
                if (conditions.length) {
                    __p += "\n    }";
                }
                __p += "\n  }    ";
                if (support.nonEnumShadows) {
                    __p += "\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ";
                    for (k = 0; k < 7; k++) {
                        __p += "\n    index = '" + obj.shadowedProps[k] + "';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))";
                        if (!obj.useHas) {
                            __p += " || (!nonEnum[index] && iterable[index] !== objectProto[index])";
                        }
                        __p += ") {\n      " + obj.loop + ";\n    }      ";
                    }
                    __p += "\n  }    ";
                }
            }
            if (obj.array || support.nonEnumArgs) {
                __p += "\n}";
            }
            __p += obj.bottom + ";\nreturn result";
            return __p;
        };
        function baseBind(bindData) {
            var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
            function bound() {
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (this instanceof bound) {
                    var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisArg, args || arguments);
            }
            setBindData(bound, bindData);
            return bound;
        }
        function baseClone(value, isDeep, callback, stackA, stackB) {
            if (callback) {
                var result = callback(value);
                if (typeof result != "undefined") {
                    return result;
                }
            }
            var isObj = isObject(value);
            if (isObj) {
                var className = toString.call(value);
                if (!cloneableClasses[className] || !support.nodeClass && isNode(value)) {
                    return value;
                }
                var ctor = ctorByClass[className];
                switch (className) {
                  case boolClass:
                  case dateClass:
                    return new ctor(+value);

                  case numberClass:
                  case stringClass:
                    return new ctor(value);

                  case regexpClass:
                    result = ctor(value.source, reFlags.exec(value));
                    result.lastIndex = value.lastIndex;
                    return result;
                }
            } else {
                return value;
            }
            var isArr = isArray(value);
            if (isDeep) {
                var initedStack = !stackA;
                stackA || (stackA = getArray());
                stackB || (stackB = getArray());
                var length = stackA.length;
                while (length--) {
                    if (stackA[length] == value) {
                        return stackB[length];
                    }
                }
                result = isArr ? ctor(value.length) : {};
            } else {
                result = isArr ? slice(value) : assign({}, value);
            }
            if (isArr) {
                if (hasOwnProperty.call(value, "index")) {
                    result.index = value.index;
                }
                if (hasOwnProperty.call(value, "input")) {
                    result.input = value.input;
                }
            }
            if (!isDeep) {
                return result;
            }
            stackA.push(value);
            stackB.push(result);
            (isArr ? baseEach : forOwn)(value, function(objValue, key) {
                result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
            });
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB);
            }
            return result;
        }
        function baseCreate(prototype, properties) {
            return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        if (!nativeCreate) {
            baseCreate = function() {
                function Object() {}
                return function(prototype) {
                    if (isObject(prototype)) {
                        Object.prototype = prototype;
                        var result = new Object();
                        Object.prototype = null;
                    }
                    return result || context.Object();
                };
            }();
        }
        function baseCreateCallback(func, thisArg, argCount) {
            if (typeof func != "function") {
                return identity;
            }
            if (typeof thisArg == "undefined" || !("prototype" in func)) {
                return func;
            }
            var bindData = func.__bindData__;
            if (typeof bindData == "undefined") {
                if (support.funcNames) {
                    bindData = !func.name;
                }
                bindData = bindData || !support.funcDecomp;
                if (!bindData) {
                    var source = fnToString.call(func);
                    if (!support.funcNames) {
                        bindData = !reFuncName.test(source);
                    }
                    if (!bindData) {
                        bindData = reThis.test(source);
                        setBindData(func, bindData);
                    }
                }
            }
            if (bindData === false || bindData !== true && bindData[1] & 1) {
                return func;
            }
            switch (argCount) {
              case 1:
                return function(value) {
                    return func.call(thisArg, value);
                };

              case 2:
                return function(a, b) {
                    return func.call(thisArg, a, b);
                };

              case 3:
                return function(value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };

              case 4:
                return function(accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };
            }
            return bind(func, thisArg);
        }
        function baseCreateWrapper(bindData) {
            var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
            function bound() {
                var thisBinding = isBind ? thisArg : this;
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (partialRightArgs || isCurry) {
                    args || (args = slice(arguments));
                    if (partialRightArgs) {
                        push.apply(args, partialRightArgs);
                    }
                    if (isCurry && args.length < arity) {
                        bitmask |= 16 & ~32;
                        return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
                    }
                }
                args || (args = arguments);
                if (isBindKey) {
                    func = thisBinding[key];
                }
                if (this instanceof bound) {
                    thisBinding = baseCreate(func.prototype);
                    var result = func.apply(thisBinding, args);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisBinding, args);
            }
            setBindData(bound, bindData);
            return bound;
        }
        function baseDifference(array, values) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
            if (isLarge) {
                var cache = createCache(values);
                if (cache) {
                    indexOf = cacheIndexOf;
                    values = cache;
                } else {
                    isLarge = false;
                }
            }
            while (++index < length) {
                var value = array[index];
                if (indexOf(values, value) < 0) {
                    result.push(value);
                }
            }
            if (isLarge) {
                releaseObject(values);
            }
            return result;
        }
        function baseFlatten(array, isShallow, isStrict, fromIndex) {
            var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                    if (!isShallow) {
                        value = baseFlatten(value, isShallow, isStrict);
                    }
                    var valIndex = -1, valLength = value.length, resIndex = result.length;
                    result.length += valLength;
                    while (++valIndex < valLength) {
                        result[resIndex++] = value[valIndex];
                    }
                } else if (!isStrict) {
                    result.push(value);
                }
            }
            return result;
        }
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            if (callback) {
                var result = callback(a, b);
                if (typeof result != "undefined") {
                    return !!result;
                }
            }
            if (a === b) {
                return a !== 0 || 1 / a == 1 / b;
            }
            var type = typeof a, otherType = typeof b;
            if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                return false;
            }
            if (a == null || b == null) {
                return a === b;
            }
            var className = toString.call(a), otherClass = toString.call(b);
            if (className == argsClass) {
                className = objectClass;
            }
            if (otherClass == argsClass) {
                otherClass = objectClass;
            }
            if (className != otherClass) {
                return false;
            }
            switch (className) {
              case boolClass:
              case dateClass:
                return +a == +b;

              case numberClass:
                return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

              case regexpClass:
              case stringClass:
                return a == String(b);
            }
            var isArr = className == arrayClass;
            if (!isArr) {
                var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                if (aWrapped || bWrapped) {
                    return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                }
                if (className != objectClass || !support.nodeClass && (isNode(a) || isNode(b))) {
                    return false;
                }
                var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor, ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
                if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
                    return false;
                }
            }
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == a) {
                    return stackB[length] == b;
                }
            }
            var size = 0;
            result = true;
            stackA.push(a);
            stackB.push(b);
            if (isArr) {
                length = a.length;
                size = b.length;
                result = size == length;
                if (result || isWhere) {
                    while (size--) {
                        var index = length, value = b[size];
                        if (isWhere) {
                            while (index--) {
                                if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                    break;
                                }
                            }
                        } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                            break;
                        }
                    }
                }
            } else {
                forIn(b, function(value, key, b) {
                    if (hasOwnProperty.call(b, key)) {
                        size++;
                        return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                    }
                });
                if (result && !isWhere) {
                    forIn(a, function(value, key, a) {
                        if (hasOwnProperty.call(a, key)) {
                            return result = --size > -1;
                        }
                    });
                }
            }
            stackA.pop();
            stackB.pop();
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB);
            }
            return result;
        }
        function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                var found, isArr, result = source, value = object[key];
                if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                    var stackLength = stackA.length;
                    while (stackLength--) {
                        if (found = stackA[stackLength] == source) {
                            value = stackB[stackLength];
                            break;
                        }
                    }
                    if (!found) {
                        var isShallow;
                        if (callback) {
                            result = callback(value, source);
                            if (isShallow = typeof result != "undefined") {
                                value = result;
                            }
                        }
                        if (!isShallow) {
                            value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                        }
                        stackA.push(source);
                        stackB.push(value);
                        if (!isShallow) {
                            baseMerge(value, source, callback, stackA, stackB);
                        }
                    }
                } else {
                    if (callback) {
                        result = callback(value, source);
                        if (typeof result == "undefined") {
                            result = source;
                        }
                    }
                    if (typeof result != "undefined") {
                        value = result;
                    }
                }
                object[key] = value;
            });
        }
        function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseUniq(array, isSorted, callback) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
            var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
            if (isLarge) {
                var cache = createCache(seen);
                indexOf = cacheIndexOf;
                seen = cache;
            }
            while (++index < length) {
                var value = array[index], computed = callback ? callback(value, index, array) : value;
                if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                    if (callback || isLarge) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
            }
            if (isLarge) {
                releaseArray(seen.array);
                releaseObject(seen);
            } else if (callback) {
                releaseArray(seen);
            }
            return result;
        }
        function createAggregator(setter) {
            return function(collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg, 3);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, callback(value, index, collection), collection);
                    }
                } else {
                    baseEach(collection, function(value, key, collection) {
                        setter(result, value, callback(value, key, collection), collection);
                    });
                }
                return result;
            };
        }
        function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
            if (!isBindKey && !isFunction(func)) {
                throw new TypeError();
            }
            if (isPartial && !partialArgs.length) {
                bitmask &= ~16;
                isPartial = partialArgs = false;
            }
            if (isPartialRight && !partialRightArgs.length) {
                bitmask &= ~32;
                isPartialRight = partialRightArgs = false;
            }
            var bindData = func && func.__bindData__;
            if (bindData && bindData !== true) {
                bindData = slice(bindData);
                if (bindData[2]) {
                    bindData[2] = slice(bindData[2]);
                }
                if (bindData[3]) {
                    bindData[3] = slice(bindData[3]);
                }
                if (isBind && !(bindData[1] & 1)) {
                    bindData[4] = thisArg;
                }
                if (!isBind && bindData[1] & 1) {
                    bitmask |= 8;
                }
                if (isCurry && !(bindData[1] & 4)) {
                    bindData[5] = arity;
                }
                if (isPartial) {
                    push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                }
                if (isPartialRight) {
                    unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                }
                bindData[1] |= bitmask;
                return createWrapper.apply(null, bindData);
            }
            var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
            return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
        }
        function createIterator() {
            iteratorData.shadowedProps = shadowedProps;
            iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = "";
            iteratorData.init = "iterable";
            iteratorData.useHas = true;
            for (var object, index = 0; object = arguments[index]; index++) {
                for (var key in object) {
                    iteratorData[key] = object[key];
                }
            }
            var args = iteratorData.args;
            iteratorData.firstArg = /^[^,]+/.exec(args)[0];
            var factory = Function("baseCreateCallback, errorClass, errorProto, hasOwnProperty, " + "indicatorObject, isArguments, isArray, isString, keys, objectProto, " + "objectTypes, nonEnumProps, stringClass, stringProto, toString", "return function(" + args + ") {\n" + iteratorTemplate(iteratorData) + "\n}");
            return factory(baseCreateCallback, errorClass, errorProto, hasOwnProperty, indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString);
        }
        function escapeHtmlChar(match) {
            return htmlEscapes[match];
        }
        function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result;
        }
        function isNative(value) {
            return typeof value == "function" && reNative.test(value);
        }
        var setBindData = !defineProperty ? noop : function(func, value) {
            descriptor.value = value;
            defineProperty(func, "__bindData__", descriptor);
        };
        function shimIsPlainObject(value) {
            var ctor, result;
            if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
            isFunction(ctor) && !(ctor instanceof ctor)) || !support.argsClass && isArguments(value) || !support.nodeClass && isNode(value)) {
                return false;
            }
            if (support.ownLast) {
                forIn(value, function(value, key, object) {
                    result = hasOwnProperty.call(object, key);
                    return false;
                });
                return result !== false;
            }
            forIn(value, function(value, key) {
                result = key;
            });
            return typeof result == "undefined" || hasOwnProperty.call(value, result);
        }
        function unescapeHtmlChar(match) {
            return htmlUnescapes[match];
        }
        function isArguments(value) {
            return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
        }
        if (!support.argsClass) {
            isArguments = function(value) {
                return value && typeof value == "object" && typeof value.length == "number" && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee") || false;
            };
        }
        var isArray = nativeIsArray || function(value) {
            return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
        };
        var shimKeys = createIterator({
            args: "object",
            init: "[]",
            top: "if (!(objectTypes[typeof object])) return result",
            loop: "result.push(index)"
        });
        var keys = !nativeKeys ? shimKeys : function(object) {
            if (!isObject(object)) {
                return [];
            }
            if (support.enumPrototypes && typeof object == "function" || support.nonEnumArgs && object.length && isArguments(object)) {
                return shimKeys(object);
            }
            return nativeKeys(object);
        };
        var eachIteratorOptions = {
            args: "collection, callback, thisArg",
            top: "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
            array: "typeof length == 'number'",
            keys: keys,
            loop: "if (callback(iterable[index], index, collection) === false) return result"
        };
        var defaultsIteratorOptions = {
            args: "object, source, guard",
            top: "var args = arguments,\n" + "    argsIndex = 0,\n" + "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" + "while (++argsIndex < argsLength) {\n" + "  iterable = args[argsIndex];\n" + "  if (iterable && objectTypes[typeof iterable]) {",
            keys: keys,
            loop: "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
            bottom: "  }\n}"
        };
        var forOwnIteratorOptions = {
            top: "if (!objectTypes[typeof iterable]) return result;\n" + eachIteratorOptions.top,
            array: false
        };
        var htmlEscapes = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        };
        var htmlUnescapes = invert(htmlEscapes);
        var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
        var baseEach = createIterator(eachIteratorOptions);
        var assign = createIterator(defaultsIteratorOptions, {
            top: defaultsIteratorOptions.top.replace(";", ";\n" + "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" + "  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n" + "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" + "  callback = args[--argsLength];\n" + "}"),
            loop: "result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]"
        });
        function clone(value, isDeep, callback, thisArg) {
            if (typeof isDeep != "boolean" && isDeep != null) {
                thisArg = callback;
                callback = isDeep;
                isDeep = false;
            }
            return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
        }
        function cloneDeep(value, callback, thisArg) {
            return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
        }
        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? assign(result, properties) : result;
        }
        var defaults = createIterator(defaultsIteratorOptions);
        function findKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function(value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        function findLastKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwnRight(object, function(value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
            useHas: false
        });
        function forInRight(object, callback, thisArg) {
            var pairs = [];
            forIn(object, function(value, key) {
                pairs.push(key, value);
            });
            var length = pairs.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(pairs[length--], pairs[length], object) === false) {
                    break;
                }
            }
            return object;
        }
        var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
        function forOwnRight(object, callback, thisArg) {
            var props = keys(object), length = props.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                var key = props[length];
                if (callback(object[key], key, object) === false) {
                    break;
                }
            }
            return object;
        }
        function functions(object) {
            var result = [];
            forIn(object, function(value, key) {
                if (isFunction(value)) {
                    result.push(key);
                }
            });
            return result.sort();
        }
        function has(object, key) {
            return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object) {
            var index = -1, props = keys(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index];
                result[object[key]] = key;
            }
            return result;
        }
        function isBoolean(value) {
            return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
        }
        function isDate(value) {
            return value && typeof value == "object" && toString.call(value) == dateClass || false;
        }
        function isElement(value) {
            return value && value.nodeType === 1 || false;
        }
        function isEmpty(value) {
            var result = true;
            if (!value) {
                return result;
            }
            var className = toString.call(value), length = value.length;
            if (className == arrayClass || className == stringClass || (support.argsClass ? className == argsClass : isArguments(value)) || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                return !length;
            }
            forOwn(value, function() {
                return result = false;
            });
            return result;
        }
        function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
        }
        function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
            return typeof value == "function";
        }
        if (isFunction(/x/)) {
            isFunction = function(value) {
                return typeof value == "function" && toString.call(value) == funcClass;
            };
        }
        function isObject(value) {
            return !!(value && objectTypes[typeof value]);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNull(value) {
            return value === null;
        }
        function isNumber(value) {
            return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
            if (!(value && toString.call(value) == objectClass) || !support.argsClass && isArguments(value)) {
                return false;
            }
            var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
            return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
        }
        function isString(value) {
            return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
        }
        function isUndefined(value) {
            return typeof value == "undefined";
        }
        function mapValues(object, callback, thisArg) {
            var result = {};
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function(value, key, object) {
                result[key] = callback(value, key, object);
            });
            return result;
        }
        function merge(object) {
            var args = arguments, length = 2;
            if (!isObject(object)) {
                return object;
            }
            if (typeof args[2] != "number") {
                length = args.length;
            }
            if (length > 3 && typeof args[length - 2] == "function") {
                var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
            } else if (length > 2 && typeof args[length - 1] == "function") {
                callback = args[--length];
            }
            var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
            while (++index < length) {
                baseMerge(object, sources[index], callback, stackA, stackB);
            }
            releaseArray(stackA);
            releaseArray(stackB);
            return object;
        }
        function omit(object, callback, thisArg) {
            var result = {};
            if (typeof callback != "function") {
                var props = [];
                forIn(object, function(value, key) {
                    props.push(key);
                });
                props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                var index = -1, length = props.length;
                while (++index < length) {
                    var key = props[index];
                    result[key] = object[key];
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function(value, key, object) {
                    if (!callback(value, key, object)) {
                        result[key] = value;
                    }
                });
            }
            return result;
        }
        function pairs(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                var key = props[index];
                result[index] = [ key, object[key] ];
            }
            return result;
        }
        function pick(object, callback, thisArg) {
            var result = {};
            if (typeof callback != "function") {
                var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                while (++index < length) {
                    var key = props[index];
                    if (key in object) {
                        result[key] = object[key];
                    }
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function(value, key, object) {
                    if (callback(value, key, object)) {
                        result[key] = value;
                    }
                });
            }
            return result;
        }
        function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            if (accumulator == null) {
                if (isArr) {
                    accumulator = [];
                } else {
                    var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                    accumulator = baseCreate(proto);
                }
            }
            if (callback) {
                callback = lodash.createCallback(callback, thisArg, 4);
                (isArr ? baseEach : forOwn)(object, function(value, index, object) {
                    return callback(accumulator, value, index, object);
                });
            }
            return accumulator;
        }
        function values(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                result[index] = object[props[index]];
            }
            return result;
        }
        function at(collection) {
            var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
            if (support.unindexedChars && isString(collection)) {
                collection = collection.split("");
            }
            while (++index < length) {
                result[index] = collection[props[index]];
            }
            return result;
        }
        function contains(collection, target, fromIndex) {
            var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
            if (isArray(collection)) {
                result = indexOf(collection, target, fromIndex) > -1;
            } else if (typeof length == "number") {
                result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
            } else {
                baseEach(collection, function(value) {
                    if (++index >= fromIndex) {
                        return !(result = value === target);
                    }
                });
            }
            return result;
        }
        var countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
        });
        function every(collection, callback, thisArg) {
            var result = true;
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    if (!(result = !!callback(collection[index], index, collection))) {
                        break;
                    }
                }
            } else {
                baseEach(collection, function(value, index, collection) {
                    return result = !!callback(value, index, collection);
                });
            }
            return result;
        }
        function filter(collection, callback, thisArg) {
            var result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        result.push(value);
                    }
                }
            } else {
                baseEach(collection, function(value, index, collection) {
                    if (callback(value, index, collection)) {
                        result.push(value);
                    }
                });
            }
            return result;
        }
        function find(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        return value;
                    }
                }
            } else {
                var result;
                baseEach(collection, function(value, index, collection) {
                    if (callback(value, index, collection)) {
                        result = value;
                        return false;
                    }
                });
                return result;
            }
        }
        function findLast(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forEachRight(collection, function(value, index, collection) {
                if (callback(value, index, collection)) {
                    result = value;
                    return false;
                }
            });
            return result;
        }
        function forEach(collection, callback, thisArg) {
            if (callback && typeof thisArg == "undefined" && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    if (callback(collection[index], index, collection) === false) {
                        break;
                    }
                }
            } else {
                baseEach(collection, callback, thisArg);
            }
            return collection;
        }
        function forEachRight(collection, callback, thisArg) {
            var iterable = collection, length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                while (length--) {
                    if (callback(collection[length], length, collection) === false) {
                        break;
                    }
                }
            } else {
                if (typeof length != "number") {
                    var props = keys(collection);
                    length = props.length;
                } else if (support.unindexedChars && isString(collection)) {
                    iterable = collection.split("");
                }
                baseEach(collection, function(value, key, collection) {
                    key = props ? props[--length] : --length;
                    return callback(iterable[key], key, collection);
                });
            }
            return collection;
        }
        var groupBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
        });
        var indexBy = createAggregator(function(result, value, key) {
            result[key] = value;
        });
        function invoke(collection, methodName) {
            var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            forEach(collection, function(value) {
                result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
            });
            return result;
        }
        function map(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                while (++index < length) {
                    result[index] = callback(collection[index], index, collection);
                }
            } else {
                baseEach(collection, function(value, key, collection) {
                    result[++index] = callback(value, key, collection);
                });
            }
            return result;
        }
        function max(collection, callback, thisArg) {
            var computed = -Infinity, result = computed;
            if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                callback = null;
            }
            if (callback == null && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value > result) {
                        result = value;
                    }
                }
            } else {
                callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                baseEach(collection, function(value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current > computed) {
                        computed = current;
                        result = value;
                    }
                });
            }
            return result;
        }
        function min(collection, callback, thisArg) {
            var computed = Infinity, result = computed;
            if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                callback = null;
            }
            if (callback == null && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value < result) {
                        result = value;
                    }
                }
            } else {
                callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                baseEach(collection, function(value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current < computed) {
                        computed = current;
                        result = value;
                    }
                });
            }
            return result;
        }
        var pluck = map;
        function reduce(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                if (noaccum) {
                    accumulator = collection[++index];
                }
                while (++index < length) {
                    accumulator = callback(accumulator, collection[index], index, collection);
                }
            } else {
                baseEach(collection, function(value, index, collection) {
                    accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                });
            }
            return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            forEachRight(collection, function(value, index, collection) {
                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
            });
            return accumulator;
        }
        function reject(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            return filter(collection, function(value, index, collection) {
                return !callback(value, index, collection);
            });
        }
        function sample(collection, n, guard) {
            if (collection && typeof collection.length != "number") {
                collection = values(collection);
            } else if (support.unindexedChars && isString(collection)) {
                collection = collection.split("");
            }
            if (n == null || guard) {
                return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(nativeMax(0, n), result.length);
            return result;
        }
        function shuffle(collection) {
            var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            forEach(collection, function(value) {
                var rand = baseRandom(0, ++index);
                result[index] = result[rand];
                result[rand] = value;
            });
            return result;
        }
        function size(collection) {
            var length = collection ? collection.length : 0;
            return typeof length == "number" ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    if (result = callback(collection[index], index, collection)) {
                        break;
                    }
                }
            } else {
                baseEach(collection, function(value, index, collection) {
                    return !(result = callback(value, index, collection));
                });
            }
            return !!result;
        }
        function sortBy(collection, callback, thisArg) {
            var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
            if (!isArr) {
                callback = lodash.createCallback(callback, thisArg, 3);
            }
            forEach(collection, function(value, key, collection) {
                var object = result[++index] = getObject();
                if (isArr) {
                    object.criteria = map(callback, function(key) {
                        return value[key];
                    });
                } else {
                    (object.criteria = getArray())[0] = callback(value, key, collection);
                }
                object.index = index;
                object.value = value;
            });
            length = result.length;
            result.sort(compareAscending);
            while (length--) {
                var object = result[length];
                result[length] = object.value;
                if (!isArr) {
                    releaseArray(object.criteria);
                }
                releaseObject(object);
            }
            return result;
        }
        function toArray(collection) {
            if (collection && typeof collection.length == "number") {
                return support.unindexedChars && isString(collection) ? collection.split("") : slice(collection);
            }
            return values(collection);
        }
        var where = filter;
        function compact(array) {
            var index = -1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result.push(value);
                }
            }
            return result;
        }
        function difference(array) {
            return baseDifference(array, baseFlatten(arguments, true, true, 1));
        }
        function findIndex(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                if (callback(array[index], index, array)) {
                    return index;
                }
            }
            return -1;
        }
        function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(array[length], length, array)) {
                    return length;
                }
            }
            return -1;
        }
        function first(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = -1;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[0] : undefined;
                }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
        function flatten(array, isShallow, callback, thisArg) {
            if (typeof isShallow != "boolean" && isShallow != null) {
                thisArg = callback;
                callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
                isShallow = false;
            }
            if (callback != null) {
                array = map(array, callback, thisArg);
            }
            return baseFlatten(array, isShallow);
        }
        function indexOf(array, value, fromIndex) {
            if (typeof fromIndex == "number") {
                var length = array ? array.length : 0;
                fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
            } else if (fromIndex) {
                var index = sortedIndex(array, value);
                return array[index] === value ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
        }
        function initial(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback == null || thisArg ? 1 : callback || n;
            }
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection() {
            var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
            while (++argsIndex < argsLength) {
                var value = arguments[argsIndex];
                if (isArray(value) || isArguments(value)) {
                    args.push(value);
                    caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                }
            }
            var array = args[0], index = -1, length = array ? array.length : 0, result = [];
            outer: while (++index < length) {
                var cache = caches[0];
                value = array[index];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                    argsIndex = argsLength;
                    (cache || seen).push(value);
                    while (--argsIndex) {
                        cache = caches[argsIndex];
                        if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                            continue outer;
                        }
                    }
                    result.push(value);
                }
            }
            while (argsLength--) {
                cache = caches[argsLength];
                if (cache) {
                    releaseObject(cache);
                }
            }
            releaseArray(caches);
            releaseArray(seen);
            return result;
        }
        function last(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != "number" && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[length - 1] : undefined;
                }
            }
            return slice(array, nativeMax(0, length - n));
        }
        function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            if (typeof fromIndex == "number") {
                index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
            }
            while (index--) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function pull(array) {
            var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
            while (++argsIndex < argsLength) {
                var index = -1, value = args[argsIndex];
                while (++index < length) {
                    if (array[index] === value) {
                        splice.call(array, index--, 1);
                        length--;
                    }
                }
            }
            return array;
        }
        function range(start, end, step) {
            start = +start || 0;
            step = typeof step == "number" ? step : +step || 1;
            if (end == null) {
                end = start;
                start = 0;
            }
            var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
            while (++index < length) {
                result[index] = start;
                start += step;
            }
            return result;
        }
        function remove(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0, result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                var value = array[index];
                if (callback(value, index, array)) {
                    result.push(value);
                    splice.call(array, index--, 1);
                    length--;
                }
            }
            return result;
        }
        function rest(array, callback, thisArg) {
            if (typeof callback != "number" && callback != null) {
                var n = 0, index = -1, length = array ? array.length : 0;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback == null || thisArg ? 1 : nativeMax(0, callback);
            }
            return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
            var low = 0, high = array ? array.length : low;
            callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
            value = callback(value);
            while (low < high) {
                var mid = low + high >>> 1;
                callback(array[mid]) < value ? low = mid + 1 : high = mid;
            }
            return low;
        }
        function union() {
            return baseUniq(baseFlatten(arguments, true, true));
        }
        function uniq(array, isSorted, callback, thisArg) {
            if (typeof isSorted != "boolean" && isSorted != null) {
                thisArg = callback;
                callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
                isSorted = false;
            }
            if (callback != null) {
                callback = lodash.createCallback(callback, thisArg, 3);
            }
            return baseUniq(array, isSorted, callback);
        }
        function without(array) {
            return baseDifference(array, slice(arguments, 1));
        }
        function xor() {
            var index = -1, length = arguments.length;
            while (++index < length) {
                var array = arguments[index];
                if (isArray(array) || isArguments(array)) {
                    var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                }
            }
            return result || [];
        }
        function zip() {
            var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
            while (++index < length) {
                result[index] = pluck(array, index);
            }
            return result;
        }
        function zipObject(keys, values) {
            var index = -1, length = keys ? keys.length : 0, result = {};
            if (!values && length && !isArray(keys[0])) {
                values = [];
            }
            while (++index < length) {
                var key = keys[index];
                if (values) {
                    result[key] = values[index];
                } else if (key) {
                    result[key[0]] = key[1];
                }
            }
            return result;
        }
        function after(n, func) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            return function() {
                if (--n < 1) {
                    return func.apply(this, arguments);
                }
            };
        }
        function bind(func, thisArg) {
            return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
        }
        function bindAll(object) {
            var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
            while (++index < length) {
                var key = funcs[index];
                object[key] = createWrapper(object[key], 1, null, null, object);
            }
            return object;
        }
        function bindKey(object, key) {
            return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
        }
        function compose() {
            var funcs = arguments, length = funcs.length;
            while (length--) {
                if (!isFunction(funcs[length])) {
                    throw new TypeError();
                }
            }
            return function() {
                var args = arguments, length = funcs.length;
                while (length--) {
                    args = [ funcs[length].apply(this, args) ];
                }
                return args[0];
            };
        }
        function curry(func, arity) {
            arity = typeof arity == "number" ? arity : +arity || func.length;
            return createWrapper(func, 4, null, null, null, arity);
        }
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            wait = nativeMax(0, wait) || 0;
            if (options === true) {
                var leading = true;
                trailing = false;
            } else if (isObject(options)) {
                leading = options.leading;
                maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                trailing = "trailing" in options ? options.trailing : trailing;
            }
            var delayed = function() {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0) {
                    if (maxTimeoutId) {
                        clearTimeout(maxTimeoutId);
                    }
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined;
                    if (isCalled) {
                        lastCalled = now();
                        result = func.apply(thisArg, args);
                        if (!timeoutId && !maxTimeoutId) {
                            args = thisArg = null;
                        }
                    }
                } else {
                    timeoutId = setTimeout(delayed, remaining);
                }
            };
            var maxDelayed = function() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (trailing || maxWait !== wait) {
                    lastCalled = now();
                    result = func.apply(thisArg, args);
                    if (!timeoutId && !maxTimeoutId) {
                        args = thisArg = null;
                    }
                }
            };
            return function() {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);
                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId;
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp;
                    }
                    var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                    if (isCalled) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId);
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args);
                    } else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                    }
                }
                if (isCalled && timeoutId) {
                    timeoutId = clearTimeout(timeoutId);
                } else if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait);
                }
                if (leadingCall) {
                    isCalled = true;
                    result = func.apply(thisArg, args);
                }
                if (isCalled && !timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                }
                return result;
            };
        }
        function defer(func) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var args = slice(arguments, 1);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, 1);
        }
        function delay(func, wait) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var args = slice(arguments, 2);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, wait);
        }
        function memoize(func, resolver) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var memoized = function() {
                var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
            };
            memoized.cache = {};
            return memoized;
        }
        function once(func) {
            var ran, result;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            return function() {
                if (ran) {
                    return result;
                }
                ran = true;
                result = func.apply(this, arguments);
                func = null;
                return result;
            };
        }
        function partial(func) {
            return createWrapper(func, 16, slice(arguments, 1));
        }
        function partialRight(func) {
            return createWrapper(func, 32, null, slice(arguments, 1));
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            if (options === false) {
                leading = false;
            } else if (isObject(options)) {
                leading = "leading" in options ? options.leading : leading;
                trailing = "trailing" in options ? options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = wait;
            debounceOptions.trailing = trailing;
            return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
            return createWrapper(wrapper, 16, [ value ]);
        }
        function constant(value) {
            return function() {
                return value;
            };
        }
        function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (func == null || type == "function") {
                return baseCreateCallback(func, thisArg, argCount);
            }
            if (type != "object") {
                return property(func);
            }
            var props = keys(func), key = props[0], a = func[key];
            if (props.length == 1 && a === a && !isObject(a)) {
                return function(object) {
                    var b = object[key];
                    return a === b && (a !== 0 || 1 / a == 1 / b);
                };
            }
            return function(object) {
                var length = props.length, result = false;
                while (length--) {
                    if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                        break;
                    }
                }
                return result;
            };
        }
        function escape(string) {
            return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
            return value;
        }
        function mixin(object, source, options) {
            var chain = true, methodNames = source && functions(source);
            if (!source || !options && !methodNames.length) {
                if (options == null) {
                    options = source;
                }
                ctor = lodashWrapper;
                source = object;
                object = lodash;
                methodNames = functions(source);
            }
            if (options === false) {
                chain = false;
            } else if (isObject(options) && "chain" in options) {
                chain = options.chain;
            }
            var ctor = object, isFunc = isFunction(ctor);
            forEach(methodNames, function(methodName) {
                var func = object[methodName] = source[methodName];
                if (isFunc) {
                    ctor.prototype[methodName] = function() {
                        var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                        push.apply(args, arguments);
                        var result = func.apply(object, args);
                        if (chain || chainAll) {
                            if (value === result && isObject(result)) {
                                return this;
                            }
                            result = new ctor(result);
                            result.__chain__ = chainAll;
                        }
                        return result;
                    };
                }
            });
        }
        function noConflict() {
            context._ = oldDash;
            return this;
        }
        function noop() {}
        var now = isNative(now = Date.now) && now || function() {
            return new Date().getTime();
        };
        var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
        };
        function property(key) {
            return function(object) {
                return object[key];
            };
        }
        function random(min, max, floating) {
            var noMin = min == null, noMax = max == null;
            if (floating == null) {
                if (typeof min == "boolean" && noMax) {
                    floating = min;
                    min = 1;
                } else if (!noMax && typeof max == "boolean") {
                    floating = max;
                    noMax = true;
                }
            }
            if (noMin && noMax) {
                max = 1;
            }
            min = +min || 0;
            if (noMax) {
                max = min;
                min = 0;
            } else {
                max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
                var rand = nativeRandom();
                return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
            }
            return baseRandom(min, max);
        }
        function result(object, key) {
            if (object) {
                var value = object[key];
                return isFunction(value) ? object[key]() : value;
            }
        }
        function template(text, data, options) {
            var settings = lodash.templateSettings;
            text = String(text || "");
            options = defaults({}, options, settings);
            var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
            var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                }
                if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                }
                index = offset + match.length;
                return match;
            });
            source += "';\n";
            var variable = options.variable, hasVariable = variable;
            if (!hasVariable) {
                variable = "obj";
                source = "with (" + variable + ") {\n" + source + "\n}\n";
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
            try {
                var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
            } catch (e) {
                e.source = source;
                throw e;
            }
            if (data) {
                return result(data);
            }
            result.source = source;
            return result;
        }
        function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1, result = Array(n);
            callback = baseCreateCallback(callback, thisArg, 1);
            while (++index < n) {
                result[index] = callback(index);
            }
            return result;
        }
        function unescape(string) {
            return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return String(prefix == null ? "" : prefix) + id;
        }
        function chain(value) {
            value = new lodashWrapper(value);
            value.__chain__ = true;
            return value;
        }
        function tap(value, interceptor) {
            interceptor(value);
            return value;
        }
        function wrapperChain() {
            this.__chain__ = true;
            return this;
        }
        function wrapperToString() {
            return String(this.__wrapped__);
        }
        function wrapperValueOf() {
            return this.__wrapped__;
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.chain = chain;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.createCallback = createCallback;
        lodash.curry = curry;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.pull = pull;
        lodash.range = range;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        lodash.unzip = zip;
        mixin(lodash);
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        mixin(function() {
            var source = {};
            forOwn(lodash, function(func, methodName) {
                if (!lodash.prototype[methodName]) {
                    source[methodName] = func;
                }
            });
            return source;
        }(), false);
        lodash.first = first;
        lodash.last = last;
        lodash.sample = sample;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function(func, methodName) {
            var callbackable = methodName !== "sample";
            if (!lodash.prototype[methodName]) {
                lodash.prototype[methodName] = function(n, guard) {
                    var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                    return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
                };
            }
        });
        lodash.VERSION = "2.4.1";
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        baseEach([ "join", "pop", "shift" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                return chainAll ? new lodashWrapper(result, chainAll) : result;
            };
        });
        baseEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                func.apply(this.__wrapped__, arguments);
                return this;
            };
        });
        baseEach([ "concat", "slice", "splice" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
            };
        });
        if (!support.spliceObjects) {
            baseEach([ "pop", "shift", "splice" ], function(methodName) {
                var func = arrayRef[methodName], isSplice = methodName == "splice";
                lodash.prototype[methodName] = function() {
                    var chainAll = this.__chain__, value = this.__wrapped__, result = func.apply(value, arguments);
                    if (value.length === 0) {
                        delete value[0];
                    }
                    return chainAll || isSplice ? new lodashWrapper(result, chainAll) : result;
                };
            });
        }
        return lodash;
    }
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
            return _;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _;
        } else {
            freeExports._ = _;
        }
    } else {
        root._ = _;
    }
}).call(this);

(function() {
    var module = angular.module("restangular", []);
    module.provider("Restangular", function() {
        var Configurer = {};
        Configurer.init = function(object, config) {
            object.configuration = config;
            var safeMethods = [ "get", "head", "options", "trace", "getlist" ];
            config.isSafe = function(operation) {
                return _.contains(safeMethods, operation.toLowerCase());
            };
            var absolutePattern = /^https?:\/\//i;
            config.isAbsoluteUrl = function(string) {
                return _.isUndefined(config.absoluteUrl) || _.isNull(config.absoluteUrl) ? string && absolutePattern.test(string) : config.absoluteUrl;
            };
            config.absoluteUrl = _.isUndefined(config.absoluteUrl) ? true : config.absoluteUrl;
            object.setSelfLinkAbsoluteUrl = function(value) {
                config.absoluteUrl = value;
            };
            config.baseUrl = _.isUndefined(config.baseUrl) ? "" : config.baseUrl;
            object.setBaseUrl = function(newBaseUrl) {
                config.baseUrl = /\/$/.test(newBaseUrl) ? newBaseUrl.substring(0, newBaseUrl.length - 1) : newBaseUrl;
                return this;
            };
            config.extraFields = config.extraFields || [];
            object.setExtraFields = function(newExtraFields) {
                config.extraFields = newExtraFields;
                return this;
            };
            config.defaultHttpFields = config.defaultHttpFields || {};
            object.setDefaultHttpFields = function(values) {
                config.defaultHttpFields = values;
                return this;
            };
            config.withHttpValues = function(httpLocalConfig, obj) {
                return _.defaults(obj, httpLocalConfig, config.defaultHttpFields);
            };
            config.encodeIds = _.isUndefined(config.encodeIds) ? true : config.encodeIds;
            object.setEncodeIds = function(encode) {
                config.encodeIds = encode;
            };
            config.defaultRequestParams = config.defaultRequestParams || {
                get: {},
                post: {},
                put: {},
                remove: {},
                common: {}
            };
            object.setDefaultRequestParams = function(param1, param2) {
                var methods = [], params = param2 || param1;
                if (!_.isUndefined(param2)) {
                    if (_.isArray(param1)) {
                        methods = param1;
                    } else {
                        methods.push(param1);
                    }
                } else {
                    methods.push("common");
                }
                _.each(methods, function(method) {
                    config.defaultRequestParams[method] = params;
                });
                return this;
            };
            object.requestParams = config.defaultRequestParams;
            config.defaultHeaders = config.defaultHeaders || {};
            object.setDefaultHeaders = function(headers) {
                config.defaultHeaders = headers;
                object.defaultHeaders = config.defaultHeaders;
                return this;
            };
            object.defaultHeaders = config.defaultHeaders;
            config.methodOverriders = config.methodOverriders || [];
            object.setMethodOverriders = function(values) {
                var overriders = _.extend([], values);
                if (config.isOverridenMethod("delete", overriders)) {
                    overriders.push("remove");
                }
                config.methodOverriders = overriders;
                return this;
            };
            config.jsonp = _.isUndefined(config.jsonp) ? false : config.jsonp;
            object.setJsonp = function(active) {
                config.jsonp = active;
            };
            config.isOverridenMethod = function(method, values) {
                var search = values || config.methodOverriders;
                return !_.isUndefined(_.find(search, function(one) {
                    return one.toLowerCase() === method.toLowerCase();
                }));
            };
            config.urlCreator = config.urlCreator || "path";
            object.setUrlCreator = function(name) {
                if (!_.has(config.urlCreatorFactory, name)) {
                    throw new Error("URL Path selected isn't valid");
                }
                config.urlCreator = name;
                return this;
            };
            config.restangularFields = config.restangularFields || {
                id: "id",
                route: "route",
                parentResource: "parentResource",
                restangularCollection: "restangularCollection",
                cannonicalId: "__cannonicalId",
                etag: "restangularEtag",
                selfLink: "href",
                get: "get",
                getList: "getList",
                put: "put",
                post: "post",
                remove: "remove",
                head: "head",
                trace: "trace",
                options: "options",
                patch: "patch",
                getRestangularUrl: "getRestangularUrl",
                getRequestedUrl: "getRequestedUrl",
                putElement: "putElement",
                addRestangularMethod: "addRestangularMethod",
                getParentList: "getParentList",
                clone: "clone",
                ids: "ids",
                httpConfig: "_$httpConfig",
                reqParams: "reqParams",
                one: "one",
                all: "all",
                several: "several",
                oneUrl: "oneUrl",
                allUrl: "allUrl",
                customPUT: "customPUT",
                customPOST: "customPOST",
                customDELETE: "customDELETE",
                customGET: "customGET",
                customGETLIST: "customGETLIST",
                customOperation: "customOperation",
                doPUT: "doPUT",
                doPOST: "doPOST",
                doDELETE: "doDELETE",
                doGET: "doGET",
                doGETLIST: "doGETLIST",
                fromServer: "fromServer",
                withConfig: "withConfig",
                withHttpConfig: "withHttpConfig",
                singleOne: "singleOne",
                plain: "plain",
                save: "save"
            };
            object.setRestangularFields = function(resFields) {
                config.restangularFields = _.extend(config.restangularFields, resFields);
                return this;
            };
            config.isRestangularized = function(obj) {
                return !!obj[config.restangularFields.one] || !!obj[config.restangularFields.all];
            };
            config.setFieldToElem = function(field, elem, value) {
                var properties = field.split(".");
                var idValue = elem;
                _.each(_.initial(properties), function(prop) {
                    idValue[prop] = {};
                    idValue = idValue[prop];
                });
                idValue[_.last(properties)] = value;
                return this;
            };
            config.getFieldFromElem = function(field, elem) {
                var properties = field.split(".");
                var idValue = elem;
                _.each(properties, function(prop) {
                    if (idValue) {
                        idValue = idValue[prop];
                    }
                });
                return angular.copy(idValue);
            };
            config.setIdToElem = function(elem, id) {
                config.setFieldToElem(config.restangularFields.id, elem, id);
                return this;
            };
            config.getIdFromElem = function(elem) {
                return config.getFieldFromElem(config.restangularFields.id, elem);
            };
            config.isValidId = function(elemId) {
                return "" !== elemId && !_.isUndefined(elemId) && !_.isNull(elemId);
            };
            config.setUrlToElem = function(elem, url, route) {
                config.setFieldToElem(config.restangularFields.selfLink, elem, url);
                return this;
            };
            config.getUrlFromElem = function(elem) {
                return config.getFieldFromElem(config.restangularFields.selfLink, elem);
            };
            config.useCannonicalId = _.isUndefined(config.useCannonicalId) ? false : config.useCannonicalId;
            object.setUseCannonicalId = function(value) {
                config.useCannonicalId = value;
                return this;
            };
            config.getCannonicalIdFromElem = function(elem) {
                var cannonicalId = elem[config.restangularFields.cannonicalId];
                var actualId = config.isValidId(cannonicalId) ? cannonicalId : config.getIdFromElem(elem);
                return actualId;
            };
            config.responseInterceptors = config.responseInterceptors || [];
            config.defaultResponseInterceptor = function(data, operation, what, url, response, deferred) {
                return data;
            };
            config.responseExtractor = function(data, operation, what, url, response, deferred) {
                var interceptors = angular.copy(config.responseInterceptors);
                interceptors.push(config.defaultResponseInterceptor);
                var theData = data;
                _.each(interceptors, function(interceptor) {
                    theData = interceptor(theData, operation, what, url, response, deferred);
                });
                return theData;
            };
            object.addResponseInterceptor = function(extractor) {
                config.responseInterceptors.push(extractor);
                return this;
            };
            object.setResponseInterceptor = object.addResponseInterceptor;
            object.setResponseExtractor = object.addResponseInterceptor;
            config.requestInterceptors = config.requestInterceptors || [];
            config.defaultInterceptor = function(element, operation, path, url, headers, params, httpConfig) {
                return {
                    element: element,
                    headers: headers,
                    params: params,
                    httpConfig: httpConfig
                };
            };
            config.fullRequestInterceptor = function(element, operation, path, url, headers, params, httpConfig) {
                var interceptors = angular.copy(config.requestInterceptors);
                var defaultRequest = config.defaultInterceptor(element, operation, path, url, headers, params, httpConfig);
                return _.reduce(interceptors, function(request, interceptor) {
                    return _.extend(request, interceptor(request.element, operation, path, url, request.headers, request.params, request.httpConfig));
                }, defaultRequest);
            };
            object.addRequestInterceptor = function(interceptor) {
                config.requestInterceptors.push(function(elem, operation, path, url, headers, params, httpConfig) {
                    return {
                        headers: headers,
                        params: params,
                        element: interceptor(elem, operation, path, url),
                        httpConfig: httpConfig
                    };
                });
                return this;
            };
            object.setRequestInterceptor = object.addRequestInterceptor;
            object.addFullRequestInterceptor = function(interceptor) {
                config.requestInterceptors.push(interceptor);
                return this;
            };
            object.setFullRequestInterceptor = object.addFullRequestInterceptor;
            config.errorInterceptor = config.errorInterceptor || function() {};
            object.setErrorInterceptor = function(interceptor) {
                config.errorInterceptor = interceptor;
                return this;
            };
            config.onBeforeElemRestangularized = config.onBeforeElemRestangularized || function(elem) {
                return elem;
            };
            object.setOnBeforeElemRestangularized = function(post) {
                config.onBeforeElemRestangularized = post;
                return this;
            };
            config.onElemRestangularized = config.onElemRestangularized || function(elem) {
                return elem;
            };
            object.setOnElemRestangularized = function(post) {
                config.onElemRestangularized = post;
                return this;
            };
            config.shouldSaveParent = config.shouldSaveParent || function() {
                return true;
            };
            object.setParentless = function(values) {
                if (_.isArray(values)) {
                    config.shouldSaveParent = function(route) {
                        return !_.contains(values, route);
                    };
                } else if (_.isBoolean(values)) {
                    config.shouldSaveParent = function() {
                        return !values;
                    };
                }
                return this;
            };
            config.suffix = _.isUndefined(config.suffix) ? null : config.suffix;
            object.setRequestSuffix = function(newSuffix) {
                config.suffix = newSuffix;
                return this;
            };
            config.transformers = config.transformers || {};
            object.addElementTransformer = function(type, secondArg, thirdArg) {
                var isCollection = null;
                var transformer = null;
                if (arguments.length === 2) {
                    transformer = secondArg;
                } else {
                    transformer = thirdArg;
                    isCollection = secondArg;
                }
                var typeTransformers = config.transformers[type];
                if (!typeTransformers) {
                    typeTransformers = config.transformers[type] = [];
                }
                typeTransformers.push(function(coll, elem) {
                    if (_.isNull(isCollection) || coll == isCollection) {
                        return transformer(elem);
                    }
                    return elem;
                });
                return object;
            };
            object.extendCollection = function(route, fn) {
                return object.addElementTransformer(route, true, fn);
            };
            object.extendModel = function(route, fn) {
                return object.addElementTransformer(route, false, fn);
            };
            config.transformElem = function(elem, isCollection, route, Restangular, force) {
                if (!force && !config.transformLocalElements && !elem[config.restangularFields.fromServer]) {
                    return elem;
                }
                var typeTransformers = config.transformers[route];
                var changedElem = elem;
                if (typeTransformers) {
                    _.each(typeTransformers, function(transformer) {
                        changedElem = transformer(isCollection, changedElem);
                    });
                }
                return config.onElemRestangularized(changedElem, isCollection, route, Restangular);
            };
            config.transformLocalElements = _.isUndefined(config.transformLocalElements) ? false : config.transformLocalElements;
            object.setTransformOnlyServerElements = function(active) {
                config.transformLocalElements = !active;
            };
            config.fullResponse = _.isUndefined(config.fullResponse) ? false : config.fullResponse;
            object.setFullResponse = function(full) {
                config.fullResponse = full;
                return this;
            };
            config.urlCreatorFactory = {};
            var BaseCreator = function() {};
            BaseCreator.prototype.setConfig = function(config) {
                this.config = config;
                return this;
            };
            BaseCreator.prototype.parentsArray = function(current) {
                var parents = [];
                while (current) {
                    parents.push(current);
                    current = current[this.config.restangularFields.parentResource];
                }
                return parents.reverse();
            };
            function RestangularResource(config, $http, url, configurer) {
                var resource = {};
                _.each(_.keys(configurer), function(key) {
                    var value = configurer[key];
                    value.params = _.extend({}, value.params, config.defaultRequestParams[value.method.toLowerCase()]);
                    if (_.isEmpty(value.params)) {
                        delete value.params;
                    }
                    if (config.isSafe(value.method)) {
                        resource[key] = function() {
                            return $http(_.extend(value, {
                                url: url
                            }));
                        };
                    } else {
                        resource[key] = function(data) {
                            return $http(_.extend(value, {
                                url: url,
                                data: data
                            }));
                        };
                    }
                });
                return resource;
            }
            BaseCreator.prototype.resource = function(current, $http, localHttpConfig, callHeaders, callParams, what, etag, operation) {
                var params = _.defaults(callParams || {}, this.config.defaultRequestParams.common);
                var headers = _.defaults(callHeaders || {}, this.config.defaultHeaders);
                if (etag) {
                    if (!config.isSafe(operation)) {
                        headers["If-Match"] = etag;
                    } else {
                        headers["If-None-Match"] = etag;
                    }
                }
                var url = this.base(current);
                if (what) {
                    var add = "";
                    if (!/\/$/.test(url)) {
                        add += "/";
                    }
                    add += what;
                    url += add;
                }
                if (this.config.suffix && url.indexOf(this.config.suffix, url.length - this.config.suffix.length) === -1 && !this.config.getUrlFromElem(current)) {
                    url += this.config.suffix;
                }
                current[this.config.restangularFields.httpConfig] = undefined;
                return RestangularResource(this.config, $http, url, {
                    getList: this.config.withHttpValues(localHttpConfig, {
                        method: "GET",
                        params: params,
                        headers: headers
                    }),
                    get: this.config.withHttpValues(localHttpConfig, {
                        method: "GET",
                        params: params,
                        headers: headers
                    }),
                    jsonp: this.config.withHttpValues(localHttpConfig, {
                        method: "jsonp",
                        params: params,
                        headers: headers
                    }),
                    put: this.config.withHttpValues(localHttpConfig, {
                        method: "PUT",
                        params: params,
                        headers: headers
                    }),
                    post: this.config.withHttpValues(localHttpConfig, {
                        method: "POST",
                        params: params,
                        headers: headers
                    }),
                    remove: this.config.withHttpValues(localHttpConfig, {
                        method: "DELETE",
                        params: params,
                        headers: headers
                    }),
                    head: this.config.withHttpValues(localHttpConfig, {
                        method: "HEAD",
                        params: params,
                        headers: headers
                    }),
                    trace: this.config.withHttpValues(localHttpConfig, {
                        method: "TRACE",
                        params: params,
                        headers: headers
                    }),
                    options: this.config.withHttpValues(localHttpConfig, {
                        method: "OPTIONS",
                        params: params,
                        headers: headers
                    }),
                    patch: this.config.withHttpValues(localHttpConfig, {
                        method: "PATCH",
                        params: params,
                        headers: headers
                    })
                });
            };
            var Path = function() {};
            Path.prototype = new BaseCreator();
            Path.prototype.base = function(current) {
                var __this = this;
                return _.reduce(this.parentsArray(current), function(acum, elem) {
                    var elemUrl;
                    var elemSelfLink = __this.config.getUrlFromElem(elem);
                    if (elemSelfLink) {
                        if (__this.config.isAbsoluteUrl(elemSelfLink)) {
                            return elemSelfLink;
                        } else {
                            elemUrl = elemSelfLink;
                        }
                    } else {
                        elemUrl = elem[__this.config.restangularFields.route];
                        if (elem[__this.config.restangularFields.restangularCollection]) {
                            var ids = elem[__this.config.restangularFields.ids];
                            if (ids) {
                                elemUrl += "/" + ids.join(",");
                            }
                        } else {
                            var elemId;
                            if (__this.config.useCannonicalId) {
                                elemId = __this.config.getCannonicalIdFromElem(elem);
                            } else {
                                elemId = __this.config.getIdFromElem(elem);
                            }
                            if (config.isValidId(elemId) && !elem.singleOne) {
                                elemUrl += "/" + (__this.config.encodeIds ? encodeURIComponent(elemId) : elemId);
                            }
                        }
                    }
                    return acum.replace(/\/$/, "") + "/" + elemUrl;
                }, this.config.baseUrl);
            };
            Path.prototype.fetchUrl = function(current, what) {
                var baseUrl = this.base(current);
                if (what) {
                    baseUrl += "/" + what;
                }
                return baseUrl;
            };
            Path.prototype.fetchRequestedUrl = function(current, what) {
                var url = this.fetchUrl(current, what);
                var params = current[config.restangularFields.reqParams];
                function sortedKeys(obj) {
                    var keys = [];
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            keys.push(key);
                        }
                    }
                    return keys.sort();
                }
                function forEachSorted(obj, iterator, context) {
                    var keys = sortedKeys(obj);
                    for (var i = 0; i < keys.length; i++) {
                        iterator.call(context, obj[keys[i]], keys[i]);
                    }
                    return keys;
                }
                function encodeUriQuery(val, pctEncodeSpaces) {
                    return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
                }
                if (!params) return url;
                var parts = [];
                forEachSorted(params, function(value, key) {
                    if (value == null || value == undefined) return;
                    if (!angular.isArray(value)) value = [ value ];
                    angular.forEach(value, function(v) {
                        if (angular.isObject(v)) {
                            v = angular.toJson(v);
                        }
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    });
                });
                return url + (this.config.suffix || "") + (url.indexOf("?") === -1 ? "?" : "&") + parts.join("&");
            };
            config.urlCreatorFactory.path = Path;
        };
        var globalConfiguration = {};
        Configurer.init(this, globalConfiguration);
        this.$get = [ "$http", "$q", function($http, $q) {
            function createServiceForConfiguration(config) {
                var service = {};
                var urlHandler = new config.urlCreatorFactory[config.urlCreator]();
                urlHandler.setConfig(config);
                function restangularizeBase(parent, elem, route, reqParams, fromServer) {
                    elem[config.restangularFields.route] = route;
                    elem[config.restangularFields.getRestangularUrl] = _.bind(urlHandler.fetchUrl, urlHandler, elem);
                    elem[config.restangularFields.getRequestedUrl] = _.bind(urlHandler.fetchRequestedUrl, urlHandler, elem);
                    elem[config.restangularFields.addRestangularMethod] = _.bind(addRestangularMethodFunction, elem);
                    elem[config.restangularFields.clone] = _.bind(copyRestangularizedElement, elem, elem);
                    elem[config.restangularFields.reqParams] = _.isEmpty(reqParams) ? null : reqParams;
                    elem[config.restangularFields.withHttpConfig] = _.bind(withHttpConfig, elem);
                    elem[config.restangularFields.plain] = _.bind(stripRestangular, elem, elem);
                    elem[config.restangularFields.one] = _.bind(one, elem, elem);
                    elem[config.restangularFields.all] = _.bind(all, elem, elem);
                    elem[config.restangularFields.several] = _.bind(several, elem, elem);
                    elem[config.restangularFields.oneUrl] = _.bind(oneUrl, elem, elem);
                    elem[config.restangularFields.allUrl] = _.bind(allUrl, elem, elem);
                    elem[config.restangularFields.fromServer] = !!fromServer;
                    if (parent && config.shouldSaveParent(route)) {
                        var parentId = config.getIdFromElem(parent);
                        var parentUrl = config.getUrlFromElem(parent);
                        var restangularFieldsForParent = _.union(_.values(_.pick(config.restangularFields, [ "route", "singleOne", "parentResource" ])), config.extraFields);
                        var parentResource = _.pick(parent, restangularFieldsForParent);
                        if (config.isValidId(parentId)) {
                            config.setIdToElem(parentResource, parentId);
                        }
                        if (config.isValidId(parentUrl)) {
                            config.setUrlToElem(parentResource, parentUrl);
                        }
                        elem[config.restangularFields.parentResource] = parentResource;
                    } else {
                        elem[config.restangularFields.parentResource] = null;
                    }
                    return elem;
                }
                function one(parent, route, id, singleOne) {
                    if (_.isNumber(route) || _.isNumber(parent)) {
                        var error = "You're creating a Restangular entity with the number ";
                        error += "instead of the route or the parent. You can't call .one(12)";
                        throw new Error(error);
                    }
                    var elem = {};
                    config.setIdToElem(elem, id);
                    config.setFieldToElem(config.restangularFields.singleOne, elem, singleOne);
                    return restangularizeElem(parent, elem, route, false);
                }
                function all(parent, route) {
                    return restangularizeCollection(parent, [], route, false);
                }
                function several(parent, route, ids) {
                    var collection = [];
                    collection[config.restangularFields.ids] = Array.prototype.splice.call(arguments, 2);
                    return restangularizeCollection(parent, collection, route, false);
                }
                function oneUrl(parent, route, url) {
                    if (!route) {
                        throw new Error("Route is mandatory when creating new Restangular objects.");
                    }
                    var elem = {};
                    config.setUrlToElem(elem, url, route);
                    return restangularizeElem(parent, elem, route, false);
                }
                function allUrl(parent, route, url) {
                    if (!route) {
                        throw new Error("Route is mandatory when creating new Restangular objects.");
                    }
                    var elem = {};
                    config.setUrlToElem(elem, url, route);
                    return restangularizeCollection(parent, elem, route, false);
                }
                function restangularizePromise(promise, isCollection, valueToFill) {
                    promise.call = _.bind(promiseCall, promise);
                    promise.get = _.bind(promiseGet, promise);
                    promise[config.restangularFields.restangularCollection] = isCollection;
                    if (isCollection) {
                        promise.push = _.bind(promiseCall, promise, "push");
                    }
                    promise.$object = valueToFill;
                    return promise;
                }
                function promiseCall(method) {
                    var deferred = $q.defer();
                    var callArgs = arguments;
                    var filledValue = {};
                    this.then(function(val) {
                        var params = Array.prototype.slice.call(callArgs, 1);
                        var func = val[method];
                        func.apply(val, params);
                        filledValue = val;
                        deferred.resolve(val);
                    });
                    return restangularizePromise(deferred.promise, this[config.restangularFields.restangularCollection], filledValue);
                }
                function promiseGet(what) {
                    var deferred = $q.defer();
                    var filledValue = {};
                    this.then(function(val) {
                        filledValue = val[what];
                        deferred.resolve(filledValue);
                    });
                    return restangularizePromise(deferred.promise, this[config.restangularFields.restangularCollection], filledValue);
                }
                function resolvePromise(deferred, response, data, filledValue) {
                    _.extend(filledValue, data);
                    if (config.fullResponse) {
                        return deferred.resolve(_.extend(response, {
                            data: data
                        }));
                    } else {
                        deferred.resolve(data);
                    }
                }
                function stripRestangular(elem) {
                    if (_.isArray(elem)) {
                        var array = [];
                        _.each(elem, function(value) {
                            array.push(stripRestangular(value));
                        });
                        return array;
                    } else {
                        return _.omit(elem, _.values(_.omit(config.restangularFields, "id")));
                    }
                }
                function addCustomOperation(elem) {
                    elem[config.restangularFields.customOperation] = _.bind(customFunction, elem);
                    _.each([ "put", "post", "get", "delete" ], function(oper) {
                        _.each([ "do", "custom" ], function(alias) {
                            var callOperation = oper === "delete" ? "remove" : oper;
                            var name = alias + oper.toUpperCase();
                            var callFunction;
                            if (callOperation !== "put" && callOperation !== "post") {
                                callFunction = customFunction;
                            } else {
                                callFunction = function(operation, elem, path, params, headers) {
                                    return _.bind(customFunction, this)(operation, path, params, headers, elem);
                                };
                            }
                            elem[name] = _.bind(callFunction, elem, callOperation);
                        });
                    });
                    elem[config.restangularFields.customGETLIST] = _.bind(fetchFunction, elem);
                    elem[config.restangularFields.doGETLIST] = elem[config.restangularFields.customGETLIST];
                }
                function copyRestangularizedElement(fromElement, toElement) {
                    var copiedElement = angular.copy(fromElement, toElement);
                    return restangularizeElem(copiedElement[config.restangularFields.parentResource], copiedElement, copiedElement[config.restangularFields.route], true);
                }
                function restangularizeElem(parent, element, route, fromServer, collection, reqParams) {
                    var elem = config.onBeforeElemRestangularized(element, false, route);
                    var localElem = restangularizeBase(parent, elem, route, reqParams, fromServer);
                    if (config.useCannonicalId) {
                        localElem[config.restangularFields.cannonicalId] = config.getIdFromElem(localElem);
                    }
                    if (collection) {
                        localElem[config.restangularFields.getParentList] = function() {
                            return collection;
                        };
                    }
                    localElem[config.restangularFields.restangularCollection] = false;
                    localElem[config.restangularFields.get] = _.bind(getFunction, localElem);
                    localElem[config.restangularFields.getList] = _.bind(fetchFunction, localElem);
                    localElem[config.restangularFields.put] = _.bind(putFunction, localElem);
                    localElem[config.restangularFields.post] = _.bind(postFunction, localElem);
                    localElem[config.restangularFields.remove] = _.bind(deleteFunction, localElem);
                    localElem[config.restangularFields.head] = _.bind(headFunction, localElem);
                    localElem[config.restangularFields.trace] = _.bind(traceFunction, localElem);
                    localElem[config.restangularFields.options] = _.bind(optionsFunction, localElem);
                    localElem[config.restangularFields.patch] = _.bind(patchFunction, localElem);
                    localElem[config.restangularFields.save] = _.bind(save, localElem);
                    addCustomOperation(localElem);
                    return config.transformElem(localElem, false, route, service, true);
                }
                function restangularizeCollection(parent, element, route, fromServer, reqParams) {
                    var elem = config.onBeforeElemRestangularized(element, true, route);
                    var localElem = restangularizeBase(parent, elem, route, reqParams, fromServer);
                    localElem[config.restangularFields.restangularCollection] = true;
                    localElem[config.restangularFields.post] = _.bind(postFunction, localElem, null);
                    localElem[config.restangularFields.remove] = _.bind(deleteFunction, localElem);
                    localElem[config.restangularFields.head] = _.bind(headFunction, localElem);
                    localElem[config.restangularFields.trace] = _.bind(traceFunction, localElem);
                    localElem[config.restangularFields.putElement] = _.bind(putElementFunction, localElem);
                    localElem[config.restangularFields.options] = _.bind(optionsFunction, localElem);
                    localElem[config.restangularFields.patch] = _.bind(patchFunction, localElem);
                    localElem[config.restangularFields.get] = _.bind(getById, localElem);
                    localElem[config.restangularFields.getList] = _.bind(fetchFunction, localElem, null);
                    addCustomOperation(localElem);
                    return config.transformElem(localElem, true, route, service, true);
                }
                function restangularizeCollectionAndElements(parent, element, route) {
                    var collection = restangularizeCollection(parent, element, route, false);
                    _.each(collection, function(elem) {
                        restangularizeElem(parent, elem, route, false);
                    });
                    return collection;
                }
                function getById(id, reqParams, headers) {
                    return this.customGET(id.toString(), reqParams, headers);
                }
                function putElementFunction(idx, params, headers) {
                    var __this = this;
                    var elemToPut = this[idx];
                    var deferred = $q.defer();
                    var filledArray = [];
                    filledArray = config.transformElem(filledArray, true, elemToPut[config.restangularFields.route], service);
                    elemToPut.put(params, headers).then(function(serverElem) {
                        var newArray = copyRestangularizedElement(__this);
                        newArray[idx] = serverElem;
                        filledArray = newArray;
                        deferred.resolve(newArray);
                    }, function(response) {
                        deferred.reject(response);
                    });
                    return restangularizePromise(deferred.promise, true, filledArray);
                }
                function parseResponse(resData, operation, route, fetchUrl, response, deferred) {
                    var data = config.responseExtractor(resData, operation, route, fetchUrl, response, deferred);
                    var etag = response.headers("ETag");
                    if (data && etag) {
                        data[config.restangularFields.etag] = etag;
                    }
                    return data;
                }
                function fetchFunction(what, reqParams, headers) {
                    var __this = this;
                    var deferred = $q.defer();
                    var operation = "getList";
                    var url = urlHandler.fetchUrl(this, what);
                    var whatFetched = what || __this[config.restangularFields.route];
                    var request = config.fullRequestInterceptor(null, operation, whatFetched, url, headers || {}, reqParams || {}, this[config.restangularFields.httpConfig] || {});
                    var filledArray = [];
                    filledArray = config.transformElem(filledArray, true, whatFetched, service);
                    var method = "getList";
                    if (config.jsonp) {
                        method = "jsonp";
                    }
                    urlHandler.resource(this, $http, request.httpConfig, request.headers, request.params, what, this[config.restangularFields.etag], operation)[method]().then(function(response) {
                        var resData = response.data;
                        var fullParams = response.config.params;
                        var data = parseResponse(resData, operation, whatFetched, url, response, deferred);
                        if (_.isUndefined(data) || "" === data) {
                            data = [];
                        }
                        if (!_.isArray(data)) {
                            throw new Error("Response for getList SHOULD be an array and not an object or something else");
                        }
                        var processedData = _.map(data, function(elem) {
                            if (!__this[config.restangularFields.restangularCollection]) {
                                return restangularizeElem(__this, elem, what, true, data);
                            } else {
                                return restangularizeElem(__this[config.restangularFields.parentResource], elem, __this[config.restangularFields.route], true, data);
                            }
                        });
                        processedData = _.extend(data, processedData);
                        if (!__this[config.restangularFields.restangularCollection]) {
                            resolvePromise(deferred, response, restangularizeCollection(__this, processedData, what, true, fullParams), filledArray);
                        } else {
                            resolvePromise(deferred, response, restangularizeCollection(__this[config.restangularFields.parentResource], processedData, __this[config.restangularFields.route], true, fullParams), filledArray);
                        }
                    }, function error(response) {
                        if (response.status === 304 && __this[config.restangularFields.restangularCollection]) {
                            resolvePromise(deferred, response, __this, filledArray);
                        } else if (config.errorInterceptor(response, deferred) !== false) {
                            deferred.reject(response);
                        }
                    });
                    return restangularizePromise(deferred.promise, true, filledArray);
                }
                function withHttpConfig(httpConfig) {
                    this[config.restangularFields.httpConfig] = httpConfig;
                    return this;
                }
                function save(params, headers) {
                    if (this[config.restangularFields.fromServer]) {
                        return this[config.restangularFields.put](params, headers);
                    } else {
                        return _.bind(elemFunction, this)("post", undefined, params, undefined, headers);
                    }
                }
                function elemFunction(operation, what, params, obj, headers) {
                    var __this = this;
                    var deferred = $q.defer();
                    var resParams = params || {};
                    var route = what || this[config.restangularFields.route];
                    var fetchUrl = urlHandler.fetchUrl(this, what);
                    var callObj = obj || this;
                    var etag = callObj[config.restangularFields.etag] || (operation != "post" ? this[config.restangularFields.etag] : null);
                    if (_.isObject(callObj) && config.isRestangularized(callObj)) {
                        callObj = stripRestangular(callObj);
                    }
                    var request = config.fullRequestInterceptor(callObj, operation, route, fetchUrl, headers || {}, resParams || {}, this[config.restangularFields.httpConfig] || {});
                    var filledObject = {};
                    filledObject = config.transformElem(filledObject, false, route, service);
                    var okCallback = function(response) {
                        var resData = response.data;
                        var fullParams = response.config.params;
                        var elem = parseResponse(resData, operation, route, fetchUrl, response, deferred);
                        if (elem) {
                            if (operation === "post" && !__this[config.restangularFields.restangularCollection]) {
                                resolvePromise(deferred, response, restangularizeElem(__this, elem, what, true, null, fullParams), filledObject);
                            } else {
                                var data = restangularizeElem(__this[config.restangularFields.parentResource], elem, __this[config.restangularFields.route], true, null, fullParams);
                                data[config.restangularFields.singleOne] = __this[config.restangularFields.singleOne];
                                resolvePromise(deferred, response, data, filledObject);
                            }
                        } else {
                            resolvePromise(deferred, response, undefined, filledObject);
                        }
                    };
                    var errorCallback = function(response) {
                        if (response.status === 304 && config.isSafe(operation)) {
                            resolvePromise(deferred, response, __this, filledObject);
                        } else if (config.errorInterceptor(response, deferred) !== false) {
                            deferred.reject(response);
                        }
                    };
                    var callOperation = operation;
                    var callHeaders = _.extend({}, request.headers);
                    var isOverrideOperation = config.isOverridenMethod(operation);
                    if (isOverrideOperation) {
                        callOperation = "post";
                        callHeaders = _.extend(callHeaders, {
                            "X-HTTP-Method-Override": operation === "remove" ? "DELETE" : operation
                        });
                    } else if (config.jsonp && callOperation === "get") {
                        callOperation = "jsonp";
                    }
                    if (config.isSafe(operation)) {
                        if (isOverrideOperation) {
                            urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation]({}).then(okCallback, errorCallback);
                        } else {
                            urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation]().then(okCallback, errorCallback);
                        }
                    } else {
                        urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation](request.element).then(okCallback, errorCallback);
                    }
                    return restangularizePromise(deferred.promise, false, filledObject);
                }
                function getFunction(params, headers) {
                    return _.bind(elemFunction, this)("get", undefined, params, undefined, headers);
                }
                function deleteFunction(params, headers) {
                    return _.bind(elemFunction, this)("remove", undefined, params, undefined, headers);
                }
                function putFunction(params, headers) {
                    return _.bind(elemFunction, this)("put", undefined, params, undefined, headers);
                }
                function postFunction(what, elem, params, headers) {
                    return _.bind(elemFunction, this)("post", what, params, elem, headers);
                }
                function headFunction(params, headers) {
                    return _.bind(elemFunction, this)("head", undefined, params, undefined, headers);
                }
                function traceFunction(params, headers) {
                    return _.bind(elemFunction, this)("trace", undefined, params, undefined, headers);
                }
                function optionsFunction(params, headers) {
                    return _.bind(elemFunction, this)("options", undefined, params, undefined, headers);
                }
                function patchFunction(elem, params, headers) {
                    return _.bind(elemFunction, this)("patch", undefined, params, elem, headers);
                }
                function customFunction(operation, path, params, headers, elem) {
                    return _.bind(elemFunction, this)(operation, path, params, elem, headers);
                }
                function addRestangularMethodFunction(name, operation, path, defaultParams, defaultHeaders, defaultElem) {
                    var bindedFunction;
                    if (operation === "getList") {
                        bindedFunction = _.bind(fetchFunction, this, path);
                    } else {
                        bindedFunction = _.bind(customFunction, this, operation, path);
                    }
                    var createdFunction = function(params, headers, elem) {
                        var callParams = _.defaults({
                            params: params,
                            headers: headers,
                            elem: elem
                        }, {
                            params: defaultParams,
                            headers: defaultHeaders,
                            elem: defaultElem
                        });
                        return bindedFunction(callParams.params, callParams.headers, callParams.elem);
                    };
                    if (config.isSafe(operation)) {
                        this[name] = createdFunction;
                    } else {
                        this[name] = function(elem, params, headers) {
                            return createdFunction(params, headers, elem);
                        };
                    }
                }
                function withConfigurationFunction(configurer) {
                    var newConfig = angular.copy(_.omit(config, "configuration"));
                    Configurer.init(newConfig, newConfig);
                    configurer(newConfig);
                    return createServiceForConfiguration(newConfig);
                }
                function toService(route, parent) {
                    var serv = {};
                    var collection = (parent || service).all(route);
                    serv.one = _.bind(one, parent || service, parent, route);
                    serv.post = _.bind(collection.post, collection);
                    serv.getList = _.bind(collection.getList, collection);
                    return serv;
                }
                Configurer.init(service, config);
                service.copy = _.bind(copyRestangularizedElement, service);
                service.service = _.bind(toService, service);
                service.withConfig = _.bind(withConfigurationFunction, service);
                service.one = _.bind(one, service, null);
                service.all = _.bind(all, service, null);
                service.several = _.bind(several, service, null);
                service.oneUrl = _.bind(oneUrl, service, null);
                service.allUrl = _.bind(allUrl, service, null);
                service.stripRestangular = _.bind(stripRestangular, service);
                service.restangularizeElement = _.bind(restangularizeElem, service);
                service.restangularizeCollection = _.bind(restangularizeCollectionAndElements, service);
                return service;
            }
            return createServiceForConfiguration(globalConfiguration);
        } ];
    });
})();

angular.module("Scope.safeApply", []).run([ "$rootScope", function($rootScope) {
    $rootScope.$safeApply = function() {
        var $scope, fn, force = false;
        if (arguments.length == 1) {
            var arg = arguments[0];
            if (typeof arg == "function") {
                fn = arg;
            } else {
                $scope = arg;
            }
        } else {
            $scope = arguments[0];
            fn = arguments[1];
            if (arguments.length == 3) {
                force = !!arguments[2];
            }
        }
        $scope = $scope || this;
        fn = fn || function() {};
        if (force || !$scope.$$phase) {
            $scope.$apply ? $scope.$apply(fn) : $scope.apply(fn);
        } else {
            fn();
        }
    };
} ]);

"use strict";

if (!Number.isInteger) {
    Number.isInteger = function isInteger(nVal) {
        return typeof nVal === "number" && isFinite(nVal) && nVal > -9007199254740992 && nVal < 9007199254740992 && Math.floor(nVal) === nVal;
    };
}

function StringView(vInput, sEncoding, nOffset, nLength) {
    var fTAView, aWhole, aRaw, fPutOutptCode, fGetOutptChrSize, nInptLen, nStartIdx = isFinite(nOffset) ? nOffset : 0, nTranscrType = 15;
    if (sEncoding) {
        this.encoding = sEncoding.toString();
    }
    encSwitch: switch (this.encoding) {
      case "UTF-8":
        fPutOutptCode = StringView.putUTF8CharCode;
        fGetOutptChrSize = StringView.getUTF8CharLength;
        fTAView = Uint8Array;
        break encSwitch;

      case "UTF-16":
        fPutOutptCode = StringView.putUTF16CharCode;
        fGetOutptChrSize = StringView.getUTF16CharLength;
        fTAView = Uint16Array;
        break encSwitch;

      case "UTF-32":
        fTAView = Uint32Array;
        nTranscrType &= 14;
        break encSwitch;

      default:
        fTAView = Uint8Array;
        nTranscrType &= 14;
    }
    typeSwitch: switch (typeof vInput) {
      case "string":
        nTranscrType &= 7;
        break typeSwitch;

      case "object":
        classSwitch: switch (vInput.constructor) {
          case StringView:
            nTranscrType &= 3;
            break typeSwitch;

          case String:
            nTranscrType &= 7;
            break typeSwitch;

          case ArrayBuffer:
            aWhole = new fTAView(vInput);
            nInptLen = this.encoding === "UTF-32" ? vInput.byteLength >>> 2 : this.encoding === "UTF-16" ? vInput.byteLength >>> 1 : vInput.byteLength;
            aRaw = nStartIdx === 0 && (!isFinite(nLength) || nLength === nInptLen) ? aWhole : new fTAView(vInput, nStartIdx, !isFinite(nLength) ? nInptLen - nStartIdx : nLength);
            break typeSwitch;

          case Uint32Array:
          case Uint16Array:
          case Uint8Array:
            fTAView = vInput.constructor;
            nInptLen = vInput.length;
            aWhole = vInput.byteOffset === 0 && vInput.length === (fTAView === Uint32Array ? vInput.buffer.byteLength >>> 2 : fTAView === Uint16Array ? vInput.buffer.byteLength >>> 1 : vInput.buffer.byteLength) ? vInput : new fTAView(vInput.buffer);
            aRaw = nStartIdx === 0 && (!isFinite(nLength) || nLength === nInptLen) ? vInput : vInput.subarray(nStartIdx, isFinite(nLength) ? nStartIdx + nLength : nInptLen);
            break typeSwitch;

          default:
            aWhole = new fTAView(vInput);
            nInptLen = aWhole.length;
            aRaw = nStartIdx === 0 && (!isFinite(nLength) || nLength === nInptLen) ? aWhole : aWhole.subarray(nStartIdx, isFinite(nLength) ? nStartIdx + nLength : nInptLen);
        }
        break typeSwitch;

      default:
        aWhole = aRaw = new fTAView(Number(vInput) || 0);
    }
    if (nTranscrType < 8) {
        var vSource, nOutptLen, nCharStart, nCharEnd, nEndIdx, fGetInptChrSize, fGetInptChrCode;
        if (nTranscrType & 4) {
            vSource = vInput;
            nOutptLen = nInptLen = vSource.length;
            nTranscrType ^= this.encoding === "UTF-32" ? 0 : 2;
            nStartIdx = nCharStart = nOffset ? Math.max((nOutptLen + nOffset) % nOutptLen, 0) : 0;
            nEndIdx = nCharEnd = (Number.isInteger(nLength) ? Math.min(Math.max(nLength, 0) + nStartIdx, nOutptLen) : nOutptLen) - 1;
        } else {
            vSource = vInput.rawData;
            nInptLen = vInput.makeIndex();
            nStartIdx = nCharStart = nOffset ? Math.max((nInptLen + nOffset) % nInptLen, 0) : 0;
            nOutptLen = Number.isInteger(nLength) ? Math.min(Math.max(nLength, 0), nInptLen - nCharStart) : nInptLen;
            nEndIdx = nCharEnd = nOutptLen + nCharStart;
            if (vInput.encoding === "UTF-8") {
                fGetInptChrSize = StringView.getUTF8CharLength;
                fGetInptChrCode = StringView.loadUTF8CharCode;
            } else if (vInput.encoding === "UTF-16") {
                fGetInptChrSize = StringView.getUTF16CharLength;
                fGetInptChrCode = StringView.loadUTF16CharCode;
            } else {
                nTranscrType &= 1;
            }
        }
        if (nOutptLen === 0 || nTranscrType < 4 && vSource.encoding === this.encoding && nCharStart === 0 && nOutptLen === nInptLen) {
            nTranscrType = 7;
        }
        conversionSwitch: switch (nTranscrType) {
          case 0:
            aWhole = new fTAView(nOutptLen);
            for (var nOutptIdx = 0; nOutptIdx < nOutptLen; aWhole[nOutptIdx] = vSource[nStartIdx + nOutptIdx++]) ;
            break conversionSwitch;

          case 1:
            nOutptLen = 0;
            for (var nInptIdx = nStartIdx; nInptIdx < nEndIdx; nInptIdx++) {
                nOutptLen += fGetOutptChrSize(vSource[nInptIdx]);
            }
            aWhole = new fTAView(nOutptLen);
            for (var nInptIdx = nStartIdx, nOutptIdx = 0; nOutptIdx < nOutptLen; nInptIdx++) {
                nOutptIdx = fPutOutptCode(aWhole, vSource[nInptIdx], nOutptIdx);
            }
            break conversionSwitch;

          case 2:
            nStartIdx = 0;
            var nChrCode;
            for (nChrIdx = 0; nChrIdx < nCharStart; nChrIdx++) {
                nChrCode = fGetInptChrCode(vSource, nStartIdx);
                nStartIdx += fGetInptChrSize(nChrCode);
            }
            aWhole = new fTAView(nOutptLen);
            for (var nInptIdx = nStartIdx, nOutptIdx = 0; nOutptIdx < nOutptLen; nInptIdx += fGetInptChrSize(nChrCode), 
            nOutptIdx++) {
                nChrCode = fGetInptChrCode(vSource, nInptIdx);
                aWhole[nOutptIdx] = nChrCode;
            }
            break conversionSwitch;

          case 3:
            nOutptLen = 0;
            var nChrCode;
            for (var nChrIdx = 0, nInptIdx = 0; nChrIdx < nCharEnd; nInptIdx += fGetInptChrSize(nChrCode)) {
                nChrCode = fGetInptChrCode(vSource, nInptIdx);
                if (nChrIdx === nCharStart) {
                    nStartIdx = nInptIdx;
                }
                if (++nChrIdx > nCharStart) {
                    nOutptLen += fGetOutptChrSize(nChrCode);
                }
            }
            aWhole = new fTAView(nOutptLen);
            for (var nInptIdx = nStartIdx, nOutptIdx = 0; nOutptIdx < nOutptLen; nInptIdx += fGetInptChrSize(nChrCode)) {
                nChrCode = fGetInptChrCode(vSource, nInptIdx);
                nOutptIdx = fPutOutptCode(aWhole, nChrCode, nOutptIdx);
            }
            break conversionSwitch;

          case 4:
            aWhole = new fTAView(nOutptLen);
            for (var nIdx = 0; nIdx < nOutptLen; nIdx++) {
                aWhole[nIdx] = vSource.charCodeAt(nIdx) & 255;
            }
            break conversionSwitch;

          case 5:
            nOutptLen = 0;
            for (var nMapIdx = 0; nMapIdx < nInptLen; nMapIdx++) {
                if (nMapIdx === nCharStart) {
                    nStartIdx = nOutptLen;
                }
                nOutptLen += fGetOutptChrSize(vSource.charCodeAt(nMapIdx));
                if (nMapIdx === nCharEnd) {
                    nEndIdx = nOutptLen;
                }
            }
            aWhole = new fTAView(nOutptLen);
            for (var nOutptIdx = 0, nChrIdx = 0; nOutptIdx < nOutptLen; nChrIdx++) {
                nOutptIdx = fPutOutptCode(aWhole, vSource.charCodeAt(nChrIdx), nOutptIdx);
            }
            break conversionSwitch;

          case 6:
            aWhole = new fTAView(nOutptLen);
            for (var nIdx = 0; nIdx < nOutptLen; nIdx++) {
                aWhole[nIdx] = vSource.charCodeAt(nIdx);
            }
            break conversionSwitch;

          case 7:
            aWhole = new fTAView(nOutptLen ? vSource : 0);
            break conversionSwitch;
        }
        aRaw = nTranscrType > 3 && (nStartIdx > 0 || nEndIdx < aWhole.length - 1) ? aWhole.subarray(nStartIdx, nEndIdx) : aWhole;
    }
    this.buffer = aWhole.buffer;
    this.bufferView = aWhole;
    this.rawData = aRaw;
    Object.freeze(this);
}

StringView.loadUTF8CharCode = function(aChars, nIdx) {
    var nLen = aChars.length, nPart = aChars[nIdx];
    return nPart > 251 && nPart < 254 && nIdx + 5 < nLen ? (nPart - 252) * 1073741824 + (aChars[nIdx + 1] - 128 << 24) + (aChars[nIdx + 2] - 128 << 18) + (aChars[nIdx + 3] - 128 << 12) + (aChars[nIdx + 4] - 128 << 6) + aChars[nIdx + 5] - 128 : nPart > 247 && nPart < 252 && nIdx + 4 < nLen ? (nPart - 248 << 24) + (aChars[nIdx + 1] - 128 << 18) + (aChars[nIdx + 2] - 128 << 12) + (aChars[nIdx + 3] - 128 << 6) + aChars[nIdx + 4] - 128 : nPart > 239 && nPart < 248 && nIdx + 3 < nLen ? (nPart - 240 << 18) + (aChars[nIdx + 1] - 128 << 12) + (aChars[nIdx + 2] - 128 << 6) + aChars[nIdx + 3] - 128 : nPart > 223 && nPart < 240 && nIdx + 2 < nLen ? (nPart - 224 << 12) + (aChars[nIdx + 1] - 128 << 6) + aChars[nIdx + 2] - 128 : nPart > 191 && nPart < 224 && nIdx + 1 < nLen ? (nPart - 192 << 6) + aChars[nIdx + 1] - 128 : nPart;
};

StringView.putUTF8CharCode = function(aTarget, nChar, nPutAt) {
    var nIdx = nPutAt;
    if (nChar < 128) {
        aTarget[nIdx++] = nChar;
    } else if (nChar < 2048) {
        aTarget[nIdx++] = 192 + (nChar >>> 6);
        aTarget[nIdx++] = 128 + (nChar & 63);
    } else if (nChar < 65536) {
        aTarget[nIdx++] = 224 + (nChar >>> 12);
        aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
        aTarget[nIdx++] = 128 + (nChar & 63);
    } else if (nChar < 2097152) {
        aTarget[nIdx++] = 240 + (nChar >>> 18);
        aTarget[nIdx++] = 128 + (nChar >>> 12 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
        aTarget[nIdx++] = 128 + (nChar & 63);
    } else if (nChar < 67108864) {
        aTarget[nIdx++] = 248 + (nChar >>> 24);
        aTarget[nIdx++] = 128 + (nChar >>> 18 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 12 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
        aTarget[nIdx++] = 128 + (nChar & 63);
    } else {
        aTarget[nIdx++] = 252 + nChar / 1073741824;
        aTarget[nIdx++] = 128 + (nChar >>> 24 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 18 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 12 & 63);
        aTarget[nIdx++] = 128 + (nChar >>> 6 & 63);
        aTarget[nIdx++] = 128 + (nChar & 63);
    }
    return nIdx;
};

StringView.getUTF8CharLength = function(nChar) {
    return nChar < 128 ? 1 : nChar < 2048 ? 2 : nChar < 65536 ? 3 : nChar < 2097152 ? 4 : nChar < 67108864 ? 5 : 6;
};

StringView.loadUTF16CharCode = function(aChars, nIdx) {
    var nFrstChr = aChars[nIdx];
    return nFrstChr > 55231 && nIdx + 1 < aChars.length ? (nFrstChr - 55296 << 10) + aChars[nIdx + 1] + 9216 : nFrstChr;
};

StringView.putUTF16CharCode = function(aTarget, nChar, nPutAt) {
    var nIdx = nPutAt;
    if (nChar < 65536) {
        aTarget[nIdx++] = nChar;
    } else {
        aTarget[nIdx++] = 55232 + (nChar >>> 10);
        aTarget[nIdx++] = 56320 + (nChar & 1023);
    }
    return nIdx;
};

StringView.getUTF16CharLength = function(nChar) {
    return nChar < 65536 ? 1 : 2;
};

StringView.b64ToUint6 = function(nChr) {
    return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
};

StringView.uint6ToB64 = function(nUint6) {
    return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;
};

StringView.bytesToBase64 = function(aBytes) {
    var sB64Enc = "";
    for (var nMod3, nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
        nMod3 = nIdx % 3;
        if (nIdx > 0 && nIdx * 4 / 3 % 76 === 0) {
            sB64Enc += "\r\n";
        }
        nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
        if (nMod3 === 2 || aBytes.length - nIdx === 1) {
            sB64Enc += String.fromCharCode(StringView.uint6ToB64(nUint24 >>> 18 & 63), StringView.uint6ToB64(nUint24 >>> 12 & 63), StringView.uint6ToB64(nUint24 >>> 6 & 63), StringView.uint6ToB64(nUint24 & 63));
            nUint24 = 0;
        }
    }
    return sB64Enc.replace(/A(?=A$|$)/g, "=");
};

StringView.base64ToBytes = function(sBase64, nBlockBytes) {
    var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""), nInLen = sB64Enc.length, nOutLen = nBlockBytes ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockBytes) * nBlockBytes : nInLen * 3 + 1 >>> 2, aBytes = new Uint8Array(nOutLen);
    for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= StringView.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
            for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
                aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
            }
            nUint24 = 0;
        }
    }
    return aBytes;
};

StringView.makeFromBase64 = function(sB64Inpt, sEncoding, nByteOffset, nLength) {
    return new StringView(sEncoding === "UTF-16" || sEncoding === "UTF-32" ? StringView.base64ToBytes(sB64Inpt, sEncoding === "UTF-16" ? 2 : 4).buffer : StringView.base64ToBytes(sB64Inpt), sEncoding, nByteOffset, nLength);
};

StringView.prototype.encoding = "UTF-8";

StringView.prototype.makeIndex = function(nChrLength, nStartFrom) {
    var aTarget = this.rawData, nChrEnd, nRawLength = aTarget.length, nStartIdx = nStartFrom || 0, nIdxEnd = nStartIdx, nStopAtChr = isNaN(nChrLength) ? Infinity : nChrLength;
    if (nChrLength + 1 > aTarget.length) {
        throw new RangeError("StringView.prototype.makeIndex - The offset can't be major than the length of the array - 1.");
    }
    switch (this.encoding) {
      case "UTF-8":
        var nPart;
        for (nChrEnd = 0; nIdxEnd < nRawLength && nChrEnd < nStopAtChr; nChrEnd++) {
            nPart = aTarget[nIdxEnd];
            nIdxEnd += nPart > 251 && nPart < 254 && nIdxEnd + 5 < nRawLength ? 6 : nPart > 247 && nPart < 252 && nIdxEnd + 4 < nRawLength ? 5 : nPart > 239 && nPart < 248 && nIdxEnd + 3 < nRawLength ? 4 : nPart > 223 && nPart < 240 && nIdxEnd + 2 < nRawLength ? 3 : nPart > 191 && nPart < 224 && nIdxEnd + 1 < nRawLength ? 2 : 1;
        }
        break;

      case "UTF-16":
        for (nChrEnd = nStartIdx; nIdxEnd < nRawLength && nChrEnd < nStopAtChr; nChrEnd++) {
            nIdxEnd += aTarget[nIdxEnd] > 55231 && nIdxEnd + 1 < aTarget.length ? 2 : 1;
        }
        break;

      default:
        nIdxEnd = nChrEnd = isFinite(nChrLength) ? nChrLength : nRawLength - 1;
    }
    if (nChrLength) {
        return nIdxEnd;
    }
    return nChrEnd;
};

StringView.prototype.toBase64 = function(bWholeBuffer) {
    return StringView.bytesToBase64(bWholeBuffer ? this.bufferView.constructor === Uint8Array ? this.bufferView : new Uint8Array(this.buffer) : this.rawData.constructor === Uint8Array ? this.rawData : new Uint8Array(this.buffer, this.rawData.byteOffset, this.rawData.length << (this.rawData.constructor === Uint16Array ? 1 : 2)));
};

StringView.prototype.subview = function(nCharOffset, nCharLength) {
    var nChrLen, nCharStart, nStrLen, bVariableLen = this.encoding === "UTF-8" || this.encoding === "UTF-16", nStartOffset = nCharOffset, nStringLength, nRawLen = this.rawData.length;
    if (nRawLen === 0) {
        return new StringView(this.buffer, this.encoding);
    }
    nStringLength = bVariableLen ? this.makeIndex() : nRawLen;
    nCharStart = nCharOffset ? Math.max((nStringLength + nCharOffset) % nStringLength, 0) : 0;
    nStrLen = Number.isInteger(nCharLength) ? Math.max(nCharLength, 0) + nCharStart > nStringLength ? nStringLength - nCharStart : nCharLength : nStringLength;
    if (nCharStart === 0 && nStrLen === nStringLength) {
        return this;
    }
    if (bVariableLen) {
        nStartOffset = this.makeIndex(nCharStart);
        nChrLen = this.makeIndex(nStrLen, nStartOffset) - nStartOffset;
    } else {
        nStartOffset = nCharStart;
        nChrLen = nStrLen - nCharStart;
    }
    if (this.encoding === "UTF-16") {
        nStartOffset <<= 1;
    } else if (this.encoding === "UTF-32") {
        nStartOffset <<= 2;
    }
    return new StringView(this.buffer, this.encoding, nStartOffset, nChrLen);
};

StringView.prototype.forEachChar = function(fCallback, oThat, nChrOffset, nChrLen) {
    var aSource = this.rawData, nRawEnd, nRawIdx;
    if (this.encoding === "UTF-8" || this.encoding === "UTF-16") {
        var fGetInptChrSize, fGetInptChrCode;
        if (this.encoding === "UTF-8") {
            fGetInptChrSize = StringView.getUTF8CharLength;
            fGetInptChrCode = StringView.loadUTF8CharCode;
        } else if (this.encoding === "UTF-16") {
            fGetInptChrSize = StringView.getUTF16CharLength;
            fGetInptChrCode = StringView.loadUTF16CharCode;
        }
        nRawIdx = isFinite(nChrOffset) ? this.makeIndex(nChrOffset) : 0;
        nRawEnd = isFinite(nChrLen) ? this.makeIndex(nChrLen, nRawIdx) : aSource.length;
        for (var nChrCode, nChrIdx = 0; nRawIdx < nRawEnd; nChrIdx++) {
            nChrCode = fGetInptChrCode(aSource, nRawIdx);
            fCallback.call(oThat || null, nChrCode, nChrIdx, nRawIdx, aSource);
            nRawIdx += fGetInptChrSize(nChrCode);
        }
    } else {
        nRawIdx = isFinite(nChrOffset) ? nChrOffset : 0;
        nRawEnd = isFinite(nChrLen) ? nChrLen + nRawIdx : aSource.length;
        for (nRawIdx; nRawIdx < nRawEnd; nRawIdx++) {
            fCallback.call(oThat || null, aSource[nRawIdx], nRawIdx, nRawIdx, aSource);
        }
    }
};

StringView.prototype.valueOf = StringView.prototype.toString = function() {
    if (this.encoding !== "UTF-8" && this.encoding !== "UTF-16") {
        return String.fromCharCode.apply(null, this.rawData);
    }
    var fGetCode, fGetIncr, sView = "";
    if (this.encoding === "UTF-8") {
        fGetIncr = StringView.getUTF8CharLength;
        fGetCode = StringView.loadUTF8CharCode;
    } else if (this.encoding === "UTF-16") {
        fGetIncr = StringView.getUTF16CharLength;
        fGetCode = StringView.loadUTF16CharCode;
    }
    for (var nChr, nLen = this.rawData.length, nIdx = 0; nIdx < nLen; nIdx += fGetIncr(nChr)) {
        nChr = fGetCode(this.rawData, nIdx);
        sView += String.fromCharCode(nChr);
    }
    return sView;
};

angular.module("ngForce", [ "Scope.safeApply", "restangular", "multipart", "ngForce.config" ]);

(function(window, document, undefined) {
    "use strict";
    angular.module("ngForce", []).factory("Backbone", [ "$http", "vfr", "$q", function($http, vfr, $q) {
        var methodMap, sync, ajax, buildQueryString, isUndefined = _.isUndefined;
        methodMap = {
            create: "POST",
            update: "PUT",
            patch: "PATCH",
            "delete": "DELETE",
            read: "GET"
        };
        sync = function(method, model, options) {
            var xhr;
            var single = true;
            if (_.has(model, "models")) {
                single = false;
            }
            if (isUndefined(options)) {
                options = {};
            }
            var httpMethod = options.method || methodMap[method], params = {
                method: httpMethod
            };
            if (!options.url) {
                params.url = _.result(model, "url");
            }
            if (isUndefined(options.data) && model && (httpMethod === "POST" || httpMethod === "PUT" || httpMethod === "PATCH")) {
                params.data = JSON.stringify(options.attrs || model.toJSON(options));
            }
            if (httpMethod === "GET" && !isUndefined(options.data)) {
                params.params = options.data;
            }
            if (httpMethod === "GET") {
                params.query = _.result(model, "getQueryString");
                xhr = vfr.query(params.query).then(function(results) {
                    if (!isUndefined(options.success) && _.isFunction(options.success)) {
                        options.success(single ? results.records[0] : results.records);
                        if (options.def) {
                            options.def.resolve(result.records);
                        }
                    }
                }).catch(function(err) {
                    options.error(err);
                    if (options.def) {
                        options.def.reject(err);
                    }
                }).finally(function() {});
            }
            if (httpMethod === "DELETE") {
                if (_.has(model, "models")) {} else {
                    if (!model.objectType) {
                        throw new Error("No object");
                    }
                    xhr = vfr.del(model.objectType, model.get(model.idAttribute)).then(function(response) {
                        options.success(response);
                        return response;
                    }).catch(function(err) {
                        options.error(err);
                        return err;
                    });
                }
            }
            if (httpMethod === "PUT" || httpMethod === "POST") {
                var models = [];
                if (!single) {
                    model.each(function(m) {
                        models.push(m.getWritableFields());
                    });
                } else {
                    models = [ model.getWritableFields() ];
                }
                if (!models || models.length < 1) {
                    options.error("No Models to Save");
                    return $q.reject("No models to save");
                }
                models = JSON.stringify(models);
                var objType = model.objectType || model.name;
                xhr = vfr.bulkUpsert(objType, models).then(function(results) {
                    options.success(single ? results.updated[0] : results.updated);
                    return results;
                }).catch(function(err) {
                    options.error(err);
                    return err;
                });
            }
            model.trigger("request", model, xhr, _.extend(params, options));
            return xhr;
        };
        ajax = function() {
            return $http.apply($http, arguments);
        };
        buildQueryString = function(model, depth, parentField) {
            var qstring = "";
            var depth = depth || 0;
            if (depth != 0) {
                qstring += "( ";
            }
            qstring += "SELECT ";
            for (var i = 0; i < model.fields.length; i++) {
                var field = model.fields[i];
                if (!field.relationship) {
                    qstring += field.name;
                } else {
                    qstring += buildQueryString(field.collection.prototype.model.prototype, depth + 1, field);
                }
                if (i < model.fields.length - 1) {
                    qstring += ", ";
                }
            }
            qstring += parentField ? " FROM " + parentField.name : " FROM " + model.objectType;
            if (model.orderby && model.orderby.field) {
                model.orderby.direction = model.orderby.direction || "ASC";
                qstring += " ORDER BY " + model.orderby.field + " " + model.orderby.direction;
            }
            if (depth != 0) {
                qstring += ")";
            }
            if (model.filters && model.filters.length > 0) {
                qstring += " WHERE ";
                for (var j = 0; j < model.filters.length; j++) {
                    var filter = model.filters[j];
                    var criteria;
                    if (filter.criteria.indexOf("=") > -1) {
                        criteria = _.clone(filter.criteria).replace("=", "");
                        criteria = model.attributes[criteria];
                    }
                    qstring += filter.name + filter.operator + "'" + criteria + "'";
                }
            }
            return qstring;
        };
        return _.extend(Backbone, {
            sync: sync,
            ajax: ajax,
            buildQueryString: buildQueryString
        });
    } ]).factory("NgBackboneModel", [ "$rootScope", "Backbone", function($rootScope, Backbone) {
        var defineProperty;
        defineProperty = function(key) {
            var self = this;
            Object.defineProperty(this.$attributes, key, {
                enumerable: true,
                configurable: true,
                get: function() {
                    return self.get(key);
                },
                set: function(newValue) {
                    self.set(key, newValue);
                }
            });
        };
        return Backbone.Model.extend({
            url: "noop",
            idAttribute: "Id",
            fields: [ {
                name: "Id"
            } ],
            objectType: "Account",
            getQueryString: function() {
                var queryString = Backbone.buildQueryString(this);
                return queryString;
            },
            constructor: function NgBackboneModel() {
                this.$status = {
                    deleting: false,
                    loading: false,
                    saving: false,
                    syncing: false
                };
                this.on("request", function(model, xhr, options) {
                    this.$setStatus({
                        deleting: options.method === "DELETE",
                        loading: options.method === "GET",
                        saving: options.method === "POST" || options.method === "PUT",
                        syncing: true
                    });
                });
                this.on("sync error", this.$resetStatus);
                return Backbone.Model.apply(this, arguments);
            },
            initialize: function(options) {
                var model = this;
                if (model.fields) {
                    _.each(model.fields, function(field) {
                        if (!model.has(field.name)) {
                            model.set(field.name, null);
                        }
                    });
                }
                return Backbone.Model.prototype.initialize.apply(this, arguments);
            },
            parse: function(response, options) {
                if (response) {
                    var self = this;
                    var newprops;
                    _.map(this.fields, function(field, index) {
                        if (field.relationship && field.relationship === "OneToMany") {
                            var recordset = response[field.name];
                            if (recordset) {
                                response[field.name] = new field.collection(recordset.records);
                            } else if (!_.has(self.attributes, field.name)) {
                                response[field.name] = new field.collection([]);
                            }
                        }
                    });
                }
                return response;
            },
            set: function(key, val, options) {
                var output = Backbone.Model.prototype.set.apply(this, arguments);
                if (output) {
                    this.$setBinding(key, val, options);
                }
                return output;
            },
            $resetStatus: function() {
                return this.$setStatus({
                    deleting: false,
                    loading: false,
                    saving: false,
                    syncing: false
                });
            },
            $setBinding: function(key, val, options) {
                var attr, attrs, unset;
                if (_.isUndefined(key)) {
                    return this;
                }
                if (_.isObject(key)) {
                    attrs = key;
                    options = val;
                } else {
                    (attrs = {})[key] = val;
                }
                options = options || {};
                if (_.isUndefined(this.$attributes)) {
                    this.$attributes = {};
                }
                unset = options.unset;
                for (attr in attrs) {
                    if (unset && this.$attributes.hasOwnProperty(attr)) {
                        delete this.$attributes[attr];
                    } else if (!unset && !this.$attributes[attr]) {
                        defineProperty.call(this, attr);
                    }
                }
                return this;
            },
            $setStatus: function(key, value, options) {
                var attr, attrs;
                if (_.isUndefined(key)) {
                    return this;
                }
                if (_.isObject(key)) {
                    attrs = key;
                    options = value;
                } else {
                    (attrs = {})[key] = value;
                }
                options = options || {};
                for (attr in this.$status) {
                    if (attrs.hasOwnProperty(attr) && _.isBoolean(attrs[attr])) {
                        this.$status[attr] = attrs[attr];
                    }
                }
            },
            $removeBinding: function(attr, options) {
                return this.$setBinding(attr, void 0, _.extend({}, options, {
                    unset: true
                }));
            },
            getWritableFields: function() {
                var self = this;
                return _.pick(_.omit(self.attributes, "attributes"), function(field, key) {
                    var fieldDef = _.findWhere(self.fields, {
                        name: key
                    });
                    if (fieldDef && !fieldDef.relationship) {
                        return true;
                    }
                });
            }
        });
    } ]).factory("NgBackboneCollection", [ "Backbone", "NgBackboneModel", function(Backbone, NgBackboneModel) {
        return Backbone.Collection.extend({
            model: NgBackboneModel,
            url: "noop",
            getQueryString: function() {
                var querystring = "";
                querystring = Backbone.buildQueryString(this.model.prototype);
                console.log(querystring);
                return querystring;
            },
            constructor: function NgBackboneCollection() {
                var self = this;
                this.$status = {
                    deleting: false,
                    loading: false,
                    saving: false,
                    syncing: false
                };
                this.on("request", function(model, xhr, options) {
                    this.$setStatus({
                        deleting: options.method === "DELETE",
                        loading: options.method === "GET",
                        saving: options.method === "POST" || options.method === "PUT",
                        syncing: true
                    });
                });
                this.on("sync error", this.$resetStatus);
                this.on("destroy", this.$resetStatus);
                Object.defineProperty(this, "$models", {
                    enumerable: true,
                    get: function() {
                        return self.models;
                    }
                });
                Backbone.Collection.apply(this, arguments);
            },
            $setStatus: function(key, value, options) {
                var attr, attrs;
                if (_.isUndefined(key)) {
                    return this;
                }
                if (_.isObject(key)) {
                    attrs = key;
                    options = value;
                } else {
                    (attrs = {})[key] = value;
                }
                options = options || {};
                for (attr in this.$status) {
                    if (attrs.hasOwnProperty(attr) && _.isBoolean(attrs[attr])) {
                        this.$status[attr] = attrs[attr];
                    }
                }
            },
            $resetStatus: function() {
                return this.$setStatus({
                    deleting: false,
                    loading: false,
                    saving: false,
                    syncing: false
                });
            },
            getChangedModels: function() {
                var changed = [];
                _.each(this.models, function(model) {
                    if (model.hasChanged()) {
                        changed.push(model.getWritableFields());
                    }
                });
                return changed;
            },
            save: function(options) {
                options = _.extend({}, options);
                var collection = this;
                options.success = function(resp) {
                    var models = [];
                    var self = this;
                    _.each(resp, function(record) {
                        models.push(Backbone.Collection.prototype._prepareModel(record));
                    });
                    collection.set(models, {
                        remove: false
                    });
                    collection.trigger("sync", collection, resp, options);
                };
                options.error = function(err) {
                    collection.trigger("error", collection, err, options);
                };
                var xhr = this.sync("update", this, options);
                return xhr;
            }
        });
    } ]);
})(window, document);

angular.module("ngForce").factory("encodeUriQuery", function() {
    function sortedKeys(obj) {
        var keys = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys.sort();
    }
    function forEachSorted(obj, iterator, context) {
        var keys = sortedKeys(obj);
        for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    return encodeUriQuery;
});

angular.module("multipart", []);

angular.module("multipart").service("RequestPart", function() {
    function RequestPart() {
        this.headers = [];
    }
    RequestPart.prototype.setBody = function(body) {
        this.body = body;
        switch (toString.call(body)) {
          case "[object ArrayBuffer]":
            this.bodyType = "arraybuffer";
            break;

          case "[object String]":
            this.bodyType = "string";
            break;

          case "[object Object]":
            this.bodyType = "json";
            break;

          default:
            throw Error("Unsupported multipart body type: " + toString.call(body));
        }
    };
    RequestPart.prototype.addHeader = function(name, value) {
        this.headers.push({
            name: name,
            value: value
        });
    };
    RequestPart.prototype.getRawHeaders = function() {
        var rawHeadersArr = [];
        for (var i = 0; i < this.headers.length; i++) {
            var h = this.headers[i];
            rawHeadersArr.push(h.name + ": " + h.value);
        }
        return rawHeadersArr.join("\n");
    };
    RequestPart.prototype.getBuffer = function() {
        var bufferArr = [];
        var rawHeaders = this.getRawHeaders();
        bufferArr.push(new StringView(rawHeaders).buffer);
        bufferArr.push(new StringView("\n\n").buffer);
        if (this.bodyType === "arraybuffer") {
            bufferArr.push(this.body);
        } else if (this.bodyType === "string") {
            bufferArr.push(new StringView(this.body).buffer);
        } else if (this.bodyType === "json") {
            var jsonStr = JSON.stringify(this.body);
            bufferArr.push(new StringView(jsonStr).buffer);
        }
        return joinBuffers(bufferArr);
    };
    RequestPart.prototype.toString = function() {
        return new StringView(this.getBuffer()).toString();
    };
    function joinBuffers(arrayBuffers) {
        var lengthSum = 0;
        for (var i = 0; i < arrayBuffers.length; i++) {
            lengthSum += arrayBuffers[i].byteLength;
        }
        var joined = new Uint8Array(lengthSum);
        var offset = 0;
        for (var i = 0; i < arrayBuffers.length; i++) {
            var ab = arrayBuffers[i];
            joined.set(new Uint8Array(ab), offset);
            offset += ab.byteLength;
        }
        return joined.buffer;
    }
    return RequestPart;
});

angular.module("multipart").service("MultipartRequest", [ "RequestPart", function(RequestPart) {
    function MultipartRequest(boundaryStr) {
        this.boundaryStr = boundaryStr;
        this.parts = [];
    }
    MultipartRequest.prototype.addPart = function(part) {
        this.parts.push(part);
    };
    MultipartRequest.prototype.getBuffer = function() {
        var bufferArr = [];
        bufferArr.push(new StringView("--" + this.boundaryStr + "\n").buffer);
        for (var i = 0; i < this.parts.length; i++) {
            bufferArr.push(this.parts[i].getBuffer());
            bufferArr.push(new StringView("\n\n").buffer);
            if (i !== this.parts.length - 1) {
                bufferArr.push(new StringView("--" + this.boundaryStr + "\n").buffer);
            }
        }
        bufferArr.push(new StringView("--" + this.boundaryStr + "--").buffer);
        return joinBuffers(bufferArr);
    };
    MultipartRequest.prototype.toString = function() {
        return new StringView(this.getBuffer()).toString();
    };
    function joinBuffers(arrayBuffers) {
        var lengthSum = 0;
        for (var i = 0; i < arrayBuffers.length; i++) {
            lengthSum += arrayBuffers[i].byteLength;
        }
        var joined = new Uint8Array(lengthSum);
        var offset = 0;
        for (var i = 0; i < arrayBuffers.length; i++) {
            var ab = arrayBuffers[i];
            joined.set(new Uint8Array(ab), offset);
            offset += ab.byteLength;
        }
        return joined.buffer;
    }
    return MultipartRequest;
} ]);

angular.module("ngForce").provider("remoteObjects", function() {
    var namespace = "SObjectModel";
    this.setNamespace = function(newNamespace) {
        if (!_.isUndefined(newNamespace)) {
            namespace = newNamespace;
        }
    };
    this.$get = [ "$q", "$log", function($q, $log) {
        var remoteObjects = {
            getPromiseObj: function(obj) {
                var promisedObj = {};
                promisedObj.remoteObj = new namespace[obj]();
                promisedObj.retrieve = function(options) {
                    promisedObj.remoteObj.retrieve(opts, this.handleWithPromise);
                };
                promisedObj.create = function(fvs) {
                    fvs = fvs ? fvs : promisedObj.remoteObj._props;
                    promisedObj.remoteObj.create(fvs, handleWithPromise);
                };
                promisedObj.update = function(ids, fvs) {
                    if (!angular._isArray(ids)) {
                        fvs = ids;
                        ids = null;
                    }
                    ids = ids ? ids : [ promisedObj.remoteObj._props.Id ];
                    fvs = fvs ? fvs : promisedObj.remoteObj._props;
                    promisedObj.remoteObj.update(ids, fvs, handleWithPromise);
                };
                promisedObj.del = function(ids) {
                    ids = ids ? ids : [ promisedObj.remoteObj._props.Id ];
                    promisedObj.remoteObj.del(ids, handleWithPromise);
                };
                handleWithPromise = function(err, records, e) {
                    var deferred = $q.defer();
                    if (err) {
                        deferred.reject(err);
                    } else {
                        if (e) {
                            deferred.resolve(records, e);
                        } else {
                            deferred.resolve(records);
                        }
                    }
                    return deferred.promise;
                };
                return promisedObj;
            }
        };
        return remoteObjects;
    } ];
});

angular.module("ngForce").provider("sfTemplate", function() {
    var scriptSymbolBlacklist = [ ".ajax4jsf.javascript.AjaxScript", "/js/perf/stub.js", "/sfdc/JiffyStubs.js" ];
    this.setScriptSymbolBlacklist = function(newBlacklist) {
        if (angular.isArray(newBlacklist) && newBlacklist.length > 0) {
            scriptSymbolBlacklist = newBlacklist;
        } else {
            throw new Error("newBlacklist must be an array!");
        }
    };
    this.$get = [ "$q", "$http", "$templateCache", "$log", function($q, $http, $templateCache, $log) {
        var escapeRegexp = function(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        };
        var buildScriptRegex = function(scriptNames) {
            var scriptNamesEscaped = _.map(scriptNames, escapeRegexp);
            var scriptNamePatterns = _.map(scriptNamesEscaped, function(s) {
                return ".*" + s + ".*?";
            });
            var scriptNameOptions = "(" + scriptNamePatterns.join("|") + ")";
            var scriptTagPattern = '<script src="' + scriptNameOptions + '"></script>';
            var scriptTagRegex = new RegExp(scriptTagPattern, "gi");
            return scriptTagRegex;
        };
        var stripScriptTags = function(htmlTemplate) {
            var badScriptRegex = buildScriptRegex(scriptSymbolBlacklist);
            var cleanedHtmlTemplate = htmlTemplate.replace(badScriptRegex, "");
            return cleanedHtmlTemplate;
        };
        var sfTemplate = {
            fromVf: function(url) {
                var pTemplate = $http.get(url, {
                    cache: $templateCache
                }).then(function(response) {
                    return response.data;
                }).then(stripScriptTags);
                return pTemplate;
            }
        };
        return sfTemplate;
    } ];
});

angular.module("ngForce").factory("sfr", [ "$q", "$rootScope", "Restangular", "$log", function($q, $rootScope, Restangular, $log, ngForceConfig) {
    var sobjectEndpoints = [];
    var recordEndpoints = [];
    var sfRest = {
        model: function(modelName, recordId) {
            var baseResource = Restangular.setDefaultHeaders({
                Authorization: "Bearer " + ngForceConfig.sessionId
            }).setBaseUrl("/services/data/v29.0/sobjects/").setRestangularFields({
                id: "Id",
                selfLink: "attributes.url"
            });
            var resource;
            if (recordId) resource = baseResource.one(modelName, recordId); else resource = baseResource.all(modelName);
            return resource;
        },
        insert: function(sObjectName, recordToInsert, getLatest) {
            var $defer = $q.defer();
            if (!angular.isString(sObjectName)) {
                $defer.reject("An sObject name is required to perform insert.");
                return $defer.promise;
            }
            var _getLatest = angular.isDefined(getLatest) ? getLatest : false;
            var sObjectEndpoint = sobjectEndpoints[sObjectName];
            if (angular.isUndefined(sObjectEndpoint)) {
                sObjectEndpoint = this.model(sObjectName);
                sobjectEndpoints[sObjectName] = sObjectEndpoint;
            }
            return sObjectEndpoint.post(recordToInsert).then(function(response) {
                if (response.success) {
                    $log.debug("ngForce: Created new " + sObjectName + " record:", response);
                    $defer.resolve(response);
                    if (!_getLatest) {
                        return $defer.promise;
                    }
                    return sObjectEndpoint.get(response.id).then(function(newRecord) {
                        $log.debug("ngForce: Inserted:", newRecord);
                        return newRecord;
                    });
                } else {
                    $defer.reject("Insert failed: [" + response.errors + "] Full response: " + response);
                }
                return $defer.promise;
            });
        },
        update: function(sObjectName, recordToUpdate, getLatest) {
            var $defer = $q.defer();
            if (!angular.isString(sObjectName)) {
                $defer.reject("An sObject name is required to perform an update.");
                return $defer.promise;
            }
            var _getLatest = angular.isDefined(getLatest) ? getLatest : false;
            var recordId = recordToUpdate.id || recordToUpdate.Id;
            if (!angular.isString(recordId)) {
                $defer.reject('An "Id" field is required to perform an update.');
                return $defer.promise;
            }
            var recordEndpoint = recordEndpoints[recordId];
            if (angular.isUndefined(recordEndpoint)) {
                recordEndpoint = this.model(sObjectName, recordId);
                recordEndpoints[recordId] = recordEndpoint;
            }
            var propsToIgnore = [ "Id", "LastReferencedDate", "LastModifiedById", "LastModifiedDate", "LastViewedDate", "SystemModstamp", "CreatedById", "CreatedDate", "IsDeleted" ];
            for (var i = 0; i < propsToIgnore.length; i++) {
                var p = propsToIgnore[i];
                delete recordToUpdate[p];
            }
            return recordEndpoint.patch(recordToUpdate).then(function(response) {
                $log.debug("ngForce: Patched " + sObjectName + " record:", recordToUpdate);
                if (!_getLatest) {
                    $defer.resolve("Patch successful!");
                    return $defer.promise;
                }
                return recordEndpoint.get().then(function(newRecord) {
                    $log.debug("ngForce: Updated " + sObjectName + " record:", response);
                    return newRecord;
                });
            });
        },
        "delete": function(sObjectName, recordToDelete) {
            var $defer = $q.defer();
            if (!angular.isString(sObjectName)) {
                $defer.reject("An sObject name is required to perform a delete.");
                return $defer.promise;
            }
            var recordId = recordToDelete.id || recordToDelete.Id;
            if (!angular.isString(recordId)) {
                $defer.reject('An "Id" field is required to perform a delete.');
                return $defer.promise;
            }
            var recordEndpoint = recordEndpoints[recordId];
            if (angular.isUndefined(recordEndpoint)) {
                recordEndpoint = this.model(sObjectName, recordId);
                recordEndpoints[recordId] = recordEndpoint;
            }
            return recordEndpoint.remove().then(function(response, err) {
                $log.debug("ngForce: Deleted " + sObjectName + " record:", recordId);
                $defer.resolve("Delete successful!");
                return $defer.promise;
            });
        }
    };
    return sfRest;
} ]);

"use strict";

angular.module("ngForce").factory("sfranalytics", [ "$q", "$rootScope", "Restangular", function($q, $rootScope, Restangular, ngForceConfig) {
    var _baseUrl = "/services/data/v29.0/analytics/";
    var _additionalHeaders = {
        Authorization: "Bearer " + ngForceConfig.sessionId
    };
    var _analytics = Restangular.withConfig(function(RestangularConfigurer) {
        RestangularConfigurer.setBaseUrl(_baseUrl);
        RestangularConfigurer.setDefaultHeaders(_additionalHeaders);
    }).setRestangularFields({
        id: "Id"
    });
    return {
        analytics: function() {
            return _analytics.all("reports");
        },
        reports: {
            metadata: function(reportId) {
                return _analytics.one("reports", reportId).get("metadata");
            },
            run: function(reportId, config) {
                if (typeof config !== "object") {
                    config = {};
                }
                if (config.async === true) {
                    throw "Asnynchronous report runs are not supported at this time";
                }
                var queryParams = {};
                if (config.includeDetails === true || config.includeDetails === false) {
                    queryParams.includeDetails = config.includeDetails;
                }
                var ondemandFiltering = config.reportFilters && config.reportFilters.length > 0;
                if (ondemandFiltering === true) {
                    var deferred = $q.defer();
                    this.metadata(reportId).then(function(response) {
                        var metadata = response.reportMetadata;
                        if (typeof config.reportBooleanFilter === "string" || config.reportBooleanFilter === null) {
                            metadata.reportBooleanFilter = config.reportBooleanFilter;
                        }
                        if (Object.prototype.toString.call(config.reportFilters) === "[object Array]") {
                            metadata.reportFilters = config.reportFilters;
                        }
                        _analytics.one("reports").post(reportId, {
                            reportMetadata: metadata
                        }, queryParams).then(function(response) {
                            deferred.resolve(response);
                        }, function(errorResponse) {
                            deferred.reject(errorResponse);
                        });
                    });
                    return deferred.promise;
                } else {
                    return _analytics.one("reports", reportId).get(queryParams);
                }
            }
        },
        dashboard: {}
    };
} ]);

angular.module("ngForce").factory("sfrBackend", [ "$q", "$rootScope", "$log", "$httpBackend", "encodeUriQuery", function($q, $rootScope, $log, $httpBackend, encodeUriQuery) {
    var escapeRegexp = function(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    };
    var sfrBackend = {
        whenGetPage: function(pageName, responsePage) {
            var _pageName = pageName;
            if (_pageName.indexOf("/apex/") == -1) {
                _pageName = "/apex/" + _pageName;
            }
            var escapedPageName = escapeRegexp(_pageName);
            $httpBackend.whenGET(new RegExp(escapedPageName, "i")).respond(responsePage);
        },
        whenQuery: function(sObjectName, resRecords, soqlClauses) {
            var _soqlClauses = angular.isString(soqlClauses) ? [ soqlClauses ] : soqlClauses;
            var _resRecords = !angular.isArray(resRecords) ? [ resRecords ] : resRecords;
            var encodedSoqlRegex = "query.*FROM\\++" + sObjectName;
            if (typeof _soqlClauses != "undefined" && _soqlClauses !== null) {
                var encodedSoqlClauses = _.chain(_soqlClauses).map(function(value, key) {
                    return encodeUriQuery(value);
                }).foldl(function(memo, value) {
                    return memo += value;
                }).value();
                encodedSoqlRegex += "\\++WHERE.*" + escapeRegexp(encodedSoqlClauses);
            }
            $httpBackend.whenGET(new RegExp(encodedSoqlRegex, "i")).respond(200, {
                totalSize: _resRecords.length,
                done: true,
                records: _resRecords
            });
        },
        expectQuery: function(sObjectName, resRecords, soqlClauses) {
            var _soqlClauses = angular.isString(soqlClauses) ? [ soqlClauses ] : soqlClauses;
            var _resRecords = !angular.isArray(resRecords) ? [ resRecords ] : resRecords;
            var encodedSoqlRegex = "query.*FROM\\++" + sObjectName;
            if (typeof _soqlClauses != "undefined" && _soqlClauses !== null) {
                var encodedSoqlClauses = _.chain(_soqlClauses).map(function(value, key) {
                    return encodeUriQuery(value);
                }).foldl(function(memo, value) {
                    return memo += value;
                }).value();
                encodedSoqlRegex += "\\++WHERE.*" + escapeRegexp(encodedSoqlClauses);
            }
            $httpBackend.expectGET(new RegExp(encodedSoqlRegex, "i")).respond(200, {
                totalSize: _resRecords.length,
                done: true,
                records: _resRecords
            });
        },
        expectInsert: function(sObjectName, resRecords, getLatest) {
            var _resRecords = !angular.isArray(resRecords) ? [ resRecords ] : resRecords;
            var _getLatest = getLatest || true;
            angular.forEach(_resRecords, function(resRecord, key) {
                $httpBackend.expectPOST(new RegExp(sObjectName, "i")).respond(201, {
                    id: resRecord.Id,
                    success: true,
                    errors: []
                });
                if (!_getLatest) {
                    $httpBackend.expectGET(new RegExp(sObjectName + "/" + resRecord.Id, "i")).respond(200, resRecord);
                }
            });
        },
        expectDelete: function(sObjectName, recordIds) {
            recordIds = recordIds || "";
            var _recordIds = !angular.isArray(recordIds) ? [ recordIds ] : recordIds;
            angular.forEach(_recordIds, function(recordId) {
                $httpBackend.expectDELETE(new RegExp(sObjectName + "/" + recordId, "i")).respond(201, {});
            });
        }
    };
    return sfrBackend;
} ]);

angular.module("ngForce").factory("sfrfile", [ "$q", "$rootScope", "$log", "Restangular", "MultipartRequest", "RequestPart", "ngForceConfig", function($q, $rootScope, $log, Restangular, MultipartRequest, RequestPart, ngForceConfig) {
    var sfrfile = Restangular.withConfig(function(RestangularConfigurer) {
        RestangularConfigurer.setDefaultHttpFields({
            cache: false,
            transformRequest: function(data) {
                return data;
            }
        });
        RestangularConfigurer.setBaseUrl("/services/data/v29.0/sobjects");
        RestangularConfigurer.setDefaultHeaders({
            Authorization: "Bearer " + ngForceConfig.sessionId
        });
    }).setRestangularFields({
        id: "Id",
        selfLink: "attributes.url"
    });
    sfrfile.insert = function(sObjectName, sObjectData, filename, fileBuffer) {
        SObjectType = {
            Document: {
                jsonPartName: "entity_document",
                binaryPartName: "Body"
            },
            Attachment: {
                jsonPartName: "entity_attachment",
                binaryPartName: "Body"
            },
            ContentVersion: {
                jsonPartName: "entity_content",
                binaryPartName: "VersionData"
            }
        };
        var mySObjectType = SObjectType[sObjectName];
        if (typeof mySObjectType === undefined) {
            throw new Error("Upload not supported for SObject type '" + sObjectName + "'");
        }
        var binaryNameAttr;
        var boundaryStr = "boundary_string";
        var req = new MultipartRequest(boundaryStr);
        var sobjectDataPart = new RequestPart();
        sobjectDataPart.addHeader("Content-Disposition", 'form-data; name="' + mySObjectType.jsonPartName + '";');
        sobjectDataPart.addHeader("Content-Type", "application/json");
        sobjectDataPart.setBody(sObjectData);
        req.addPart(sobjectDataPart);
        var filePart = new RequestPart();
        filePart.addHeader("Content-Type", "application/octet-stream");
        filePart.addHeader("Content-Disposition", 'form-data; name="' + mySObjectType.binaryPartName + '"; filename="' + filename + '"');
        filePart.setBody(fileBuffer);
        req.addPart(filePart);
        var bufferView = new Uint8Array(req.getBuffer());
        return sfrfile.all(sObjectName).post(bufferView, null, {
            "Content-Type": 'multipart/form-data; boundary="' + boundaryStr + '"'
        }).then(function(response) {
            return response;
        });
    };
    return sfrfile;
} ]);

angular.module("ngForce").factory("sfrquery", [ "$q", "$rootScope", "$log", "Restangular", "encodeUriQuery", "ngForceConfig", function($q, $rootScope, $log, Restangular, encodeUriQuery, ngForceConfig) {
    var sfrquery = Restangular.withConfig(function(RestangularConfigurer) {
        RestangularConfigurer.setDefaultHttpFields({
            cache: false
        });
        RestangularConfigurer.setBaseUrl("/services/data/v30.0/");
        RestangularConfigurer.setDefaultHeaders({
            Authorization: "Bearer " + ngForceConfig.sessionId
        });
    }).setRestangularFields({
        id: "Id",
        selfLink: "attributes.url"
    }).oneUrl("query", "/services/data/v30.0/query");
    sfrquery.query = function(query, cacheEnabled) {
        cacheEnabled = typeof cacheEnabled !== "undefined" ? cacheEnabled : false;
        return sfrquery.withHttpConfig({
            cache: cacheEnabled
        }).get({
            q: query
        }).then(function(response) {
            return response.records;
        });
    };
    sfrquery.queryAll = function(queryStringOrQueryLocator, cacheEnabled, deferred, results) {
        if (angular.isUndefined(cacheEnabled)) {
            cacheEnabled = true;
        }
        if (angular.isUndefined(results)) {
            results = [];
        }
        if (angular.isUndefined(deferred)) {
            deferred = $q.defer();
        }
        if (queryStringOrQueryLocator.trim().substring(0, 6).toLowerCase() === "select") {
            queryStringOrQueryLocator = "?q=" + encodeUriQuery(queryStringOrQueryLocator);
        }
        sfrquery.withHttpConfig({
            cache: cacheEnabled
        }).customGET(queryStringOrQueryLocator).then(function(data) {
            results = results.concat(data.records);
            if (!data.done) {
                sfrquery.queryAll(_.last(data.nextRecordsUrl.split("/")), cacheEnabled, deferred, results);
            } else {
                deferred.resolve(results);
                return deferred.promise;
            }
        }, function(error) {
            return deferred.reject(error);
        });
        deferred.notify();
        return deferred.promise;
    };
    return sfrquery;
} ]);

angular.module("ngForce").provider("vfr", function() {
    if (typeof Visualforce != "object") {
        throw new Error("Visualforce is not available as an object! Did you forget to include the ngForce component?");
    }
    var vfRemote = {};
    var standardOpts = {
        escape: false,
        timeout: 1e4
    };
    return {
        setStandardOptions: function(newOptions) {
            if (newOptions && typeof newOptions !== "object") {
                throw new Error("standardOptions must be an object");
            }
            standardOpts = newOptions;
        },
        $get: [ "$q", "$rootScope", function($q, $rootScope) {
            function send(remoteAction, options, nullok) {
                var namespace, controller, method;
                var Manager = Visualforce.remoting.Manager;
                var parts = remoteAction.split(".");
                if (options && typeof options !== "object") {
                    throw new Error("Options must be an object");
                }
                if (parts.length < 2) {
                    throw new Error("Invalid Remote Action specified. Use Controller.MethodName or $RemoteAction.Controller.MethodName");
                } else {
                    if (parts.length === 3) {
                        namespace = parts[0];
                        controller = parts[1];
                        method = parts[2];
                    } else if (parts.length === 2) {
                        controller = parts[0];
                        method = parts[1];
                    }
                }
                return function() {
                    var deferred = $q.defer();
                    var args;
                    if (arguments.length) {
                        args = Array.prototype.slice.apply(arguments);
                    } else {
                        args = [];
                    }
                    args.splice(0, 0, remoteAction);
                    args.push(function(result, event) {
                        handleResultWithPromise(result, event, nullok, deferred);
                    });
                    if (options) {
                        args.push(options);
                    }
                    Manager.invokeAction.apply(Manager, args);
                    return deferred.promise;
                };
            }
            function handleResultWithPromise(result, event, nullok, deferred) {
                if (result) {
                    if (typeof result !== "object") {
                        try {
                            result = JSON.parse(result);
                        } catch (e) {
                            deferred.reject(e.message);
                        }
                    }
                    if (Array.isArray(result) && result.length !== 0 && result[0].message && result[0].errorCode) {
                        deferred.reject(result);
                        $rootScope.$safeApply();
                    } else {
                        deferred.resolve(result);
                        $rootScope.$safeApply();
                    }
                } else if (event && event.status === false) {
                    deferred.reject({
                        message: event.message,
                        method: event.method,
                        where: event.where,
                        errorCode: event.type === "exception" ? "EXCEPTION" : "UNSPECIFIED_ERROR"
                    });
                    $rootScope.$safeApply();
                } else if (typeof nullok !== "undefined" && nullok) {
                    deferred.resolve();
                    $rootScope.$safeApply();
                } else {
                    deferred.reject({
                        message: "Null returned by RemoteAction not called with nullOk flag",
                        errorCode: "NULL_RETURN"
                    });
                    $rootScope.$safeApply();
                }
            }
            return {
                send: send,
                standardOptions: standardOpts,
                bulkCreate: send("ngForceController.bulkCreate", standardOpts, false),
                bulkDelete: send("ngForceController.bulkDelete", standardOpts, false),
                bulkUpdate: send("ngForceController.bulkUpdate", standardOpts, false),
                bulkUpsert: send("ngForceController.bulkUpsert", standardOpts, false),
                create: send("ngForceController.create", standardOpts, false),
                clone: send("ngForceController.sObjectKlone", standardOpts, false),
                del: send("ngForceController.del", standardOpts, true),
                describe: send("ngForceController.describe", standardOpts, false),
                describeFieldSet: send("ngForceController.describeFieldSet", standardOpts, false),
                describePicklistValues: send("ngForceController.getPicklistValues", standardOpts, false),
                getObjectType: send("ngForceController.getObjType", standardOpts, false),
                getQueryResultsAsSelect2Data: send("ngForceController.getQueryResultsAsSelect2Data", standardOpts, false),
                query: send("ngForceController.query", {
                    escape: false,
                    timeout: 3e4
                }, false),
                queryFromFieldset: send("ngForceController.queryFromFieldSet", {
                    escape: false,
                    timeout: 3e4
                }, false),
                retrieve: send("ngForceController.retrieve", standardOpts, false),
                search: send("ngForceController.search", standardOpts, false),
                soqlFromFieldSet: send("ngForceController.soqlFromFieldSet", standardOpts, false),
                update: send("ngForceController.updat", standardOpts, true),
                upsert: send("ngForceController.upser", standardOpts, true)
            };
        } ]
    };
});
//# sourceMappingURL=ngForceWithDependencies.min.js.map